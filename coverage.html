
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>argument: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">oras.land/oras/cmd/oras/internal/argument/checker.go (0.0%)</option>
				
				<option value="file1">oras.land/oras/cmd/oras/internal/command/logger.go (100.0%)</option>
				
				<option value="file2">oras.land/oras/cmd/oras/internal/display/content/discard.go (0.0%)</option>
				
				<option value="file3">oras.land/oras/cmd/oras/internal/display/content/manifest_fetch.go (0.0%)</option>
				
				<option value="file4">oras.land/oras/cmd/oras/internal/display/content/manifest_index.go (61.5%)</option>
				
				<option value="file5">oras.land/oras/cmd/oras/internal/display/handler.go (34.0%)</option>
				
				<option value="file6">oras.land/oras/cmd/oras/internal/display/metadata/descriptor/manifest_fetch.go (0.0%)</option>
				
				<option value="file7">oras.land/oras/cmd/oras/internal/display/metadata/discard.go (50.0%)</option>
				
				<option value="file8">oras.land/oras/cmd/oras/internal/display/metadata/json/attach.go (0.0%)</option>
				
				<option value="file9">oras.land/oras/cmd/oras/internal/display/metadata/json/discover.go (0.0%)</option>
				
				<option value="file10">oras.land/oras/cmd/oras/internal/display/metadata/json/manifest_fetch.go (0.0%)</option>
				
				<option value="file11">oras.land/oras/cmd/oras/internal/display/metadata/json/pull.go (0.0%)</option>
				
				<option value="file12">oras.land/oras/cmd/oras/internal/display/metadata/json/push.go (0.0%)</option>
				
				<option value="file13">oras.land/oras/cmd/oras/internal/display/metadata/model/attach.go (0.0%)</option>
				
				<option value="file14">oras.land/oras/cmd/oras/internal/display/metadata/model/descriptor.go (0.0%)</option>
				
				<option value="file15">oras.land/oras/cmd/oras/internal/display/metadata/model/discover.go (0.0%)</option>
				
				<option value="file16">oras.land/oras/cmd/oras/internal/display/metadata/model/fetched.go (0.0%)</option>
				
				<option value="file17">oras.land/oras/cmd/oras/internal/display/metadata/model/pull.go (0.0%)</option>
				
				<option value="file18">oras.land/oras/cmd/oras/internal/display/metadata/model/push.go (0.0%)</option>
				
				<option value="file19">oras.land/oras/cmd/oras/internal/display/metadata/model/tag.go (0.0%)</option>
				
				<option value="file20">oras.land/oras/cmd/oras/internal/display/metadata/table/discover.go (97.4%)</option>
				
				<option value="file21">oras.land/oras/cmd/oras/internal/display/metadata/template/attach.go (0.0%)</option>
				
				<option value="file22">oras.land/oras/cmd/oras/internal/display/metadata/template/discover.go (0.0%)</option>
				
				<option value="file23">oras.land/oras/cmd/oras/internal/display/metadata/template/manifest_fetch.go (0.0%)</option>
				
				<option value="file24">oras.land/oras/cmd/oras/internal/display/metadata/template/pull.go (0.0%)</option>
				
				<option value="file25">oras.land/oras/cmd/oras/internal/display/metadata/template/push.go (0.0%)</option>
				
				<option value="file26">oras.land/oras/cmd/oras/internal/display/metadata/text/attach.go (9.1%)</option>
				
				<option value="file27">oras.land/oras/cmd/oras/internal/display/metadata/text/blob_delete.go (0.0%)</option>
				
				<option value="file28">oras.land/oras/cmd/oras/internal/display/metadata/text/blob_push.go (0.0%)</option>
				
				<option value="file29">oras.land/oras/cmd/oras/internal/display/metadata/text/copy.go (20.0%)</option>
				
				<option value="file30">oras.land/oras/cmd/oras/internal/display/metadata/text/manifest_delete.go (0.0%)</option>
				
				<option value="file31">oras.land/oras/cmd/oras/internal/display/metadata/text/manifest_index.go (0.0%)</option>
				
				<option value="file32">oras.land/oras/cmd/oras/internal/display/metadata/text/manifest_push.go (0.0%)</option>
				
				<option value="file33">oras.land/oras/cmd/oras/internal/display/metadata/text/pull.go (8.3%)</option>
				
				<option value="file34">oras.land/oras/cmd/oras/internal/display/metadata/text/push.go (50.0%)</option>
				
				<option value="file35">oras.land/oras/cmd/oras/internal/display/metadata/text/resolve.go (0.0%)</option>
				
				<option value="file36">oras.land/oras/cmd/oras/internal/display/metadata/text/tag.go (0.0%)</option>
				
				<option value="file37">oras.land/oras/cmd/oras/internal/display/metadata/tree/discover.go (89.7%)</option>
				
				<option value="file38">oras.land/oras/cmd/oras/internal/display/status/console/console.go (95.5%)</option>
				
				<option value="file39">oras.land/oras/cmd/oras/internal/display/status/discard.go (17.9%)</option>
				
				<option value="file40">oras.land/oras/cmd/oras/internal/display/status/progress/humanize/bytes.go (92.9%)</option>
				
				<option value="file41">oras.land/oras/cmd/oras/internal/display/status/progress/manager.go (87.7%)</option>
				
				<option value="file42">oras.land/oras/cmd/oras/internal/display/status/progress/messenger.go (100.0%)</option>
				
				<option value="file43">oras.land/oras/cmd/oras/internal/display/status/progress/speed.go (100.0%)</option>
				
				<option value="file44">oras.land/oras/cmd/oras/internal/display/status/progress/spinner.go (100.0%)</option>
				
				<option value="file45">oras.land/oras/cmd/oras/internal/display/status/progress/status.go (100.0%)</option>
				
				<option value="file46">oras.land/oras/cmd/oras/internal/display/status/text.go (53.4%)</option>
				
				<option value="file47">oras.land/oras/cmd/oras/internal/display/status/track/reader.go (84.6%)</option>
				
				<option value="file48">oras.land/oras/cmd/oras/internal/display/status/track/target.go (78.9%)</option>
				
				<option value="file49">oras.land/oras/cmd/oras/internal/display/status/tty.go (87.7%)</option>
				
				<option value="file50">oras.land/oras/cmd/oras/internal/display/status/utils.go (100.0%)</option>
				
				<option value="file51">oras.land/oras/cmd/oras/internal/errors/errors.go (40.0%)</option>
				
				<option value="file52">oras.land/oras/cmd/oras/internal/fileref/unix.go (100.0%)</option>
				
				<option value="file53">oras.land/oras/cmd/oras/internal/manifest/manifest.go (100.0%)</option>
				
				<option value="file54">oras.land/oras/cmd/oras/internal/option/annotation.go (100.0%)</option>
				
				<option value="file55">oras.land/oras/cmd/oras/internal/option/applier.go (100.0%)</option>
				
				<option value="file56">oras.land/oras/cmd/oras/internal/option/binary_target.go (0.0%)</option>
				
				<option value="file57">oras.land/oras/cmd/oras/internal/option/cache.go (85.7%)</option>
				
				<option value="file58">oras.land/oras/cmd/oras/internal/option/common.go (0.0%)</option>
				
				<option value="file59">oras.land/oras/cmd/oras/internal/option/confirmation.go (92.9%)</option>
				
				<option value="file60">oras.land/oras/cmd/oras/internal/option/descriptor.go (80.0%)</option>
				
				<option value="file61">oras.land/oras/cmd/oras/internal/option/format.go (0.0%)</option>
				
				<option value="file62">oras.land/oras/cmd/oras/internal/option/packer.go (67.6%)</option>
				
				<option value="file63">oras.land/oras/cmd/oras/internal/option/parser.go (100.0%)</option>
				
				<option value="file64">oras.land/oras/cmd/oras/internal/option/platform.go (91.7%)</option>
				
				<option value="file65">oras.land/oras/cmd/oras/internal/option/pretty.go (100.0%)</option>
				
				<option value="file66">oras.land/oras/cmd/oras/internal/option/remote.go (72.2%)</option>
				
				<option value="file67">oras.land/oras/cmd/oras/internal/option/spec.go (0.0%)</option>
				
				<option value="file68">oras.land/oras/cmd/oras/internal/option/target.go (53.9%)</option>
				
				<option value="file69">oras.land/oras/cmd/oras/internal/option/terminal.go (77.8%)</option>
				
				<option value="file70">oras.land/oras/cmd/oras/internal/option/verbose.go (0.0%)</option>
				
				<option value="file71">oras.land/oras/cmd/oras/internal/output/json.go (88.9%)</option>
				
				<option value="file72">oras.land/oras/cmd/oras/internal/output/print.go (88.5%)</option>
				
				<option value="file73">oras.land/oras/cmd/oras/internal/output/template.go (71.4%)</option>
				
				<option value="file74">oras.land/oras/cmd/oras/main.go (0.0%)</option>
				
				<option value="file75">oras.land/oras/cmd/oras/root/attach.go (0.0%)</option>
				
				<option value="file76">oras.land/oras/cmd/oras/root/blob/cmd.go (0.0%)</option>
				
				<option value="file77">oras.land/oras/cmd/oras/root/blob/delete.go (0.0%)</option>
				
				<option value="file78">oras.land/oras/cmd/oras/root/blob/fetch.go (34.2%)</option>
				
				<option value="file79">oras.land/oras/cmd/oras/root/blob/push.go (20.7%)</option>
				
				<option value="file80">oras.land/oras/cmd/oras/root/cmd.go (0.0%)</option>
				
				<option value="file81">oras.land/oras/cmd/oras/root/cp.go (35.7%)</option>
				
				<option value="file82">oras.land/oras/cmd/oras/root/discover.go (0.0%)</option>
				
				<option value="file83">oras.land/oras/cmd/oras/root/file.go (0.0%)</option>
				
				<option value="file84">oras.land/oras/cmd/oras/root/login.go (0.0%)</option>
				
				<option value="file85">oras.land/oras/cmd/oras/root/logout.go (0.0%)</option>
				
				<option value="file86">oras.land/oras/cmd/oras/root/manifest/cmd.go (0.0%)</option>
				
				<option value="file87">oras.land/oras/cmd/oras/root/manifest/delete.go (0.0%)</option>
				
				<option value="file88">oras.land/oras/cmd/oras/root/manifest/fetch.go (8.0%)</option>
				
				<option value="file89">oras.land/oras/cmd/oras/root/manifest/fetch_config.go (0.0%)</option>
				
				<option value="file90">oras.land/oras/cmd/oras/root/manifest/index/cmd.go (0.0%)</option>
				
				<option value="file91">oras.land/oras/cmd/oras/root/manifest/index/create.go (25.0%)</option>
				
				<option value="file92">oras.land/oras/cmd/oras/root/manifest/index/update.go (26.9%)</option>
				
				<option value="file93">oras.land/oras/cmd/oras/root/manifest/push.go (0.0%)</option>
				
				<option value="file94">oras.land/oras/cmd/oras/root/pull.go (3.1%)</option>
				
				<option value="file95">oras.land/oras/cmd/oras/root/push.go (10.6%)</option>
				
				<option value="file96">oras.land/oras/cmd/oras/root/repo/cmd.go (0.0%)</option>
				
				<option value="file97">oras.land/oras/cmd/oras/root/repo/ls.go (0.0%)</option>
				
				<option value="file98">oras.land/oras/cmd/oras/root/repo/tags.go (0.0%)</option>
				
				<option value="file99">oras.land/oras/cmd/oras/root/resolve.go (0.0%)</option>
				
				<option value="file100">oras.land/oras/cmd/oras/root/tag.go (0.0%)</option>
				
				<option value="file101">oras.land/oras/cmd/oras/root/version.go (0.0%)</option>
				
				<option value="file102">oras.land/oras/internal/cache/target.go (70.2%)</option>
				
				<option value="file103">oras.land/oras/internal/contentutil/reference.go (100.0%)</option>
				
				<option value="file104">oras.land/oras/internal/contentutil/target.go (5.0%)</option>
				
				<option value="file105">oras.land/oras/internal/credential/credential.go (100.0%)</option>
				
				<option value="file106">oras.land/oras/internal/credential/store.go (80.0%)</option>
				
				<option value="file107">oras.land/oras/internal/crypto/certificate.go (100.0%)</option>
				
				<option value="file108">oras.land/oras/internal/descriptor/descriptor.go (100.0%)</option>
				
				<option value="file109">oras.land/oras/internal/file/file.go (93.2%)</option>
				
				<option value="file110">oras.land/oras/internal/graph/graph.go (75.4%)</option>
				
				<option value="file111">oras.land/oras/internal/io/io.go (93.3%)</option>
				
				<option value="file112">oras.land/oras/internal/listener/tag.go (56.2%)</option>
				
				<option value="file113">oras.land/oras/internal/mock/repository.go (0.0%)</option>
				
				<option value="file114">oras.land/oras/internal/net/net.go (100.0%)</option>
				
				<option value="file115">oras.land/oras/internal/progress/tracker.go (94.4%)</option>
				
				<option value="file116">oras.land/oras/internal/registryutil/auth.go (0.0%)</option>
				
				<option value="file117">oras.land/oras/internal/repository/repository.go (100.0%)</option>
				
				<option value="file118">oras.land/oras/internal/testutils/console.go (86.4%)</option>
				
				<option value="file119">oras.land/oras/internal/testutils/error_fetcher.go (100.0%)</option>
				
				<option value="file120">oras.land/oras/internal/testutils/fetcher.go (89.3%)</option>
				
				<option value="file121">oras.land/oras/internal/testutils/prompt.go (100.0%)</option>
				
				<option value="file122">oras.land/oras/internal/testutils/writer_failure.go (100.0%)</option>
				
				<option value="file123">oras.land/oras/internal/trace/context.go (61.5%)</option>
				
				<option value="file124">oras.land/oras/internal/trace/text_formatter.go (100.0%)</option>
				
				<option value="file125">oras.land/oras/internal/trace/transport.go (56.2%)</option>
				
				<option value="file126">oras.land/oras/internal/tree/node.go (100.0%)</option>
				
				<option value="file127">oras.land/oras/internal/tree/printer.go (73.7%)</option>
				
				<option value="file128">oras.land/oras/internal/version/version.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package argument

import "fmt"

// Exactly checks if the number of arguments is exactly cnt.
func Exactly(cnt int) func(args []string) (bool, string) <span class="cov0" title="0">{
        return func(args []string) (bool, string) </span><span class="cov0" title="0">{
                return len(args) == cnt, fmt.Sprintf("exactly %d argument", cnt)
        }</span>
}

// AtLeast checks if the number of arguments is larger or equal to cnt.
func AtLeast(cnt int) func(args []string) (bool, string) <span class="cov0" title="0">{
        return func(args []string) (bool, string) </span><span class="cov0" title="0">{
                return len(args) &gt;= cnt, fmt.Sprintf("at least %d argument", cnt)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package command

import (
        "context"

        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/internal/trace"
)

// GetLogger returns a new FieldLogger and an associated Context derived from command context.
func GetLogger(cmd *cobra.Command, opts *option.Common) (context.Context, logrus.FieldLogger) <span class="cov10" title="3">{
        ctx, logger := trace.NewLogger(cmd.Context(), opts.Debug)
        cmd.SetContext(ctx)
        return ctx, logger
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package content

import ocispec "github.com/opencontainers/image-spec/specs-go/v1"

type DiscardHandler struct{}

// OnContentFetched implements ManifestFetchHandler.
func (DiscardHandler) OnContentFetched(ocispec.Descriptor, []byte) error <span class="cov0" title="0">{
        return nil
}</span>

// OnContentCreated implements ManifestIndexCreateHandler.
func (DiscardHandler) OnContentCreated([]byte) error <span class="cov0" title="0">{
        return nil
}</span>

// NewDiscardHandler returns a new discard handler.
func NewDiscardHandler() DiscardHandler <span class="cov0" title="0">{
        return DiscardHandler{}
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package content

import (
        "fmt"
        "io"
        "os"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/output"
)

// manifestFetch handles raw content output.
type manifestFetch struct {
        pretty     bool
        stdout     io.Writer
        outputPath string
}

func (h *manifestFetch) OnContentFetched(desc ocispec.Descriptor, manifest []byte) (eventErr error) <span class="cov0" title="0">{
        out := h.stdout
        if h.outputPath != "-" &amp;&amp; h.outputPath != "" </span><span class="cov0" title="0">{
                f, err := os.Create(h.outputPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open %q: %w", h.outputPath, err)
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err := f.Close(); eventErr == nil </span><span class="cov0" title="0">{
                                eventErr = err
                        }</span>
                }()
                <span class="cov0" title="0">out = f</span>
        }
        <span class="cov0" title="0">return output.PrintJSON(out, manifest, h.pretty)</span>
}

// NewManifestFetchHandler creates a new handler.
func NewManifestFetchHandler(out io.Writer, pretty bool, outputPath string) ManifestFetchHandler <span class="cov0" title="0">{
        // ignore --pretty when output to a file
        if outputPath != "" &amp;&amp; outputPath != "-" </span><span class="cov0" title="0">{
                pretty = false
        }</span>
        <span class="cov0" title="0">return &amp;manifestFetch{
                pretty:     pretty,
                stdout:     out,
                outputPath: outputPath,
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package content

import (
        "fmt"
        "io"
        "os"

        "oras.land/oras/cmd/oras/internal/output"
)

// manifestIndexCreate handles raw content output.
type manifestIndexCreate struct {
        pretty     bool
        stdout     io.Writer
        outputPath string
}

// NewManifestIndexCreateHandler creates a new handler.
func NewManifestIndexCreateHandler(out io.Writer, pretty bool, outputPath string) ManifestIndexCreateHandler <span class="cov8" title="1">{
        // ignore --pretty when output to a file
        if outputPath != "" &amp;&amp; outputPath != "-" </span><span class="cov8" title="1">{
                pretty = false
        }</span>
        <span class="cov8" title="1">return &amp;manifestIndexCreate{
                pretty:     pretty,
                stdout:     out,
                outputPath: outputPath,
        }</span>
}

// OnContentCreated is called after index content is created.
func (h *manifestIndexCreate) OnContentCreated(manifest []byte) (eventErr error) <span class="cov8" title="1">{
        out := h.stdout
        if h.outputPath != "" &amp;&amp; h.outputPath != "-" </span><span class="cov8" title="1">{
                f, err := os.Create(h.outputPath)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to open %q: %w", h.outputPath, err)
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err := f.Close(); eventErr == nil </span><span class="cov0" title="0">{
                                eventErr = err
                        }</span>
                }()
                <span class="cov0" title="0">out = f</span>
        }
        <span class="cov0" title="0">return output.PrintJSON(out, manifest, h.pretty)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package display

import (
        "io"
        "os"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        fetcher "oras.land/oras-go/v2/content"

        "oras.land/oras/cmd/oras/internal/display/content"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/display/metadata/descriptor"
        "oras.land/oras/cmd/oras/internal/display/metadata/json"
        "oras.land/oras/cmd/oras/internal/display/metadata/table"
        "oras.land/oras/cmd/oras/internal/display/metadata/template"
        "oras.land/oras/cmd/oras/internal/display/metadata/text"
        "oras.land/oras/cmd/oras/internal/display/metadata/tree"
        "oras.land/oras/cmd/oras/internal/display/status"
        "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/cmd/oras/internal/output"
)

// NewPushHandler returns status and metadata handlers for push command.
func NewPushHandler(printer *output.Printer, format option.Format, tty *os.File, fetcher fetcher.Fetcher) (status.PushHandler, metadata.PushHandler, error) <span class="cov10" title="2">{
        var statusHandler status.PushHandler
        if tty != nil </span><span class="cov1" title="1">{
                statusHandler = status.NewTTYPushHandler(tty, fetcher)
        }</span> else<span class="cov1" title="1"> if format.Type == option.FormatTypeText.Name </span><span class="cov0" title="0">{
                statusHandler = status.NewTextPushHandler(printer, fetcher)
        }</span> else<span class="cov1" title="1"> {
                statusHandler = status.NewDiscardHandler()
        }</span>

        <span class="cov10" title="2">var metadataHandler metadata.PushHandler
        switch format.Type </span>{
        case option.FormatTypeText.Name:<span class="cov1" title="1">
                metadataHandler = text.NewPushHandler(printer)</span>
        case option.FormatTypeJSON.Name:<span class="cov0" title="0">
                metadataHandler = json.NewPushHandler(printer)</span>
        case option.FormatTypeGoTemplate.Name:<span class="cov0" title="0">
                metadataHandler = template.NewPushHandler(printer, format.Template)</span>
        default:<span class="cov1" title="1">
                return nil, nil, errors.UnsupportedFormatTypeError(format.Type)</span>
        }
        <span class="cov1" title="1">return statusHandler, metadataHandler, nil</span>
}

// NewAttachHandler returns status and metadata handlers for attach command.
func NewAttachHandler(printer *output.Printer, format option.Format, tty *os.File, fetcher fetcher.Fetcher) (status.AttachHandler, metadata.AttachHandler, error) <span class="cov1" title="1">{
        var statusHandler status.AttachHandler
        if tty != nil </span><span class="cov1" title="1">{
                statusHandler = status.NewTTYAttachHandler(tty, fetcher)
        }</span> else<span class="cov0" title="0"> if format.Type == option.FormatTypeText.Name </span><span class="cov0" title="0">{
                statusHandler = status.NewTextAttachHandler(printer, fetcher)
        }</span> else<span class="cov0" title="0"> {
                statusHandler = status.NewDiscardHandler()
        }</span>

        <span class="cov1" title="1">var metadataHandler metadata.AttachHandler
        switch format.Type </span>{
        case option.FormatTypeText.Name:<span class="cov1" title="1">
                metadataHandler = text.NewAttachHandler(printer)</span>
        case option.FormatTypeJSON.Name:<span class="cov0" title="0">
                metadataHandler = json.NewAttachHandler(printer)</span>
        case option.FormatTypeGoTemplate.Name:<span class="cov0" title="0">
                metadataHandler = template.NewAttachHandler(printer, format.Template)</span>
        default:<span class="cov0" title="0">
                return nil, nil, errors.UnsupportedFormatTypeError(format.Type)</span>
        }
        <span class="cov1" title="1">return statusHandler, metadataHandler, nil</span>
}

// NewPullHandler returns status and metadata handlers for pull command.
func NewPullHandler(printer *output.Printer, format option.Format, path string, tty *os.File) (status.PullHandler, metadata.PullHandler, error) <span class="cov10" title="2">{
        var statusHandler status.PullHandler
        if tty != nil </span><span class="cov1" title="1">{
                statusHandler = status.NewTTYPullHandler(tty)
        }</span> else<span class="cov1" title="1"> if format.Type == option.FormatTypeText.Name </span><span class="cov0" title="0">{
                statusHandler = status.NewTextPullHandler(printer)
        }</span> else<span class="cov1" title="1"> {
                statusHandler = status.NewDiscardHandler()
        }</span>

        <span class="cov10" title="2">var metadataHandler metadata.PullHandler
        switch format.Type </span>{
        case option.FormatTypeText.Name:<span class="cov1" title="1">
                metadataHandler = text.NewPullHandler(printer)</span>
        case option.FormatTypeJSON.Name:<span class="cov0" title="0">
                metadataHandler = json.NewPullHandler(printer, path)</span>
        case option.FormatTypeGoTemplate.Name:<span class="cov0" title="0">
                metadataHandler = template.NewPullHandler(printer, path, format.Template)</span>
        default:<span class="cov1" title="1">
                return nil, nil, errors.UnsupportedFormatTypeError(format.Type)</span>
        }
        <span class="cov1" title="1">return statusHandler, metadataHandler, nil</span>
}

// NewDiscoverHandler returns status and metadata handlers for discover command.
func NewDiscoverHandler(out io.Writer, format option.Format, path string, rawReference string, desc ocispec.Descriptor, verbose bool, tty *os.File) (metadata.DiscoverHandler, error) <span class="cov0" title="0">{
        var handler metadata.DiscoverHandler
        switch format.Type </span>{
        case option.FormatTypeTree.Name:<span class="cov0" title="0">
                handler = tree.NewDiscoverHandler(out, path, desc, verbose, tty)</span>
        case option.FormatTypeTable.Name:<span class="cov0" title="0">
                handler = table.NewDiscoverHandler(out, rawReference, desc, verbose)</span>
        case option.FormatTypeJSON.Name:<span class="cov0" title="0">
                handler = json.NewDiscoverHandler(out, desc, path)</span>
        case option.FormatTypeGoTemplate.Name:<span class="cov0" title="0">
                handler = template.NewDiscoverHandler(out, desc, path, format.Template)</span>
        default:<span class="cov0" title="0">
                return nil, errors.UnsupportedFormatTypeError(format.Type)</span>
        }
        <span class="cov0" title="0">return handler, nil</span>
}

// NewManifestFetchHandler returns a manifest fetch handler.
func NewManifestFetchHandler(out io.Writer, format option.Format, outputDescriptor, pretty bool, outputPath string) (metadata.ManifestFetchHandler, content.ManifestFetchHandler, error) <span class="cov1" title="1">{
        var metadataHandler metadata.ManifestFetchHandler
        var contentHandler content.ManifestFetchHandler

        switch format.Type </span>{
        case option.FormatTypeText.Name:<span class="cov0" title="0">
                // raw
                if outputDescriptor </span><span class="cov0" title="0">{
                        metadataHandler = descriptor.NewManifestFetchHandler(out, pretty)
                }</span> else<span class="cov0" title="0"> {
                        metadataHandler = metadata.NewDiscardHandler()
                }</span>
        case option.FormatTypeJSON.Name:<span class="cov0" title="0">
                // json
                metadataHandler = json.NewManifestFetchHandler(out)
                if outputPath == "" </span><span class="cov0" title="0">{
                        contentHandler = content.NewDiscardHandler()
                }</span>
        case option.FormatTypeGoTemplate.Name:<span class="cov0" title="0">
                // go template
                metadataHandler = template.NewManifestFetchHandler(out, format.Template)
                if outputPath == "" </span><span class="cov0" title="0">{
                        contentHandler = content.NewDiscardHandler()
                }</span>
        default:<span class="cov1" title="1">
                return nil, nil, errors.UnsupportedFormatTypeError(format.Type)</span>
        }

        <span class="cov0" title="0">if contentHandler == nil </span><span class="cov0" title="0">{
                contentHandler = content.NewManifestFetchHandler(out, pretty, outputPath)
        }</span>
        <span class="cov0" title="0">return metadataHandler, contentHandler, nil</span>
}

// NewTagHandler returns a tag handler.
func NewTagHandler(printer *output.Printer, target option.Target) metadata.TagHandler <span class="cov0" title="0">{
        return text.NewTagHandler(printer, target)
}</span>

// NewManifestPushHandler returns a manifest push handler.
func NewManifestPushHandler(printer *output.Printer, outputDescriptor bool, pretty bool, desc ocispec.Descriptor, target *option.Target) (status.ManifestPushHandler, metadata.ManifestPushHandler) <span class="cov0" title="0">{
        if outputDescriptor </span><span class="cov0" title="0">{
                return status.NewDiscardHandler(), metadata.NewDiscardHandler()
        }</span>
        <span class="cov0" title="0">return status.NewTextManifestPushHandler(printer, desc), text.NewManifestPushHandler(printer, target)</span>
}

// NewManifestDeleteHandler returns a manifest delete handler.
func NewManifestDeleteHandler(printer *output.Printer, target *option.Target) metadata.ManifestDeleteHandler <span class="cov0" title="0">{
        return text.NewManifestDeleteHandler(printer, target)
}</span>

// NewManifestIndexCreateHandler returns status, metadata and content handlers for index create command.
func NewManifestIndexCreateHandler(outputPath string, printer *output.Printer, pretty bool) (status.ManifestIndexCreateHandler, metadata.ManifestIndexCreateHandler, content.ManifestIndexCreateHandler) <span class="cov0" title="0">{
        var statusHandler status.ManifestIndexCreateHandler
        var metadataHandler metadata.ManifestIndexCreateHandler
        var contentHandler content.ManifestIndexCreateHandler
        switch outputPath </span>{
        case "":<span class="cov0" title="0">
                statusHandler = status.NewTextManifestIndexCreateHandler(printer)
                metadataHandler = text.NewManifestIndexCreateHandler(printer)
                contentHandler = content.NewDiscardHandler()</span>
        case "-":<span class="cov0" title="0">
                statusHandler = status.NewDiscardHandler()
                metadataHandler = metadata.NewDiscardHandler()
                contentHandler = content.NewManifestIndexCreateHandler(printer, pretty, outputPath)</span>
        default:<span class="cov0" title="0">
                statusHandler = status.NewTextManifestIndexCreateHandler(printer)
                metadataHandler = text.NewManifestIndexCreateHandler(printer)
                contentHandler = content.NewManifestIndexCreateHandler(printer, pretty, outputPath)</span>
        }
        <span class="cov0" title="0">return statusHandler, metadataHandler, contentHandler</span>
}

// NewManifestIndexUpdateHandler returns status, metadata and content handlers for index update command.
func NewManifestIndexUpdateHandler(outputPath string, printer *output.Printer, pretty bool) (
        status.ManifestIndexUpdateHandler,
        metadata.ManifestIndexUpdateHandler,
        content.ManifestIndexUpdateHandler) <span class="cov0" title="0">{
        statusHandler := status.NewTextManifestIndexUpdateHandler(printer)
        metadataHandler := text.NewManifestIndexCreateHandler(printer)
        contentHandler := content.NewManifestIndexCreateHandler(printer, pretty, outputPath)
        switch outputPath </span>{
        case "":<span class="cov0" title="0">
                contentHandler = content.NewDiscardHandler()</span>
        case "-":<span class="cov0" title="0">
                statusHandler = status.NewDiscardHandler()
                metadataHandler = metadata.NewDiscardHandler()</span>
        }
        <span class="cov0" title="0">return statusHandler, metadataHandler, contentHandler</span>
}

// NewCopyHandler returns copy handlers.
func NewCopyHandler(printer *output.Printer, tty *os.File, fetcher fetcher.Fetcher) (status.CopyHandler, metadata.CopyHandler) <span class="cov10" title="2">{
        if tty != nil </span><span class="cov1" title="1">{
                return status.NewTTYCopyHandler(tty), text.NewCopyHandler(printer)
        }</span>
        <span class="cov1" title="1">return status.NewTextCopyHandler(printer, fetcher), text.NewCopyHandler(printer)</span>
}

// NewBlobPushHandler returns blob push handlers.
func NewBlobPushHandler(printer *output.Printer, outputDescriptor bool, pretty bool, desc ocispec.Descriptor, tty *os.File) (status.BlobPushHandler, metadata.BlobPushHandler) <span class="cov0" title="0">{
        if outputDescriptor </span><span class="cov0" title="0">{
                return status.NewDiscardHandler(), metadata.NewDiscardHandler()
        }</span>
        <span class="cov0" title="0">if tty != nil </span><span class="cov0" title="0">{
                return status.NewTTYBlobPushHandler(tty, desc), text.NewBlobPushHandler(printer, desc)
        }</span>
        <span class="cov0" title="0">return status.NewTextBlobPushHandler(printer, desc), text.NewBlobPushHandler(printer, desc)</span>
}

// NewResolveHandler returns a resolve metadata handler.
func NewResolveHandler(printer *output.Printer, fullRef bool, path string) metadata.ResolveHandler <span class="cov0" title="0">{
        return text.NewResolveHandler(printer, fullRef, path)
}</span>

// NewBlobDeleteHandler returns blob delete handlers.
func NewBlobDeleteHandler(printer *output.Printer, target *option.Target) metadata.BlobDeleteHandler <span class="cov0" title="0">{
        return text.NewBlobDeleteHandler(printer, target)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package descriptor

import (
        "encoding/json"
        "fmt"
        "io"
        "oras.land/oras/cmd/oras/internal/output"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
)

// manifestFetchHandler handles metadata descriptor output.
type manifestFetchHandler struct {
        pretty bool
        out    io.Writer
}

// OnFetched implements ManifestFetchHandler.
func (h *manifestFetchHandler) OnFetched(_ string, desc ocispec.Descriptor, _ []byte) error <span class="cov0" title="0">{
        descBytes, err := json.Marshal(desc)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid descriptor: %w", err)
        }</span>
        <span class="cov0" title="0">return output.PrintJSON(h.out, descBytes, h.pretty)</span>
}

// NewManifestFetchHandler creates a new handler.
func NewManifestFetchHandler(out io.Writer, pretty bool) metadata.ManifestFetchHandler <span class="cov0" title="0">{
        return &amp;manifestFetchHandler{
                pretty: pretty,
                out:    out,
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metadata

import (
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/option"
)

type Discard struct{}

// NewDiscardHandler creates a new handler that discards output for all events.
func NewDiscardHandler() Discard <span class="cov10" title="2">{
        return Discard{}
}</span>

// OnFetched implements ManifestFetchHandler.
func (Discard) OnFetched(string, ocispec.Descriptor, []byte) error <span class="cov0" title="0">{
        return nil
}</span>

// OnManifestPushed implements ManifestPushHandler.
func (Discard) OnManifestPushed(ocispec.Descriptor) error <span class="cov1" title="1">{
        return nil
}</span>

// Render implements ManifestPushHandler.
func (Discard) Render() error <span class="cov0" title="0">{
        return nil
}</span>

// OnTagged implements ManifestIndexCreateHandler.
func (Discard) OnTagged(ocispec.Descriptor, string) error <span class="cov1" title="1">{
        return nil
}</span>

// OnIndexCreated implements ManifestIndexCreateHandler.
func (Discard) OnIndexCreated(ocispec.Descriptor) {<span class="cov0" title="0">}</span>

// OnBlobPushed implements BlobPushHandler
func (Discard) OnBlobPushed(target *option.Target) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package json

import (
        "io"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/display/metadata/model"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/cmd/oras/internal/output"
)

// AttachHandler handles json metadata output for attach events.
type AttachHandler struct {
        out  io.Writer
        path string
        root ocispec.Descriptor
}

// NewAttachHandler creates a new handler for attach events.
func NewAttachHandler(out io.Writer) metadata.AttachHandler <span class="cov0" title="0">{
        return &amp;AttachHandler{
                out: out,
        }
}</span>

// OnAttached implements AttachHandler.
func (ah *AttachHandler) OnAttached(target *option.Target, root ocispec.Descriptor, _ ocispec.Descriptor) <span class="cov0" title="0">{
        ah.path = target.Path
        ah.root = root
}</span>

// Render is called when the attach command is completed.
func (ah *AttachHandler) Render() error <span class="cov0" title="0">{
        return output.PrintPrettyJSON(ah.out, model.NewAttach(ah.root, ah.path))
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package json

import (
        "io"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/display/metadata/model"
        "oras.land/oras/cmd/oras/internal/output"
)

// discoverHandler handles json metadata output for discover events.
type discoverHandler struct {
        out   io.Writer
        path  string
        model model.Discover
}

// NewDiscoverHandler creates a new handler for discover events.
func NewDiscoverHandler(out io.Writer, subject ocispec.Descriptor, path string) metadata.DiscoverHandler <span class="cov0" title="0">{
        return &amp;discoverHandler{
                out:   out,
                path:  path,
                model: model.NewDiscover(path, subject),
        }
}</span>

// OnDiscovered implements metadata.DiscoverHandler.
func (h *discoverHandler) OnDiscovered(referrer, subject ocispec.Descriptor) error <span class="cov0" title="0">{
        return h.model.AddReferrer(referrer, subject)
}</span>

// Render implements metadata.DiscoverHandler.
func (h *discoverHandler) Render() error <span class="cov0" title="0">{
        return output.PrintPrettyJSON(h.out, h.model.Root)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package json

import (
        "encoding/json"
        "io"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/display/metadata/model"
        "oras.land/oras/cmd/oras/internal/output"
)

// manifestFetchHandler handles JSON metadata output for manifest fetch events.
type manifestFetchHandler struct {
        out io.Writer
}

// NewManifestFetchHandler creates a new handler for manifest fetch events.
func NewManifestFetchHandler(out io.Writer) metadata.ManifestFetchHandler <span class="cov0" title="0">{
        return &amp;manifestFetchHandler{
                out: out,
        }
}</span>

// OnFetched is called after the manifest fetch is completed.
func (h *manifestFetchHandler) OnFetched(path string, desc ocispec.Descriptor, content []byte) error <span class="cov0" title="0">{
        var manifest map[string]any
        if err := json.Unmarshal(content, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                manifest = nil
        }</span>
        <span class="cov0" title="0">return output.PrintPrettyJSON(h.out, model.NewFetched(path, desc, manifest))</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package json

import (
        "io"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/display/metadata/model"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/cmd/oras/internal/output"
)

// PullHandler handles JSON metadata output for pull events.
type PullHandler struct {
        path   string
        pulled model.Pulled
        out    io.Writer
        root   ocispec.Descriptor
}

// NewPullHandler returns a new handler for Pull events.
func NewPullHandler(out io.Writer, path string) metadata.PullHandler <span class="cov0" title="0">{
        return &amp;PullHandler{
                out:  out,
                path: path,
        }
}</span>

// OnLayerSkipped implements metadata.PullHandler.
func (ph *PullHandler) OnLayerSkipped(ocispec.Descriptor) error <span class="cov0" title="0">{
        return nil
}</span>

// OnFilePulled implements metadata.PullHandler.
func (ph *PullHandler) OnFilePulled(name string, outputDir string, desc ocispec.Descriptor, descPath string) error <span class="cov0" title="0">{
        return ph.pulled.Add(name, outputDir, desc, descPath)
}</span>

// OnPulled implements metadata.PullHandler.
func (ph *PullHandler) OnPulled(_ *option.Target, desc ocispec.Descriptor) <span class="cov0" title="0">{
        ph.root = desc
}</span>

// Render implements metadata.PullHandler.
func (ph *PullHandler) Render() error <span class="cov0" title="0">{
        return output.PrintPrettyJSON(ph.out, model.NewPull(ph.path+"@"+ph.root.Digest.String(), ph.pulled.Files()))
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package json

import (
        "io"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/display/metadata/model"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/cmd/oras/internal/output"
        "oras.land/oras/internal/contentutil"
)

// PushHandler handles JSON metadata output for push events.
type PushHandler struct {
        path   string
        out    io.Writer
        tagged model.Tagged
        root   ocispec.Descriptor
}

// NewPushHandler creates a new handler for push events.
func NewPushHandler(out io.Writer) metadata.PushHandler <span class="cov0" title="0">{
        return &amp;PushHandler{
                out: out,
        }
}</span>

// OnTagged implements metadata.TaggedHandler.
func (ph *PushHandler) OnTagged(desc ocispec.Descriptor, tag string) error <span class="cov0" title="0">{
        ph.tagged.AddTag(tag)
        return nil
}</span>

// OnCopied is called after files are copied.
func (ph *PushHandler) OnCopied(opts *option.Target, root ocispec.Descriptor) error <span class="cov0" title="0">{
        if opts.RawReference != "" &amp;&amp; !contentutil.IsDigest(opts.Reference) </span><span class="cov0" title="0">{
                ph.tagged.AddTag(opts.Reference)
        }</span>
        <span class="cov0" title="0">ph.path = opts.Path
        ph.root = root
        return nil</span>
}

// Render implements PushHandler.
func (ph *PushHandler) Render() error <span class="cov0" title="0">{
        return output.PrintPrettyJSON(ph.out, model.NewPush(ph.root, ph.path, ph.tagged.Tags()))
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package model

import ocispec "github.com/opencontainers/image-spec/specs-go/v1"

// attach contains metadata formatted by oras attach.
type attach struct {
        Descriptor
}

// NewAttach returns a metadata getter for attach command.
func NewAttach(desc ocispec.Descriptor, path string) any <span class="cov0" title="0">{
        return attach{FromDescriptor(path, desc)}
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package model

import (
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
)

// DigestReference is a reference to an artifact with digest.
type DigestReference struct {
        Reference string `json:"reference"`
}

// NewDigestReference creates a new digest reference.
func NewDigestReference(name string, digest string) DigestReference <span class="cov0" title="0">{
        return DigestReference{
                Reference: name + "@" + digest,
        }
}</span>

// Descriptor is a descriptor with digest reference.
// We cannot use ocispec.Descriptor here since the first letter of the json
// annotation key is not uppercase.
type Descriptor struct {
        DigestReference
        ocispec.Descriptor
}

// FromDescriptor converts a OCI descriptor to a descriptor with digest reference.
func FromDescriptor(name string, desc ocispec.Descriptor) Descriptor <span class="cov0" title="0">{
        ret := Descriptor{
                DigestReference: NewDigestReference(name, desc.Digest.String()),
                Descriptor: ocispec.Descriptor{
                        MediaType:    desc.MediaType,
                        Size:         desc.Size,
                        Digest:       desc.Digest,
                        Annotations:  desc.Annotations,
                        ArtifactType: desc.ArtifactType,
                },
        }
        return ret
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package model

import (
        "fmt"

        "github.com/opencontainers/go-digest"
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
)

// Discover is a model for discovered referrers.
type Discover struct {
        name  string
        nodes map[digest.Digest]*Node
        Root  *Node
}

// Node represents a node in the discovered reference tree.
type Node struct {
        Descriptor
        Referrers []*Node `json:"referrers"`
}

// AddReferrer adds a node to the discovered referrers tree.
func (d *Discover) AddReferrer(referrer, subject ocispec.Descriptor) error <span class="cov0" title="0">{
        to, ok := d.nodes[subject.Digest]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected subject descriptor: %v", subject)
        }</span>
        <span class="cov0" title="0">from := NewNode(d.name, referrer)
        d.nodes[from.Digest] = from
        to.Referrers = append(to.Referrers, from)
        return nil</span>
}

// NewDiscover creates a new discover model.
func NewDiscover(path string, root ocispec.Descriptor) Discover <span class="cov0" title="0">{
        treeRoot := NewNode(path, root)
        return Discover{
                name: path,
                nodes: map[digest.Digest]*Node{
                        root.Digest: treeRoot,
                },
                Root: treeRoot,
        }
}</span>

// NewNode creates a new node.
func NewNode(name string, desc ocispec.Descriptor) *Node <span class="cov0" title="0">{
        return &amp;Node{
                Descriptor: FromDescriptor(name, desc),
                Referrers:  []*Node{},
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package model

import ocispec "github.com/opencontainers/image-spec/specs-go/v1"

type fetched struct {
        Descriptor
        Content any `json:"content"`
}

// NewFetched creates a new fetched metadata.
func NewFetched(path string, desc ocispec.Descriptor, content any) any <span class="cov0" title="0">{
        return &amp;fetched{
                Descriptor: FromDescriptor(path, desc),
                Content:    content,
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package model

import (
        "fmt"
        "path/filepath"
        "slices"
        "sync"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras-go/v2/content/file"
)

// File records metadata of a pulled file.
type File struct {
        // Path is the absolute path of the pulled file.
        Path string `json:"path"`
        Descriptor
}

// newFile creates a new file metadata.
func newFile(name string, outputDir string, desc ocispec.Descriptor, descPath string) (File, error) <span class="cov0" title="0">{
        path := name
        if !filepath.IsAbs(name) </span><span class="cov0" title="0">{
                var err error
                path, err = filepath.Abs(filepath.Join(outputDir, name))
                // not likely to go wrong since the file has already be written to file store
                if err != nil </span><span class="cov0" title="0">{
                        return File{}, fmt.Errorf("failed to get absolute path of pulled file %s: %w", name, err)
                }</span>
        } else<span class="cov0" title="0"> {
                path = filepath.Clean(path)
        }</span>
        <span class="cov0" title="0">if desc.Annotations[file.AnnotationUnpack] == "true" </span><span class="cov0" title="0">{
                path += string(filepath.Separator)
        }</span>
        <span class="cov0" title="0">return File{
                Path:       path,
                Descriptor: FromDescriptor(descPath, desc),
        }, nil</span>
}

type pull struct {
        DigestReference
        Files []File `json:"files"`
}

// NewPull creates a new metadata struct for pull command.
func NewPull(digestReference string, files []File) any <span class="cov0" title="0">{
        return pull{
                DigestReference: DigestReference{
                        Reference: digestReference,
                },
                Files: files,
        }
}</span>

// Pulled records all pulled files.
type Pulled struct {
        lock  sync.Mutex
        files []File
}

// Files returns all pulled files.
func (p *Pulled) Files() []File <span class="cov0" title="0">{
        p.lock.Lock()
        defer p.lock.Unlock()
        return slices.Clone(p.files)
}</span>

// Add adds a pulled file.
func (p *Pulled) Add(name string, outputDir string, desc ocispec.Descriptor, descPath string) error <span class="cov0" title="0">{
        p.lock.Lock()
        defer p.lock.Unlock()
        file, err := newFile(name, outputDir, desc, descPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">p.files = append(p.files, file)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package model

import (
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
)

// push contains metadata formatted by oras push.
type push struct {
        Descriptor
        ReferenceAsTags []string `json:"referenceAsTags"`
}

// NewPush returns a metadata getter for push command.
func NewPush(desc ocispec.Descriptor, path string, tags []string) any <span class="cov0" title="0">{
        var refAsTags []string
        for _, tag := range tags </span><span class="cov0" title="0">{
                refAsTags = append(refAsTags, path+":"+tag)
        }</span>
        <span class="cov0" title="0">return push{
                Descriptor:      FromDescriptor(path, desc),
                ReferenceAsTags: refAsTags,
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package model

import (
        "slices"
        "sync"
)

// Tagged contains metadata formatted by oras Tagged.
type Tagged struct {
        tags []string
        lock sync.RWMutex
}

// AddTag adds a tag to the metadata.
func (tag *Tagged) AddTag(t string) <span class="cov0" title="0">{
        tag.lock.Lock()
        defer tag.lock.Unlock()

        tag.tags = append(tag.tags, t)
}</span>

// Tags returns the tags.
func (tag *Tagged) Tags() []string <span class="cov0" title="0">{
        tag.lock.RLock()
        defer tag.lock.RUnlock()
        slices.Sort(tag.tags)
        return tag.tags
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package table

import (
        "fmt"
        "io"
        "strings"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras-go/v2/content"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/output"
)

// discoverHandler handles json metadata output for discover events.
type discoverHandler struct {
        out          io.Writer
        rawReference string
        root         ocispec.Descriptor
        verbose      bool
        referrers    []ocispec.Descriptor
}

// NewDiscoverHandler creates a new handler for discover events.
func NewDiscoverHandler(out io.Writer, rawReference string, root ocispec.Descriptor, verbose bool) metadata.DiscoverHandler <span class="cov7" title="5">{
        return &amp;discoverHandler{
                out:          out,
                rawReference: rawReference,
                root:         root,
                verbose:      verbose,
        }
}</span>

// OnDiscovered implements metadata.DiscoverHandler.
func (h *discoverHandler) OnDiscovered(referrer, subject ocispec.Descriptor) error <span class="cov7" title="5">{
        if !content.Equal(subject, h.root) </span><span class="cov1" title="1">{
                return fmt.Errorf("unexpected subject descriptor: %v", subject)
        }</span>
        <span class="cov6" title="4">h.referrers = append(h.referrers, referrer)
        return nil</span>
}

// Render implements metadata.DiscoverHandler.
func (h *discoverHandler) Render() (err error) <span class="cov9" title="9">{
        if n := len(h.referrers); n != 1 </span><span class="cov8" title="7">{
                _, err = fmt.Fprintln(h.out, "Discovered", n, "artifacts referencing", h.rawReference)
        }</span> else<span class="cov3" title="2"> {
                _, err = fmt.Fprintln(h.out, "Discovered", n, "artifact referencing", h.rawReference)
        }</span>
        <span class="cov9" title="9">if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov9" title="8">_, err = fmt.Fprintln(h.out, "Digest:", h.root.Digest)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov8" title="7">if len(h.referrers) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov8" title="6">_, err = fmt.Fprintln(h.out)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov7" title="5">return h.printDiscoveredReferrersTable()</span>
}

func (h *discoverHandler) printDiscoveredReferrersTable() (err error) <span class="cov7" title="5">{
        typeNameTitle := "Artifact Type"
        typeNameLength := len(typeNameTitle)
        for _, ref := range h.referrers </span><span class="cov9" title="8">{
                if length := len(ref.ArtifactType); length &gt; typeNameLength </span><span class="cov7" title="5">{
                        typeNameLength = length
                }</span>
        }

        <span class="cov7" title="5">printKey := func(key string, value interface{}) (err error) </span><span class="cov10" title="10">{
                _, err = fmt.Fprintln(h.out, key, strings.Repeat(" ", typeNameLength-len(key)+1), value)
                return err
        }</span>

        <span class="cov7" title="5">err = printKey(typeNameTitle, "Digest")
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov6" title="4">for _, ref := range h.referrers </span><span class="cov7" title="5">{
                err = printKey(ref.ArtifactType, ref.Digest)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov6" title="4">if h.verbose </span><span class="cov1" title="1">{
                        if err := output.PrintPrettyJSON(h.out, ref); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error printing JSON: %w", err)
                        }</span>
                }
        }
        <span class="cov5" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package template

import (
        "io"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/display/metadata/model"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/cmd/oras/internal/output"
)

// AttachHandler handles go-template metadata output for attach events.
type AttachHandler struct {
        template string
        out      io.Writer
        path     string
        root     ocispec.Descriptor
}

// NewAttachHandler returns a new handler for attach metadata events.
func NewAttachHandler(out io.Writer, template string) metadata.AttachHandler <span class="cov0" title="0">{
        return &amp;AttachHandler{
                out:      out,
                template: template,
        }
}</span>

// OnAttached implements AttachHandler.
func (ah *AttachHandler) OnAttached(target *option.Target, root ocispec.Descriptor, _ ocispec.Descriptor) <span class="cov0" title="0">{
        ah.path = target.Path
        ah.root = root
}</span>

// Render formats the metadata of attach command.
func (ah *AttachHandler) Render() error <span class="cov0" title="0">{
        return output.ParseAndWrite(ah.out, model.NewAttach(ah.root, ah.path), ah.template)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package template

import (
        "io"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/display/metadata/model"
        "oras.land/oras/cmd/oras/internal/output"
)

// discoverHandler handles json metadata output for discover events.
type discoverHandler struct {
        template string
        path     string
        out      io.Writer
        model    model.Discover
}

// NewDiscoverHandler creates a new handler for discover events.
func NewDiscoverHandler(out io.Writer, root ocispec.Descriptor, path string, template string) metadata.DiscoverHandler <span class="cov0" title="0">{
        return &amp;discoverHandler{
                out:      out,
                path:     path,
                template: template,
                model:    model.NewDiscover(path, root),
        }
}</span>

// OnDiscovered implements metadata.DiscoverHandler.
func (h *discoverHandler) OnDiscovered(referrer, subject ocispec.Descriptor) error <span class="cov0" title="0">{
        return h.model.AddReferrer(referrer, subject)
}</span>

// Render implements metadata.DiscoverHandler.
func (h *discoverHandler) Render() error <span class="cov0" title="0">{
        return output.ParseAndWrite(h.out, h.model.Root, h.template)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package template

import (
        "encoding/json"
        "io"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/display/metadata/model"
        "oras.land/oras/cmd/oras/internal/output"
)

// manifestFetchHandler handles JSON metadata output for manifest fetch events.
type manifestFetchHandler struct {
        template string
        out      io.Writer
}

// NewManifestFetchHandler creates a new handler for manifest fetch events.
func NewManifestFetchHandler(out io.Writer, template string) metadata.ManifestFetchHandler <span class="cov0" title="0">{
        return &amp;manifestFetchHandler{
                template: template,
                out:      out,
        }
}</span>

// OnFetched is called after the manifest fetch is completed.
func (h *manifestFetchHandler) OnFetched(path string, desc ocispec.Descriptor, content []byte) error <span class="cov0" title="0">{
        var manifest map[string]any
        if err := json.Unmarshal(content, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                manifest = nil
        }</span>
        <span class="cov0" title="0">return output.ParseAndWrite(h.out, model.NewFetched(path, desc, manifest), h.template)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package template

import (
        "io"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/display/metadata/model"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/cmd/oras/internal/output"
)

// PullHandler handles text metadata output for pull events.
type PullHandler struct {
        template string
        path     string
        out      io.Writer
        pulled   model.Pulled
        root     ocispec.Descriptor
}

// NewPullHandler returns a new handler for pull events.
func NewPullHandler(out io.Writer, path string, template string) metadata.PullHandler <span class="cov0" title="0">{
        return &amp;PullHandler{
                path:     path,
                template: template,
                out:      out,
        }
}</span>

// OnPulled implements metadata.PullHandler.
func (ph *PullHandler) OnPulled(_ *option.Target, desc ocispec.Descriptor) <span class="cov0" title="0">{
        ph.root = desc
}</span>

// Render implements metadata.PullHandler.
func (ph *PullHandler) Render() error <span class="cov0" title="0">{
        return output.ParseAndWrite(ph.out, model.NewPull(ph.path+"@"+ph.root.Digest.String(), ph.pulled.Files()), ph.template)
}</span>

// OnFilePulled implements metadata.PullHandler.
func (ph *PullHandler) OnFilePulled(name string, outputDir string, desc ocispec.Descriptor, descPath string) error <span class="cov0" title="0">{
        return ph.pulled.Add(name, outputDir, desc, descPath)
}</span>

// OnLayerSkipped implements metadata.PullHandler.
func (ph *PullHandler) OnLayerSkipped(ocispec.Descriptor) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package template

import (
        "io"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/display/metadata/model"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/cmd/oras/internal/output"
        "oras.land/oras/internal/contentutil"
)

// PushHandler handles go-template metadata output for push events.
type PushHandler struct {
        template string
        path     string
        tagged   model.Tagged
        out      io.Writer
        root     ocispec.Descriptor
}

// NewPushHandler returns a new handler for push events.
func NewPushHandler(out io.Writer, template string) metadata.PushHandler <span class="cov0" title="0">{
        return &amp;PushHandler{
                out:      out,
                template: template,
        }
}</span>

// OnTagged implements metadata.TaggedHandler.
func (ph *PushHandler) OnTagged(desc ocispec.Descriptor, tag string) error <span class="cov0" title="0">{
        ph.tagged.AddTag(tag)
        return nil
}</span>

// OnCopied is called after files are copied.
func (ph *PushHandler) OnCopied(opts *option.Target, root ocispec.Descriptor) error <span class="cov0" title="0">{
        if opts.RawReference != "" &amp;&amp; !contentutil.IsDigest(opts.Reference) </span><span class="cov0" title="0">{
                ph.tagged.AddTag(opts.Reference)
        }</span>
        <span class="cov0" title="0">ph.path = opts.Path
        ph.root = root
        return nil</span>
}

// Render implements PushHandler.
func (ph *PushHandler) Render() error <span class="cov0" title="0">{
        return output.ParseAndWrite(ph.out, model.NewPush(ph.root, ph.path, ph.tagged.Tags()), ph.template)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package text

import (
        "fmt"
        "strings"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/cmd/oras/internal/output"
)

// AttachHandler handles text metadata output for attach events.
type AttachHandler struct {
        printer                 *output.Printer
        subjectDisplayReference string
        root                    ocispec.Descriptor
}

// NewAttachHandler returns a new handler for attach events.
func NewAttachHandler(printer *output.Printer) metadata.AttachHandler <span class="cov8" title="1">{
        return &amp;AttachHandler{
                printer: printer,
        }
}</span>

// OnAttached implements AttachHandler.
func (ah *AttachHandler) OnAttached(target *option.Target, root ocispec.Descriptor, subject ocispec.Descriptor) <span class="cov0" title="0">{
        ah.root = root
        if strings.HasSuffix(target.RawReference, subject.Digest.String()) </span><span class="cov0" title="0">{
                ah.subjectDisplayReference = target.GetDisplayReference()
        }</span> else<span class="cov0" title="0"> {
                // use subject digest instead of tag
                newTarget := *target
                newTarget.RawReference = fmt.Sprintf("%s@%s", target.Path, subject.Digest)
                ah.subjectDisplayReference = newTarget.GetDisplayReference()
        }</span>
}

// Render is called when the attach command is complete.
func (ah *AttachHandler) Render() error <span class="cov0" title="0">{
        err := ah.printer.Println("Attached to", ah.subjectDisplayReference)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return ah.printer.Println("Digest:", ah.root.Digest)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package text

import (
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/cmd/oras/internal/output"
)

// BlobDeleteHandler handles text metadata output for blob delete events.
type BlobDeleteHandler struct {
        printer *output.Printer
        target  *option.Target
}

// NewBlobDeleteHandler returns a new handler for blob delete events.
func NewBlobDeleteHandler(printer *output.Printer, target *option.Target) metadata.BlobDeleteHandler <span class="cov0" title="0">{
        return &amp;BlobDeleteHandler{
                printer: printer,
                target:  target,
        }
}</span>

// OnBlobMissing implements BlobDeleteHandler.
func (h *BlobDeleteHandler) OnBlobMissing() error <span class="cov0" title="0">{
        return h.printer.Println("Missing", h.target.RawReference)
}</span>

// OnBlobDeleted implements BlobDeleteHandler.
func (h *BlobDeleteHandler) OnBlobDeleted() error <span class="cov0" title="0">{
        return h.printer.Println("Deleted", h.target.GetDisplayReference())
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package text

import (
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/cmd/oras/internal/output"
)

// BlobPushHandler handles text metadata output for blob push events.
type BlobPushHandler struct {
        printer *output.Printer
        desc    ocispec.Descriptor
}

// NewBlobPushHandler returns a new handler for Blob push events.
func NewBlobPushHandler(printer *output.Printer, desc ocispec.Descriptor) metadata.BlobPushHandler <span class="cov0" title="0">{
        return &amp;BlobPushHandler{
                printer: printer,
                desc:    desc,
        }
}</span>

// OnBlobPushed implements metadata.BlobPushHandler.
func (h *BlobPushHandler) OnBlobPushed(target *option.Target) error <span class="cov0" title="0">{
        return h.printer.Println("Pushed:", target.GetDisplayReference())
}</span>

// Render implements metadata.BlobPushHandler.
func (h *BlobPushHandler) Render() error <span class="cov0" title="0">{
        return h.printer.Println("Digest:", h.desc.Digest)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package text

import (
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/cmd/oras/internal/output"
)

// CopyHandler handles text metadata output for cp events.
type CopyHandler struct {
        printer *output.Printer
        desc    ocispec.Descriptor
}

// NewCopyHandler returns a new handler for cp events.
func NewCopyHandler(printer *output.Printer) metadata.CopyHandler <span class="cov10" title="2">{
        return &amp;CopyHandler{
                printer: printer,
        }
}</span>

// OnTagged implements metadata.TaggedHandler.
func (h *CopyHandler) OnTagged(_ ocispec.Descriptor, tag string) error <span class="cov0" title="0">{
        return h.printer.Println("Tagged", tag)
}</span>

// Render implements metadata.Renderer.
func (h *CopyHandler) Render() error <span class="cov0" title="0">{
        return h.printer.Println("Digest:", h.desc.Digest)
}</span>

// OnCopied implements metadata.CopyHandler.
func (h *CopyHandler) OnCopied(target *option.BinaryTarget, desc ocispec.Descriptor) error <span class="cov0" title="0">{
        h.desc = desc
        return h.printer.Println("Copied", target.From.GetDisplayReference(), "=&gt;", target.To.GetDisplayReference())
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package text

import (
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/cmd/oras/internal/output"
)

// ManifestDeleteHandler handles text metadata output for manifest delete events.
type ManifestDeleteHandler struct {
        printer *output.Printer
        target  *option.Target
}

// NewManifestDeleteHandler returns a new handler for manifest delete events.
func NewManifestDeleteHandler(printer *output.Printer, target *option.Target) metadata.ManifestDeleteHandler <span class="cov0" title="0">{
        return &amp;ManifestDeleteHandler{
                printer: printer,
                target:  target,
        }
}</span>

// OnManifestMissing implements ManifestDeleteHandler.
func (h *ManifestDeleteHandler) OnManifestMissing() error <span class="cov0" title="0">{
        return h.printer.Println("Missing", h.target.RawReference)
}</span>

// OnManifestDeleted implements ManifestDeleteHandler.
func (h *ManifestDeleteHandler) OnManifestDeleted() error <span class="cov0" title="0">{
        return h.printer.Println("Deleted", h.target.GetDisplayReference())
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package text

import (
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/output"
)

// ManifestIndexCreateHandler handles text metadata output for index create events.
type ManifestIndexCreateHandler struct {
        printer *output.Printer
        root    ocispec.Descriptor
}

// NewManifestIndexCreateHandler returns a new handler for index create events.
func NewManifestIndexCreateHandler(printer *output.Printer) metadata.ManifestIndexCreateHandler <span class="cov0" title="0">{
        return &amp;ManifestIndexCreateHandler{
                printer: printer,
        }
}</span>

// OnTagged implements TaggedHandler.
func (h *ManifestIndexCreateHandler) OnTagged(_ ocispec.Descriptor, tag string) error <span class="cov0" title="0">{
        return h.printer.Println("Tagged", tag)
}</span>

// OnIndexCreated implements ManifestIndexCreateHandler.
func (h *ManifestIndexCreateHandler) OnIndexCreated(desc ocispec.Descriptor) <span class="cov0" title="0">{
        h.root = desc
}</span>

// Render implements ManifestIndexCreateHandler.
func (h *ManifestIndexCreateHandler) Render() error <span class="cov0" title="0">{
        return h.printer.Println("Digest:", h.root.Digest)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package text

import (
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/cmd/oras/internal/output"
)

// ManifestPushHandler handles text metadata output for manifest push events.
type ManifestPushHandler struct {
        printer *output.Printer
        target  *option.Target
        desc    ocispec.Descriptor
}

// NewManifestPushHandler returns a new handler for manifest push events.
func NewManifestPushHandler(printer *output.Printer, target *option.Target) metadata.ManifestPushHandler <span class="cov0" title="0">{
        return &amp;ManifestPushHandler{
                printer: printer,
                target:  target,
        }
}</span>

// OnTagged implements metadata.TaggedHandler.
func (h *ManifestPushHandler) OnTagged(_ ocispec.Descriptor, tag string) error <span class="cov0" title="0">{
        return h.printer.Println("Tagged", tag)
}</span>

// OnManifestPushed implements metadata.ManifestPushHandler.
func (h *ManifestPushHandler) OnManifestPushed(desc ocispec.Descriptor) error <span class="cov0" title="0">{
        h.desc = desc
        return h.printer.Println("Pushed:", h.target.GetDisplayReference())
}</span>

// Render implements metadata.ManifestPushHandler.
func (h *ManifestPushHandler) Render() error <span class="cov0" title="0">{
        return h.printer.Println("Digest:", h.desc.Digest)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package text

import (
        "sync/atomic"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/cmd/oras/internal/output"
)

// PullHandler handles text metadata output for pull events.
type PullHandler struct {
        printer      *output.Printer
        layerSkipped atomic.Bool
        target       *option.Target
        root         ocispec.Descriptor
}

// NewPullHandler returns a new handler for Pull events.
func NewPullHandler(printer *output.Printer) metadata.PullHandler <span class="cov8" title="1">{
        return &amp;PullHandler{
                printer: printer,
        }
}</span>

func (ph *PullHandler) OnFilePulled(_ string, _ string, _ ocispec.Descriptor, _ string) error <span class="cov0" title="0">{
        return nil
}</span>

// OnLayerSkipped implements metadata.PullHandler.
func (ph *PullHandler) OnLayerSkipped(ocispec.Descriptor) error <span class="cov0" title="0">{
        ph.layerSkipped.Store(true)
        return nil
}</span>

// OnPulled implements metadata.PullHandler.
func (ph *PullHandler) OnPulled(target *option.Target, desc ocispec.Descriptor) <span class="cov0" title="0">{
        ph.target = target
        ph.root = desc
}</span>

// Render implements metadata.PullHandler.
func (ph *PullHandler) Render() error <span class="cov0" title="0">{
        if ph.layerSkipped.Load() </span><span class="cov0" title="0">{
                _ = ph.printer.Printf("Skipped pulling layers without file name in %q\n", ocispec.AnnotationTitle)
                _ = ph.printer.Printf("Use 'oras copy %s --to-oci-layout &lt;layout-dir&gt;' to pull all layers.\n", ph.target.RawReference)
        }</span> else<span class="cov0" title="0"> {
                _ = ph.printer.Println("Pulled", ph.target.GetDisplayReference())
                _ = ph.printer.Println("Digest:", ph.root.Digest)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package text

import (
        "sync"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/cmd/oras/internal/output"
)

// PushHandler handles text metadata output for push events.
type PushHandler struct {
        printer *output.Printer
        tagLock sync.Mutex
        root    ocispec.Descriptor
}

// NewPushHandler returns a new handler for push events.
func NewPushHandler(printer *output.Printer) metadata.PushHandler <span class="cov1" title="1">{
        return &amp;PushHandler{
                printer: printer,
        }
}</span>

// OnTagged implements metadata.TaggedHandler.
func (h *PushHandler) OnTagged(_ ocispec.Descriptor, tag string) error <span class="cov0" title="0">{
        h.tagLock.Lock()
        defer h.tagLock.Unlock()
        return h.printer.Println("Tagged", tag)
}</span>

// OnCopied is called after files are copied.
func (h *PushHandler) OnCopied(opts *option.Target, root ocispec.Descriptor) error <span class="cov0" title="0">{
        h.root = root
        return h.printer.Println("Pushed", opts.GetDisplayReference())
}</span>

// Render implements PushHandler.
func (h *PushHandler) Render() error <span class="cov10" title="2">{
        err := h.printer.Println("ArtifactType:", h.root.ArtifactType)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">return h.printer.Println("Digest:", h.root.Digest)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package text

import (
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/output"
)

// ResolveHandler handles text metadata output for resolve events.
type ResolveHandler struct {
        printer *output.Printer
        fullRef bool
        path    string
}

// NewResolveHandler returns a new handler for resolve events.
func NewResolveHandler(printer *output.Printer, fullRef bool, path string) metadata.ResolveHandler <span class="cov0" title="0">{
        return &amp;ResolveHandler{
                printer: printer,
                fullRef: fullRef,
                path:    path,
        }
}</span>

// OnResolved implements metadata.ResolveHandler.
func (h *ResolveHandler) OnResolved(desc ocispec.Descriptor) error <span class="cov0" title="0">{
        if h.fullRef </span><span class="cov0" title="0">{
                return h.printer.Printf("%s@%s\n", h.path, desc.Digest)
        }</span>
        <span class="cov0" title="0">return h.printer.Println(desc.Digest.String())</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package text

import (
        "fmt"
        "sync"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/cmd/oras/internal/output"
)

// TagHandler handles text metadata output for tag events.
type TagHandler struct {
        printer   *output.Printer
        printOnce sync.Once
        refPrefix string
}

// NewTagHandler returns a new handler for tag events.
func NewTagHandler(printer *output.Printer, target option.Target) metadata.TagHandler <span class="cov0" title="0">{
        return &amp;TagHandler{
                printer:   printer,
                refPrefix: fmt.Sprintf("[%s] %s", target.Type, target.Path),
        }
}</span>

// OnTagging is called when the tagging is complete.
func (ah *TagHandler) OnTagging(desc ocispec.Descriptor, _ string) (err error) <span class="cov0" title="0">{
        ah.printOnce.Do(func() </span><span class="cov0" title="0">{
                ref := ah.refPrefix + "@" + desc.Digest.String()
                err = ah.printer.Println("Tagging", ref)
        }</span>)
        <span class="cov0" title="0">return err</span>
}

// OnTagged is called when the tagging is complete.
func (ah *TagHandler) OnTagged(_ ocispec.Descriptor, tag string) error <span class="cov0" title="0">{
        return ah.printer.Println("Tagged", tag)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tree

import (
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/morikuni/aec"
        "github.com/opencontainers/go-digest"
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "gopkg.in/yaml.v3"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/internal/tree"
)

var (
        artifactTypeColor = aec.LightYellowF
        digestColor       = aec.LightGreenF
        annotationsColor  = aec.LightCyanF
)

// discoverHandler handles json metadata output for discover events.
type discoverHandler struct {
        out     io.Writer
        path    string
        root    *tree.Node
        nodes   map[digest.Digest]*tree.Node
        verbose bool
        tty     *os.File
}

// NewDiscoverHandler creates a new handler for discover events.
func NewDiscoverHandler(out io.Writer, path string, root ocispec.Descriptor, verbose bool, tty *os.File) metadata.DiscoverHandler <span class="cov10" title="2">{
        rootDigest := fmt.Sprintf("%s@%s", path, root.Digest)
        if tty != nil </span><span class="cov1" title="1">{
                rootDigest = digestColor.Apply(rootDigest)
        }</span>
        <span class="cov10" title="2">treeRoot := tree.New(rootDigest)
        return &amp;discoverHandler{
                out:  out,
                path: path,
                root: treeRoot,
                nodes: map[digest.Digest]*tree.Node{
                        root.Digest: treeRoot,
                },
                verbose: verbose,
                tty:     tty,
        }</span>
}

// OnDiscovered implements metadata.DiscoverHandler.
func (h *discoverHandler) OnDiscovered(referrer, subject ocispec.Descriptor) error <span class="cov10" title="2">{
        node, ok := h.nodes[subject.Digest]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected subject descriptor: %v", subject)
        }</span>

        // add artifact type and digest to the referrer
        <span class="cov10" title="2">artifactType := referrer.ArtifactType
        if artifactType == "" </span><span class="cov0" title="0">{
                artifactType = "&lt;unknown&gt;"
        }</span>
        <span class="cov10" title="2">dgst := referrer.Digest.String()
        if h.tty != nil </span><span class="cov1" title="1">{
                artifactType = artifactTypeColor.Apply(artifactType)
                dgst = digestColor.Apply(dgst)
        }</span>
        <span class="cov10" title="2">referrerNode := node.AddPath(artifactType, dgst)

        // add annotations to the referrer
        if h.verbose &amp;&amp; len(referrer.Annotations) &gt; 0 </span><span class="cov10" title="2">{
                annotationsTitle := "[annotations]"
                if h.tty != nil </span><span class="cov1" title="1">{
                        annotationsTitle = annotationsColor.Apply(annotationsTitle)
                }</span>
                <span class="cov10" title="2">annotationsNode := referrerNode.Add(annotationsTitle)
                for k, v := range referrer.Annotations </span><span class="cov10" title="2">{
                        bytes, err := yaml.Marshal(map[string]string{k: v})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov10" title="2">annotationsNode.AddPath(strings.TrimSpace(string(bytes)))</span>
                }
        }
        <span class="cov10" title="2">h.nodes[referrer.Digest] = referrerNode
        return nil</span>
}

// Render implements metadata.DiscoverHandler.
func (h *discoverHandler) Render() error <span class="cov10" title="2">{
        return tree.NewPrinter(h.out).Print(h.root)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package console

import (
        "os"

        containerd "github.com/containerd/console"
        "github.com/morikuni/aec"
)

const (
        // MinWidth is the minimal width of supported console.
        MinWidth = 80
        // MinHeight is the minimal height of supported console.
        MinHeight = 10
        // Save cannot use aec.Save since DEC has better compatibility than SCO
        Save = "\0337"
        // Restore cannot use aec.Restore since DEC has better compatibility than SCO
        Restore = "\0338"
)

// Console is a wrapper around containerd's Console and ANSI escape codes.
type Console interface {
        containerd.Console
        GetHeightWidth() (height, width int)
        Save()
        NewRow()
        OutputTo(upCnt uint, str string)
        Restore()
}

type console struct {
        containerd.Console
}

// NewConsole generates a console from a file.
func NewConsole(f *os.File) (Console, error) <span class="cov9" title="20">{
        c, err := containerd.ConsoleFromFile(f)
        if err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>
        <span class="cov9" title="17">return &amp;console{c}, nil</span>
}

// GetHeightWidth returns the width and height of the console.
// If the console size cannot be determined, returns a default value of 80x10.
func (c *console) GetHeightWidth() (height, width int) <span class="cov9" title="18">{
        windowSize, err := c.Size()
        if err != nil </span><span class="cov0" title="0">{
                return MinHeight, MinWidth
        }</span>
        <span class="cov9" title="18">if windowSize.Height &lt; MinHeight </span><span class="cov9" title="16">{
                windowSize.Height = MinHeight
        }</span>
        <span class="cov9" title="18">if windowSize.Width &lt; MinWidth </span><span class="cov9" title="16">{
                windowSize.Width = MinWidth
        }</span>
        <span class="cov9" title="18">return int(windowSize.Height), int(windowSize.Width)</span>
}

// Save saves the current cursor position.
func (c *console) Save() <span class="cov8" title="14">{
        _, _ = c.Write([]byte(aec.Hide.Apply(Save)))
}</span>

// NewRow allocates a horizontal space to the output area with scroll if needed.
func (c *console) NewRow() <span class="cov10" title="21">{
        _, _ = c.Write([]byte(Restore))
        _, _ = c.Write([]byte("\n"))
        _, _ = c.Write([]byte(Save))
}</span>

// OutputTo outputs a string to a specific line.
func (c *console) OutputTo(upCnt uint, str string) <span class="cov10" title="21">{
        _, _ = c.Write([]byte(Restore))
        _, _ = c.Write([]byte(aec.PreviousLine(upCnt).Apply(str)))
        _, _ = c.Write([]byte("\n"))
        _, _ = c.Write([]byte(aec.EraseLine(aec.EraseModes.Tail).String()))
}</span>

// Restore restores the saved cursor position.
func (c *console) Restore() <span class="cov8" title="14">{
        // cannot use aec.Restore since DEC has better compatibility than SCO
        _, _ = c.Write([]byte(Restore))
        _, _ = c.Write([]byte(aec.Column(0).
                With(aec.EraseLine(aec.EraseModes.All)).
                With(aec.Show).String()))
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package status

import (
        "context"

        "github.com/opencontainers/go-digest"
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras-go/v2"
)

func discardStopTrack() error <span class="cov0" title="0">{
        return nil
}</span>

// DiscardHandler is a no-op handler that discards all status updates.
type DiscardHandler struct{}

// NewDiscardHandler returns a new no-op handler.
func NewDiscardHandler() DiscardHandler <span class="cov10" title="6">{
        return DiscardHandler{}
}</span>

// OnFileLoading is called before a file is being loaded.
func (DiscardHandler) OnFileLoading(name string) error <span class="cov0" title="0">{
        return nil
}</span>

// OnEmptyArtifact is called when no file is loaded for an artifact push.
func (DiscardHandler) OnEmptyArtifact() error <span class="cov0" title="0">{
        return nil
}</span>

// TrackTarget returns a target with status tracking.
func (DiscardHandler) TrackTarget(gt oras.GraphTarget) (oras.GraphTarget, StopTrackTargetFunc, error) <span class="cov0" title="0">{
        return gt, discardStopTrack, nil
}</span>

// OnCopySkipped is called when an object already exists.
func (DiscardHandler) OnCopySkipped(_ context.Context, _ ocispec.Descriptor) error <span class="cov0" title="0">{
        return nil
}</span>

// PreCopy implements PreCopy of CopyHandler.
func (DiscardHandler) PreCopy(_ context.Context, _ ocispec.Descriptor) error <span class="cov0" title="0">{
        return nil
}</span>

// PostCopy implements PostCopy of CopyHandler.
func (DiscardHandler) PostCopy(_ context.Context, _ ocispec.Descriptor) error <span class="cov0" title="0">{
        return nil
}</span>

// OnNodeDownloading implements PullHandler.
func (DiscardHandler) OnNodeDownloading(desc ocispec.Descriptor) error <span class="cov0" title="0">{
        return nil
}</span>

// OnNodeDownloaded implements PullHandler.
func (DiscardHandler) OnNodeDownloaded(desc ocispec.Descriptor) error <span class="cov0" title="0">{
        return nil
}</span>

// OnNodeRestored implements PullHandler.
func (DiscardHandler) OnNodeRestored(_ ocispec.Descriptor) error <span class="cov0" title="0">{
        return nil
}</span>

// OnNodeProcessing implements PullHandler.
func (DiscardHandler) OnNodeProcessing(desc ocispec.Descriptor) error <span class="cov0" title="0">{
        return nil
}</span>

// OnNodeProcessing implements PullHandler.
func (DiscardHandler) OnNodeSkipped(desc ocispec.Descriptor) error <span class="cov0" title="0">{
        return nil
}</span>

// OnFetching implements referenceFetchHandler.
func (DiscardHandler) OnFetching(string) error <span class="cov0" title="0">{
        return nil
}</span>

// OnFetched implements referenceFetchHandler.
func (DiscardHandler) OnFetched(string, ocispec.Descriptor) error <span class="cov0" title="0">{
        return nil
}</span>

// OnManifestPushSkipped implements ManifestPushHandler.
func (DiscardHandler) OnManifestPushSkipped() error <span class="cov1" title="1">{
        return nil
}</span>

// OnManifestPushing implements ManifestPushHandler.
func (DiscardHandler) OnManifestPushing() error <span class="cov0" title="0">{
        return nil
}</span>

// OnManifestPushed implements ManifestPushHandler.
func (DiscardHandler) OnManifestPushed() error <span class="cov0" title="0">{
        return nil
}</span>

// OnManifestRemoved implements ManifestIndexUpdateHandler.
func (DiscardHandler) OnManifestRemoved(digest.Digest) error <span class="cov1" title="1">{
        return nil
}</span>

// OnManifestAdded implements ManifestIndexUpdateHandler.
func (DiscardHandler) OnManifestAdded(string, ocispec.Descriptor) error <span class="cov0" title="0">{
        return nil
}</span>

// OnIndexMerged implements ManifestIndexUpdateHandler.
func (DiscardHandler) OnIndexMerged(string, ocispec.Descriptor) error <span class="cov1" title="1">{
        return nil
}</span>

// OnIndexPacked implements ManifestIndexCreateHandler.
func (DiscardHandler) OnIndexPacked(ocispec.Descriptor) error <span class="cov0" title="0">{
        return nil
}</span>

// OnIndexPushed implements ManifestIndexCreateHandler.
func (DiscardHandler) OnIndexPushed(string) error <span class="cov1" title="1">{
        return nil
}</span>

// OnBlobExists implements BlobPushHandler.
func (DiscardHandler) OnBlobExists() error <span class="cov0" title="0">{
        return nil
}</span>

// OnBlobUploading implements BlobPushHandler.
func (DiscardHandler) OnBlobUploading() error <span class="cov0" title="0">{
        return nil
}</span>

// OnBlobUploaded implements BlobPushHandler.
func (DiscardHandler) OnBlobUploaded() error <span class="cov0" title="0">{
        return nil
}</span>

// StartTracking implements BlobPushHandler.
func (DiscardHandler) StartTracking(gt oras.GraphTarget) (oras.GraphTarget, error) <span class="cov0" title="0">{
        return gt, nil
}</span>

// StopTracking implements BlobPushHandler.
func (DiscardHandler) StopTracking() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package humanize

import (
        "fmt"
        "math"
)

const base = 1024.0

var units = []string{"B", "KB", "MB", "GB", "TB"}

type Bytes struct {
        Size float64
        Unit string
}

// ToBytes converts size in bytes to human readable format.
func ToBytes(sizeInBytes int64) Bytes <span class="cov10" title="46">{
        f := float64(sizeInBytes)
        if f &lt; base </span><span class="cov8" title="20">{
                return Bytes{f, units[0]}
        }</span>
        <span class="cov8" title="26">e := int(math.Floor(math.Log(f) / math.Log(base)))
        if e &gt;= len(units) </span><span class="cov0" title="0">{
                // only support up to TB
                e = len(units) - 1
        }</span>
        <span class="cov8" title="26">p := f / math.Pow(base, float64(e))
        return Bytes{RoundTo(p), units[e]}</span>
}

// String returns the string representation of Bytes.
func (b Bytes) String() string <span class="cov8" title="27">{
        return fmt.Sprintf("%g %2s", b.Size, b.Unit)
}</span>

// RoundTo makes length of the size string to less than or equal to 4.
func RoundTo(size float64) float64 <span class="cov9" title="34">{
        if size &lt; 10 </span><span class="cov8" title="29">{
                return math.Round(size*100) / 100
        }</span> else<span class="cov4" title="5"> if size &lt; 100 </span><span class="cov2" title="2">{
                return math.Round(size*10) / 10
        }</span>
        <span class="cov3" title="3">return math.Round(size)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package progress

import (
        "errors"
        "os"
        "sync"
        "time"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/status/console"
        "oras.land/oras/internal/progress"
)

const (
        // bufferSize is the size of the status channel buffer.
        bufferSize       = 1
        framePerSecond   = 5
        bufFlushDuration = time.Second / framePerSecond
)

var errManagerStopped = errors.New("progress output manager has already been stopped")

type manager struct {
        status       []*status
        statusLock   sync.RWMutex
        console      console.Console
        updating     sync.WaitGroup
        renderDone   chan struct{}
        renderClosed chan struct{}
        prompts      map[progress.State]string
}

// NewManager initialized a new progress manager.
func NewManager(tty *os.File, prompts map[progress.State]string) (progress.Manager, error) <span class="cov8" title="15">{
        c, err := console.NewConsole(tty)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>
        <span class="cov7" title="13">return newManager(c, prompts), nil</span>
}

func newManager(c console.Console, prompts map[progress.State]string) progress.Manager <span class="cov7" title="14">{
        m := &amp;manager{
                console:      c,
                renderDone:   make(chan struct{}),
                renderClosed: make(chan struct{}),
                prompts:      prompts,
        }
        m.start()
        return m
}</span>

func (m *manager) start() <span class="cov7" title="14">{
        m.console.Save()
        renderTicker := time.NewTicker(bufFlushDuration)
        go func() </span><span class="cov7" title="14">{
                defer m.console.Restore()
                defer renderTicker.Stop()
                for </span><span class="cov8" title="15">{
                        select </span>{
                        case &lt;-m.renderDone:<span class="cov7" title="14">
                                m.render()
                                close(m.renderClosed)
                                return</span>
                        case &lt;-renderTicker.C:<span class="cov1" title="1">
                                m.render()</span>
                        }
                }
        }()
}

func (m *manager) render() <span class="cov8" title="15">{
        m.statusLock.RLock()
        defer m.statusLock.RUnlock()

        // render with culling: only the latter statuses are rendered.
        models := m.status
        height, width := m.console.GetHeightWidth()
        if n := len(m.status) - height/2; n &gt; 0 </span><span class="cov0" title="0">{
                models = models[n:]
                if height%2 == 1 </span><span class="cov0" title="0">{
                        view := m.status[n-1].Render(width)
                        m.console.OutputTo(uint(len(models)*2+1), view[1])
                }</span>
        }
        <span class="cov8" title="15">viewHeight := len(models) * 2
        for i, model := range models </span><span class="cov7" title="11">{
                view := model.Render(width)
                m.console.OutputTo(uint(viewHeight-i*2), view[0])
                m.console.OutputTo(uint(viewHeight-i*2-1), view[1])
        }</span>
}

// Track appends a new status with 2-line space for rendering.
func (m *manager) Track(desc ocispec.Descriptor) (progress.Tracker, error) <span class="cov7" title="11">{
        if m.closed() </span><span class="cov0" title="0">{
                return nil, errManagerStopped
        }</span>

        <span class="cov7" title="11">s := newStatus(desc)
        m.statusLock.Lock()
        m.status = append(m.status, s)
        m.statusLock.Unlock()

        defer m.console.NewRow()
        defer m.console.NewRow()
        return m.newTracker(s), nil</span>
}

func (m *manager) newTracker(s *status) progress.Tracker <span class="cov7" title="11">{
        ch := make(chan statusUpdate, bufferSize)
        m.updating.Add(1)
        go func() </span><span class="cov7" title="11">{
                defer m.updating.Done()
                for update := range ch </span><span class="cov10" title="32">{
                        update(s)
                }</span>
        }()
        <span class="cov7" title="11">return &amp;messenger{
                update:  ch,
                prompts: m.prompts,
        }</span>
}

// Close stops all status and waits for updating and rendering.
func (m *manager) Close() error <span class="cov7" title="14">{
        if m.closed() </span><span class="cov0" title="0">{
                return errManagerStopped
        }</span>
        // 1. wait for update to stop
        <span class="cov7" title="14">m.updating.Wait()
        // 2. stop periodic rendering
        close(m.renderDone)
        // 3. wait for the render stop
        &lt;-m.renderClosed
        return nil</span>
}

func (m *manager) closed() bool <span class="cov9" title="25">{
        select </span>{
        case &lt;-m.renderClosed:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov9" title="25">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file42" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package progress

import "oras.land/oras/internal/progress"

// messenger is progress message channel.
type messenger struct {
        update  chan statusUpdate
        closed  bool
        prompts map[progress.State]string
}

// Update sends the status to the message channel.
func (m *messenger) Update(status progress.Status) error <span class="cov10" title="26">{
        switch status.State </span>{
        case progress.StateInitialized:<span class="cov6" title="7">
                m.update &lt;- updateStatusStartTime()</span>
        case progress.StateTransmitting:<span class="cov6" title="7">
                select </span>{
                case m.update &lt;- updateStatusMessage(m.prompts[progress.StateTransmitting], status.Offset):<span class="cov5" title="5"></span>
                default:<span class="cov2" title="2"></span>
                        // drop message if channel is full
                }
        default:<span class="cov7" title="12">
                m.update &lt;- updateStatusMessage(m.prompts[status.State], status.Offset)</span>
        }
        <span class="cov10" title="26">return nil</span>
}

// Fail sends the error to the message channel.
func (m *messenger) Fail(err error) error <span class="cov1" title="1">{
        m.update &lt;- updateStatusError(err)
        return nil
}</span>

// Close marks the progress as completed and closes the message channel.
func (m *messenger) Close() error <span class="cov8" title="15">{
        if m.closed </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov8" title="14">m.update &lt;- updateStatusEndTime()
        close(m.update)
        m.closed = true
        return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package progress

import "time"

type speedPoint struct {
        time   time.Time
        offset int64
}

type speedWindow struct {
        point []speedPoint
        next  int
        size  int
}

// newSpeedWindow creates a new speed window with a given capacity.
func newSpeedWindow(capacity int) *speedWindow <span class="cov10" title="29">{
        return &amp;speedWindow{
                point: make([]speedPoint, capacity),
        }
}</span>

// Add adds a done workload to the window.
func (w *speedWindow) Add(time time.Time, offset int64) <span class="cov8" title="17">{
        if w.size != len(w.point) </span><span class="cov8" title="16">{
                w.size++
        }</span>
        <span class="cov8" title="17">w.point[w.next] = speedPoint{
                time:   time,
                offset: offset,
        }
        w.next = (w.next + 1) % len(w.point)</span>
}

// Mean returns the mean speed of the window with unit of byte per second.
func (w *speedWindow) Mean() float64 <span class="cov7" title="10">{
        if w.size &lt; 2 </span><span class="cov6" title="7">{
                // no speed displayed for first read
                return 0
        }</span>

        <span class="cov3" title="3">begin := (w.next - w.size + len(w.point)) % len(w.point)
        end := (begin - 1 + w.size) % w.size

        return float64(w.point[end].offset-w.point[begin].offset) / w.point[end].time.Sub(w.point[begin].time).Seconds()</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package progress

var spinnerSymbols = []rune("")

type spinner int

// symbol returns the rune of status mark and shift to the next.
func (s *spinner) symbol() rune <span class="cov10" title="16">{
        last := int(*s)
        *s = spinner((last + 1) % len(spinnerSymbols))
        return spinnerSymbols[last]
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package progress

import (
        "fmt"
        "strings"
        "sync"
        "time"
        "unicode/utf8"

        "github.com/morikuni/aec"
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/cmd/oras/internal/display/status/progress/humanize"
)

const (
        barLength    = 20
        speedLength  = 7    // speed_size(4) + space(1) + speed_unit(2)
        zeroDuration = "0s" // default zero value of time.Duration.String()
)

var (
        spinnerColor  = aec.LightYellowF
        doneMarkColor = aec.LightGreenF
        progressColor = aec.LightBlueB
        failureColor  = aec.LightRedF
)

// status is the model to present the progress of an operation.
type status struct {
        lock sync.RWMutex
        done bool  // true if the operation is succeeded
        err  error // non-nil if the operation fails

        mark      spinner
        text      string
        startTime time.Time
        endTime   time.Time

        descriptor ocispec.Descriptor
        offset     int64
        total      humanize.Bytes
        speed      *speedWindow
}

// newStatus generates a base empty status.
func newStatus(desc ocispec.Descriptor) *status <span class="cov9" title="19">{
        return &amp;status{
                descriptor: desc,
                offset:     -1,
                total:      humanize.ToBytes(desc.Size),
                speed:      newSpeedWindow(framePerSecond),
        }
}</span>

// Render returns human-readable TTY strings of the status.
// Format:
//
//        [left--------------------------------------------][margin][right---------------------------------]
//        mark(1) bar(22) speed(8) action(&lt;=11) name(&lt;=126)        size_per_size(&lt;=13) percent(8) time(&gt;=6)
//          digest(72)
func (s *status) Render(width int) [2]string <span class="cov9" title="21">{
        s.lock.RLock()
        defer s.lock.RUnlock()

        // obtain object name
        name := s.descriptor.Annotations[ocispec.AnnotationTitle]
        if name == "" </span><span class="cov7" title="12">{
                name = s.descriptor.MediaType
        }</span>

        // calculate the progress percentage
        <span class="cov9" title="21">var offset string
        var percent float64
        if s.done </span><span class="cov8" title="15">{
                // 100%, show exact size
                offset = fmt.Sprint(s.total.Size)
                percent = 1
        }</span> else<span class="cov5" title="6"> if s.offset &lt; 0 </span><span class="cov1" title="1">{
                // not started, show 0%
                offset = "-"
        }</span> else<span class="cov5" title="5"> if s.descriptor.Size == 0 </span><span class="cov1" title="1">{
                // 0 byte, show 100%
                offset = "0"
                percent = 1
        }</span> else<span class="cov4" title="4"> {
                // 0% ~ 99%, show 2-digit precision
                percent = float64(s.offset) / float64(s.descriptor.Size)
                offset = fmt.Sprintf("%.2f", humanize.RoundTo(s.total.Size*percent))
        }</span>

        // render the left side of the primary line
        <span class="cov9" title="21">var left string
        lenLeft := 0 // manually calculate the string length due to the color escape sequence
        if s.done </span><span class="cov8" title="15">{
                left = fmt.Sprintf("%s %s %s", doneMarkColor.Apply(""), s.text, name)
        }</span> else<span class="cov5" title="6"> {
                var mark string
                if s.err == nil </span><span class="cov5" title="5">{
                        mark = spinnerColor.Apply(string(s.mark.symbol()))
                }</span> else<span class="cov1" title="1"> {
                        mark = failureColor.Apply("")
                }</span>
                <span class="cov5" title="6">lenBar := int(percent * barLength)
                speed := s.calculateSpeed()
                left = fmt.Sprintf("%s [%s%s](%*s/s) %s %s", mark,
                        progressColor.Apply(strings.Repeat(" ", lenBar)), strings.Repeat(".", barLength-lenBar),
                        speedLength, speed, s.text, name)
                // bar + wrapper(2) + space(1) + speed + "/s"(2) + wrapper(2) = len(bar) + len(speed) + 7
                lenLeft = barLength + speedLength + 7</span>
        }
        // mark(1) + space(1) + prompt + space(1) + name = len(prompt) + len(name) + 3
        <span class="cov9" title="21">lenLeft += utf8.RuneCountInString(s.text) + utf8.RuneCountInString(name) + 3

        // render the right side of the primary line
        right := fmt.Sprintf(" %s/%s %6.2f%% %6s", offset, s.total, percent*100, s.durationString())
        lenRight := utf8.RuneCountInString(right)

        // render view
        lenMargin := width - lenLeft - lenRight
        if lenMargin &lt; 0 </span><span class="cov4" title="4">{
                // hide partial name with one space left
                left = left[:len(left)+lenMargin-1] + "."
                lenMargin = 0
        }</span>
        <span class="cov9" title="21">var padding string
        if paddingLen := width - len(s.descriptor.Digest) - 5; paddingLen &gt; 0 </span><span class="cov9" title="21">{
                padding = strings.Repeat(" ", paddingLen)
        }</span>
        <span class="cov9" title="21">return [2]string{
                fmt.Sprintf("%s%s%s", left, strings.Repeat(" ", lenMargin), right),
                fmt.Sprintf("   %s%s", s.descriptor.Digest, padding),
        }</span>
}

// calculateSpeed calculates the speed of the progress and update last status.
// caller must hold the lock.
func (s *status) calculateSpeed() humanize.Bytes <span class="cov5" title="6">{
        if s.offset &lt; 0 </span><span class="cov1" title="1">{
                // not started
                return humanize.ToBytes(0)
        }</span>
        <span class="cov5" title="5">s.speed.Add(time.Now(), s.offset)
        return humanize.ToBytes(int64(s.speed.Mean()))</span>
}

// durationString returns a viewable TTY string of the status with duration.
func (s *status) durationString() string <span class="cov10" title="26">{
        if s.startTime.IsZero() </span><span class="cov5" title="6">{
                return zeroDuration
        }</span>

        <span class="cov9" title="20">var d time.Duration
        if s.endTime.IsZero() </span><span class="cov5" title="5">{
                d = time.Since(s.startTime)
        }</span> else<span class="cov8" title="15"> {
                d = s.endTime.Sub(s.startTime)
        }</span>

        <span class="cov9" title="20">switch </span>{
        case d &gt; time.Second:<span class="cov7" title="12">
                d = d.Round(time.Second)</span>
        case d &gt; time.Millisecond:<span class="cov1" title="1">
                d = d.Round(time.Millisecond)</span>
        default:<span class="cov6" title="7">
                d = d.Round(time.Microsecond)</span>
        }
        <span class="cov9" title="20">return d.String()</span>
}

// statusUpdate is a function to update the status.
type statusUpdate func(*status)

// updateStatusMessage returns a statusUpdate to update the status message.
// Optionally, it can update the offset of the status.
func updateStatusMessage(text string, offset int64) statusUpdate <span class="cov9" title="22">{
        return func(s *status) </span><span class="cov9" title="20">{
                s.lock.Lock()
                defer s.lock.Unlock()

                s.text = text
                if offset &gt;= 0 </span><span class="cov7" title="12">{
                        s.offset = offset
                }</span>
        }
}

// updateStatusStartTime returns a statusUpdate to update the status start time.
func updateStatusStartTime() statusUpdate <span class="cov6" title="8">{
        return func(s *status) </span><span class="cov6" title="8">{
                s.lock.Lock()
                defer s.lock.Unlock()

                s.startTime = time.Now()
                s.speed.Add(s.startTime, 0)
        }</span>
}

// updateStatusEndTime returns a statusUpdate to update the status end time.
func updateStatusEndTime() statusUpdate <span class="cov8" title="16">{
        return func(s *status) </span><span class="cov8" title="13">{
                s.lock.Lock()
                defer s.lock.Unlock()

                s.endTime = time.Now()
                if s.err == nil </span><span class="cov7" title="12">{
                        s.done = true
                }</span>
        }
}

// updateStatusError returns a statusUpdate to update the status error.
func updateStatusError(err error) statusUpdate <span class="cov4" title="3">{
        return func(s *status) </span><span class="cov4" title="3">{
                s.lock.Lock()
                defer s.lock.Unlock()

                s.err = err
        }</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package status

import (
        "context"
        "sync"

        "oras.land/oras/internal/contentutil"
        "oras.land/oras/internal/descriptor"
        "oras.land/oras/internal/graph"

        "github.com/opencontainers/go-digest"
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/content"
        "oras.land/oras/cmd/oras/internal/output"
)

// TextPushHandler handles text status output for push events.
type TextPushHandler struct {
        printer   *output.Printer
        committed *sync.Map
        fetcher   content.Fetcher
}

// NewTextPushHandler returns a new handler for push command.
func NewTextPushHandler(printer *output.Printer, fetcher content.Fetcher) PushHandler <span class="cov10" title="5">{
        tch := TextPushHandler{
                printer:   printer,
                fetcher:   fetcher,
                committed: &amp;sync.Map{},
        }
        return &amp;tch
}</span>

// OnFileLoading is called when a file is being prepared for upload.
func (ph *TextPushHandler) OnFileLoading(name string) error <span class="cov1" title="1">{
        return ph.printer.PrintVerbose("Preparing", name)
}</span>

// OnEmptyArtifact is called when an empty artifact is being uploaded.
func (ph *TextPushHandler) OnEmptyArtifact() error <span class="cov1" title="1">{
        return ph.printer.Println("Uploading empty artifact")
}</span>

// TrackTarget returns a tracked target.
func (ph *TextPushHandler) TrackTarget(gt oras.GraphTarget) (oras.GraphTarget, StopTrackTargetFunc, error) <span class="cov0" title="0">{
        return gt, discardStopTrack, nil
}</span>

// OnCopySkipped is called when an object already exists.
func (ph *TextPushHandler) OnCopySkipped(_ context.Context, desc ocispec.Descriptor) error <span class="cov1" title="1">{
        ph.committed.Store(desc.Digest.String(), desc.Annotations[ocispec.AnnotationTitle])
        return ph.printer.PrintStatus(desc, PushPromptExists)
}</span>

// PreCopy implements PreCopy of CopyHandler.
func (ph *TextPushHandler) PreCopy(_ context.Context, desc ocispec.Descriptor) error <span class="cov1" title="1">{
        return ph.printer.PrintStatus(desc, PushPromptUploading)
}</span>

// PostCopy implements PostCopy of CopyHandler.
func (ph *TextPushHandler) PostCopy(ctx context.Context, desc ocispec.Descriptor) error <span class="cov1" title="1">{
        ph.committed.Store(desc.Digest.String(), desc.Annotations[ocispec.AnnotationTitle])
        successors, err := graph.FilteredSuccessors(ctx, desc, ph.fetcher, DeduplicatedFilter(ph.committed))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">for _, successor := range successors </span><span class="cov0" title="0">{
                if err = ph.printer.PrintStatus(successor, PushPromptExists); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">return ph.printer.PrintStatus(desc, PushPromptUploaded)</span>
}

// NewTextAttachHandler returns a new handler for attach command.
func NewTextAttachHandler(printer *output.Printer, fetcher content.Fetcher) AttachHandler <span class="cov0" title="0">{
        return NewTextPushHandler(printer, fetcher)
}</span>

// TextPullHandler handles text status output for pull events.
type TextPullHandler struct {
        printer *output.Printer
}

// TrackTarget implements PullHandler.
func (ph *TextPullHandler) TrackTarget(gt oras.GraphTarget) (oras.GraphTarget, StopTrackTargetFunc, error) <span class="cov0" title="0">{
        return gt, discardStopTrack, nil
}</span>

// OnNodeDownloading implements PullHandler.
func (ph *TextPullHandler) OnNodeDownloading(desc ocispec.Descriptor) error <span class="cov1" title="1">{
        return ph.printer.PrintStatus(desc, PullPromptDownloading)
}</span>

// OnNodeDownloaded implements PullHandler.
func (ph *TextPullHandler) OnNodeDownloaded(desc ocispec.Descriptor) error <span class="cov1" title="1">{
        return ph.printer.PrintStatus(desc, PullPromptDownloaded)
}</span>

// OnNodeRestored implements PullHandler.
func (ph *TextPullHandler) OnNodeRestored(desc ocispec.Descriptor) error <span class="cov1" title="1">{
        return ph.printer.PrintStatus(desc, PullPromptRestored)
}</span>

// OnNodeProcessing implements PullHandler.
func (ph *TextPullHandler) OnNodeProcessing(desc ocispec.Descriptor) error <span class="cov1" title="1">{
        return ph.printer.PrintStatus(desc, PullPromptProcessing)
}</span>

// OnNodeSkipped implements PullHandler.
func (ph *TextPullHandler) OnNodeSkipped(desc ocispec.Descriptor) error <span class="cov1" title="1">{
        return ph.printer.PrintStatus(desc, PullPromptSkipped)
}</span>

// NewTextPullHandler returns a new handler for pull command.
func NewTextPullHandler(printer *output.Printer) PullHandler <span class="cov10" title="5">{
        return &amp;TextPullHandler{
                printer: printer,
        }
}</span>

// TextCopyHandler handles text status output for push events.
type TextCopyHandler struct {
        printer   *output.Printer
        committed *sync.Map
        fetcher   content.Fetcher
}

// NewTextCopyHandler returns a new handler for push command.
func NewTextCopyHandler(printer *output.Printer, fetcher content.Fetcher) CopyHandler <span class="cov10" title="5">{
        return &amp;TextCopyHandler{
                printer:   printer,
                fetcher:   fetcher,
                committed: &amp;sync.Map{},
        }
}</span>

// StartTracking starts a tracked target from a graph target.
func (ch *TextCopyHandler) StartTracking(gt oras.GraphTarget) (oras.GraphTarget, error) <span class="cov0" title="0">{
        return gt, nil
}</span>

// StopTracking ends the copy tracking for the target.
func (ch *TextCopyHandler) StopTracking() error <span class="cov0" title="0">{
        return nil
}</span>

// OnCopySkipped is called when an object already exists.
func (ch *TextCopyHandler) OnCopySkipped(_ context.Context, desc ocispec.Descriptor) error <span class="cov1" title="1">{
        ch.committed.Store(desc.Digest.String(), desc.Annotations[ocispec.AnnotationTitle])
        return ch.printer.PrintStatus(desc, copyPromptExists)
}</span>

// PreCopy implements PreCopy of CopyHandler.
func (ch *TextCopyHandler) PreCopy(_ context.Context, desc ocispec.Descriptor) error <span class="cov1" title="1">{
        return ch.printer.PrintStatus(desc, copyPromptCopying)
}</span>

// PostCopy implements PostCopy of CopyHandler.
func (ch *TextCopyHandler) PostCopy(ctx context.Context, desc ocispec.Descriptor) error <span class="cov7" title="3">{
        ch.committed.Store(desc.Digest.String(), desc.Annotations[ocispec.AnnotationTitle])
        deduplicated, err := graph.FilteredSuccessors(ctx, desc, ch.fetcher, DeduplicatedFilter(ch.committed))
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov4" title="2">for _, successor := range deduplicated </span><span class="cov1" title="1">{
                if err = ch.printer.PrintStatus(successor, copyPromptSkipped); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov4" title="2">return ch.printer.PrintStatus(desc, copyPromptCopied)</span>
}

// OnMounted implements OnMounted of CopyHandler.
func (ch *TextCopyHandler) OnMounted(_ context.Context, desc ocispec.Descriptor) error <span class="cov1" title="1">{
        ch.committed.Store(desc.Digest.String(), desc.Annotations[ocispec.AnnotationTitle])
        return ch.printer.PrintStatus(desc, copyPromptMounted)
}</span>

// TextManifestPushHandler handles text status output for manifest push events.
type TextManifestPushHandler struct {
        desc    ocispec.Descriptor
        printer *output.Printer
}

// NewTextManifestPushHandler returns a new handler for manifest push command.
func NewTextManifestPushHandler(printer *output.Printer, desc ocispec.Descriptor) ManifestPushHandler <span class="cov1" title="1">{
        return &amp;TextManifestPushHandler{
                desc:    desc,
                printer: printer,
        }
}</span>

func (mph *TextManifestPushHandler) OnManifestPushSkipped() error <span class="cov1" title="1">{
        return mph.printer.PrintStatus(mph.desc, PushPromptExists)
}</span>

func (mph *TextManifestPushHandler) OnManifestPushing() error <span class="cov0" title="0">{
        return mph.printer.PrintStatus(mph.desc, PushPromptUploading)
}</span>

func (mph *TextManifestPushHandler) OnManifestPushed() error <span class="cov0" title="0">{
        return mph.printer.PrintStatus(mph.desc, PushPromptUploaded)
}</span>

// TextManifestIndexCreateHandler handles text status output for manifest index create events.
type TextManifestIndexCreateHandler struct {
        printer *output.Printer
}

// NewTextManifestIndexCreateHandler returns a new handler for manifest index create command.
func NewTextManifestIndexCreateHandler(printer *output.Printer) ManifestIndexCreateHandler <span class="cov0" title="0">{
        tmich := TextManifestIndexCreateHandler{
                printer: printer,
        }
        return &amp;tmich
}</span>

// OnFetching implements ManifestIndexCreateHandler.
func (mich *TextManifestIndexCreateHandler) OnFetching(source string) error <span class="cov0" title="0">{
        return mich.printer.Println(IndexPromptFetching, source)
}</span>

// OnFetched implements ManifestIndexCreateHandler.
func (mich *TextManifestIndexCreateHandler) OnFetched(ref string, desc ocispec.Descriptor) error <span class="cov0" title="0">{
        if contentutil.IsDigest(ref) </span><span class="cov0" title="0">{
                return mich.printer.Println(IndexPromptFetched, ref)
        }</span>
        <span class="cov0" title="0">return mich.printer.Println(IndexPromptFetched, desc.Digest, ref)</span>
}

// OnIndexPacked implements ManifestIndexCreateHandler.
func (mich *TextManifestIndexCreateHandler) OnIndexPacked(desc ocispec.Descriptor) error <span class="cov0" title="0">{
        return mich.printer.Println(IndexPromptPacked, descriptor.ShortDigest(desc), ocispec.MediaTypeImageIndex)
}</span>

// OnIndexPushed implements ManifestIndexCreateHandler.
func (mich *TextManifestIndexCreateHandler) OnIndexPushed(path string) error <span class="cov0" title="0">{
        return mich.printer.Println(IndexPromptPushed, path)
}</span>

// TextManifestIndexUpdateHandler handles text status output for manifest index update events.
type TextManifestIndexUpdateHandler struct {
        printer *output.Printer
}

// NewTextManifestIndexUpdateHandler returns a new handler for manifest index create command.
func NewTextManifestIndexUpdateHandler(printer *output.Printer) ManifestIndexUpdateHandler <span class="cov0" title="0">{
        miuh := TextManifestIndexUpdateHandler{
                printer: printer,
        }
        return &amp;miuh
}</span>

// OnFetching implements ManifestIndexUpdateHandler.
func (miuh *TextManifestIndexUpdateHandler) OnFetching(ref string) error <span class="cov0" title="0">{
        return miuh.printer.Println(IndexPromptFetching, ref)
}</span>

// OnFetched implements ManifestIndexUpdateHandler.
func (miuh *TextManifestIndexUpdateHandler) OnFetched(ref string, desc ocispec.Descriptor) error <span class="cov0" title="0">{
        if contentutil.IsDigest(ref) </span><span class="cov0" title="0">{
                return miuh.printer.Println(IndexPromptFetched, ref)
        }</span>
        <span class="cov0" title="0">return miuh.printer.Println(IndexPromptFetched, desc.Digest, ref)</span>
}

// OnManifestRemoved implements ManifestIndexUpdateHandler.
func (miuh *TextManifestIndexUpdateHandler) OnManifestRemoved(digest digest.Digest) error <span class="cov0" title="0">{
        return miuh.printer.Println(IndexPromptRemoved, digest)
}</span>

// OnManifestAdded implements ManifestIndexUpdateHandler.
func (miuh *TextManifestIndexUpdateHandler) OnManifestAdded(ref string, desc ocispec.Descriptor) error <span class="cov4" title="2">{
        if contentutil.IsDigest(ref) </span><span class="cov1" title="1">{
                return miuh.printer.Println(IndexPromptAdded, ref)
        }</span>
        <span class="cov1" title="1">return miuh.printer.Println(IndexPromptAdded, desc.Digest, ref)</span>
}

// OnIndexMerged implements ManifestIndexUpdateHandler.
func (miuh *TextManifestIndexUpdateHandler) OnIndexMerged(ref string, desc ocispec.Descriptor) error <span class="cov4" title="2">{
        if contentutil.IsDigest(ref) </span><span class="cov1" title="1">{
                return miuh.printer.Println(IndexPromptMerged, ref)
        }</span>
        <span class="cov1" title="1">return miuh.printer.Println(IndexPromptMerged, desc.Digest, ref)</span>
}

// OnIndexPacked implements ManifestIndexUpdateHandler.
func (miuh *TextManifestIndexUpdateHandler) OnIndexPacked(desc ocispec.Descriptor) error <span class="cov0" title="0">{
        return miuh.printer.Println(IndexPromptUpdated, desc.Digest)
}</span>

// OnIndexPushed implements ManifestIndexUpdateHandler.
func (miuh *TextManifestIndexUpdateHandler) OnIndexPushed(indexRef string) error <span class="cov0" title="0">{
        return miuh.printer.Println(IndexPromptPushed, indexRef)
}</span>

// TextBlobPushHandler handles text status output for blob push events.
type TextBlobPushHandler struct {
        desc    ocispec.Descriptor
        printer *output.Printer
}

// NewTextBlobPushHandler returns a new handler for blob push command.
func NewTextBlobPushHandler(printer *output.Printer, desc ocispec.Descriptor) BlobPushHandler <span class="cov0" title="0">{
        return &amp;TextBlobPushHandler{
                desc:    desc,
                printer: printer,
        }
}</span>

// OnBlobExists implements BlobPushHandler.
func (bph *TextBlobPushHandler) OnBlobExists() error <span class="cov0" title="0">{
        return bph.printer.PrintStatus(bph.desc, PushPromptExists)
}</span>

// OnBlobUploading implements BlobPushHandler.
func (bph *TextBlobPushHandler) OnBlobUploading() error <span class="cov0" title="0">{
        return bph.printer.PrintStatus(bph.desc, PushPromptUploading)
}</span>

// OnBlobUploaded implements BlobPushHandler.
func (bph *TextBlobPushHandler) OnBlobUploaded() error <span class="cov0" title="0">{
        return bph.printer.PrintStatus(bph.desc, PushPromptUploaded)
}</span>

// StartTracking implements BlobPushHandler.
func (bph *TextBlobPushHandler) StartTracking(gt oras.GraphTarget) (oras.GraphTarget, error) <span class="cov0" title="0">{
        return gt, nil
}</span>

// StopTracking implements BlobPushHandler.
func (bph *TextBlobPushHandler) StopTracking() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package track

import (
        "io"
        "os"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        sprogress "oras.land/oras/cmd/oras/internal/display/status/progress"
        "oras.land/oras/internal/progress"
)

// Reader is a tracked io.Reader.
type Reader struct {
        io.Reader
        tracker progress.Tracker
        manager progress.Manager
}

// NewReader returns a new reader with tracked progress.
func NewReader(r io.Reader, descriptor ocispec.Descriptor, actionPrompt string, donePrompt string, tty *os.File) (*Reader, error) <span class="cov1" title="1">{
        prompt := map[progress.State]string{
                progress.StateInitialized:  actionPrompt,
                progress.StateTransmitting: actionPrompt,
                progress.StateTransmitted:  donePrompt,
        }

        manager, err := sprogress.NewManager(tty, prompt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return newReader(r, descriptor, manager)</span>
}

func newReader(r io.Reader, descriptor ocispec.Descriptor, manager progress.Manager) (*Reader, error) <span class="cov7" title="6">{
        tracker, err := manager.Track(descriptor)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="6">return &amp;Reader{
                Reader:  progress.TrackReader(tracker, r),
                tracker: tracker,
                manager: manager,
        }, nil</span>
}

// Tracker returns the progress tracker.
func (r *Reader) Tracker() progress.Tracker <span class="cov10" title="12">{
        return r.tracker
}</span>

// StopTracker stops the messenger channel.
func (r *Reader) StopTracker() <span class="cov6" title="5">{
        _ = r.tracker.Close()
}</span>

// StopManager stops the messenger channel and related manager.
func (r *Reader) StopManager() <span class="cov1" title="1">{
        _ = r.tracker.Close()
        _ = r.manager.Close()
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package track

import (
        "context"
        "errors"
        "io"
        "os"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/errdef"
        "oras.land/oras-go/v2/registry"
        sprogress "oras.land/oras/cmd/oras/internal/display/status/progress"
        "oras.land/oras/internal/progress"
)

// GraphTarget is a tracked oras.GraphTarget.
type GraphTarget interface {
        oras.GraphTarget
        io.Closer
        Report(desc ocispec.Descriptor, state progress.State) error
}

type graphTarget struct {
        oras.GraphTarget
        manager progress.Manager
}

type referenceGraphTarget struct {
        *graphTarget
}

// NewTarget creates a new tracked Target.
func NewTarget(t oras.GraphTarget, prompts map[progress.State]string, tty *os.File) (GraphTarget, error) <span class="cov10" title="14">{
        manager, err := sprogress.NewManager(tty, prompts)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>
        <span class="cov9" title="12">gt := &amp;graphTarget{
                GraphTarget: t,
                manager:     manager,
        }

        if _, ok := t.(registry.ReferencePusher); ok </span><span class="cov3" title="2">{
                return &amp;referenceGraphTarget{
                        graphTarget: gt,
                }, nil
        }</span>
        <span class="cov8" title="10">return gt, nil</span>
}

// Mount mounts a blob from a specified repository. This method is invoked only
// by the `*remote.Repository` target.
func (t *graphTarget) Mount(ctx context.Context, desc ocispec.Descriptor, fromRepo string, getContent func() (io.ReadCloser, error)) error <span class="cov3" title="2">{
        mounter := t.GraphTarget.(registry.Mounter)
        return mounter.Mount(ctx, desc, fromRepo, getContent)
}</span>

// Push pushes the content to the base oras.GraphTarget with tracking.
func (t *graphTarget) Push(ctx context.Context, expected ocispec.Descriptor, content io.Reader) error <span class="cov5" title="4">{
        r, err := newReader(content, expected, t.manager)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="4">defer r.StopTracker()
        if err := progress.Start(r.Tracker()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="4">if err := t.GraphTarget.Push(ctx, expected, r); err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, errdef.ErrAlreadyExists) </span><span class="cov1" title="1">{
                        // allowed error types in oras-go oci and memory store
                        if err := progress.Done(r.Tracker()); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov1" title="1">return err</span>
        }
        <span class="cov4" title="3">return progress.Done(r.Tracker())</span>
}

// PushReference pushes the content to the base oras.GraphTarget with tracking.
func (rgt *referenceGraphTarget) PushReference(ctx context.Context, expected ocispec.Descriptor, content io.Reader, reference string) error <span class="cov1" title="1">{
        r, err := newReader(content, expected, rgt.manager)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer r.StopTracker()
        if err := progress.Start(r.Tracker()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">err = rgt.GraphTarget.(registry.ReferencePusher).PushReference(ctx, expected, r, reference)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return progress.Done(r.Tracker())</span>
}

// Close closes the tracking manager.
func (t *graphTarget) Close() error <span class="cov8" title="10">{
        return t.manager.Close()
}</span>

// Report prompts the user with the provided state and descriptor.
func (t *graphTarget) Report(desc ocispec.Descriptor, state progress.State) error <span class="cov5" title="4">{
        tracker, err := t.manager.Track(desc)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="4">if err = tracker.Update(progress.Status{
                State:  state,
                Offset: desc.Size,
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="4">return tracker.Close()</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package status

import (
        "context"
        "os"
        "sync"

        "oras.land/oras/internal/graph"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/content"
        "oras.land/oras/cmd/oras/internal/display/status/track"
        "oras.land/oras/internal/progress"
)

// TTYPushHandler handles TTY status output for push command.
type TTYPushHandler struct {
        tty       *os.File
        tracked   track.GraphTarget
        committed *sync.Map
        fetcher   content.Fetcher
}

// NewTTYPushHandler returns a new handler for push status events.
func NewTTYPushHandler(tty *os.File, fetcher content.Fetcher) PushHandler <span class="cov9" title="7">{
        return &amp;TTYPushHandler{
                tty:       tty,
                fetcher:   fetcher,
                committed: &amp;sync.Map{},
        }
}</span>

// OnFileLoading is called before loading a file.
func (ph *TTYPushHandler) OnFileLoading(_ string) error <span class="cov1" title="1">{
        return nil
}</span>

// OnEmptyArtifact is called when no file is loaded for an artifact push.
func (ph *TTYPushHandler) OnEmptyArtifact() error <span class="cov1" title="1">{
        return nil
}</span>

// TrackTarget returns a tracked target.
func (ph *TTYPushHandler) TrackTarget(gt oras.GraphTarget) (oras.GraphTarget, StopTrackTargetFunc, error) <span class="cov4" title="2">{
        prompt := map[progress.State]string{
                progress.StateInitialized:  PushPromptUploading,
                progress.StateTransmitting: PushPromptUploading,
                progress.StateTransmitted:  PushPromptUploaded,
                progress.StateExists:       PushPromptExists,
                progress.StateSkipped:      PushPromptSkipped,
        }
        tracked, err := track.NewTarget(gt, prompt, ph.tty)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">ph.tracked = tracked
        return tracked, tracked.Close, nil</span>
}

// OnCopySkipped is called when an object already exists.
func (ph *TTYPushHandler) OnCopySkipped(_ context.Context, desc ocispec.Descriptor) error <span class="cov1" title="1">{
        ph.committed.Store(desc.Digest.String(), desc.Annotations[ocispec.AnnotationTitle])
        return ph.tracked.Report(desc, progress.StateExists)
}</span>

// PreCopy implements PreCopy of CopyHandler.
func (ph *TTYPushHandler) PreCopy(_ context.Context, _ ocispec.Descriptor) error <span class="cov0" title="0">{
        return nil
}</span>

// PostCopy implements PostCopy of CopyHandler.
func (ph *TTYPushHandler) PostCopy(ctx context.Context, desc ocispec.Descriptor) error <span class="cov5" title="3">{
        ph.committed.Store(desc.Digest.String(), desc.Annotations[ocispec.AnnotationTitle])
        successors, err := graph.FilteredSuccessors(ctx, desc, ph.fetcher, DeduplicatedFilter(ph.committed))
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov4" title="2">for _, successor := range successors </span><span class="cov1" title="1">{
                if err = ph.tracked.Report(successor, progress.StateSkipped); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// NewTTYAttachHandler returns a new handler for attach status events.
func NewTTYAttachHandler(tty *os.File, fetcher content.Fetcher) AttachHandler <span class="cov4" title="2">{
        return NewTTYPushHandler(tty, fetcher)
}</span>

// TTYPullHandler handles TTY status output for pull events.
type TTYPullHandler struct {
        tty     *os.File
        tracked track.GraphTarget
}

// NewTTYPullHandler returns a new handler for Pull status events.
func NewTTYPullHandler(tty *os.File) PullHandler <span class="cov8" title="6">{
        return &amp;TTYPullHandler{
                tty: tty,
        }
}</span>

// OnNodeDownloading implements PullHandler.
func (ph *TTYPullHandler) OnNodeDownloading(_ ocispec.Descriptor) error <span class="cov1" title="1">{
        return nil
}</span>

// OnNodeDownloaded implements PullHandler.
func (ph *TTYPullHandler) OnNodeDownloaded(_ ocispec.Descriptor) error <span class="cov1" title="1">{
        return nil
}</span>

// OnNodeProcessing implements PullHandler.
func (ph *TTYPullHandler) OnNodeProcessing(_ ocispec.Descriptor) error <span class="cov1" title="1">{
        return nil
}</span>

// OnNodeRestored implements PullHandler.
func (ph *TTYPullHandler) OnNodeRestored(desc ocispec.Descriptor) error <span class="cov0" title="0">{
        return ph.tracked.Report(desc, progress.StateRestored)
}</span>

// OnNodeSkipped implements PullHandler.
func (ph *TTYPullHandler) OnNodeSkipped(desc ocispec.Descriptor) error <span class="cov0" title="0">{
        return ph.tracked.Report(desc, progress.StateSkipped)
}</span>

// TrackTarget returns a tracked target.
func (ph *TTYPullHandler) TrackTarget(gt oras.GraphTarget) (oras.GraphTarget, StopTrackTargetFunc, error) <span class="cov4" title="2">{
        prompt := map[progress.State]string{
                progress.StateInitialized:  PullPromptDownloading,
                progress.StateTransmitting: PullPromptDownloading,
                progress.StateTransmitted:  PullPromptPulled,
                progress.StateSkipped:      PullPromptSkipped,
                progress.StateRestored:     PullPromptRestored,
        }
        tracked, err := track.NewTarget(gt, prompt, ph.tty)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">ph.tracked = tracked
        return tracked, tracked.Close, nil</span>
}

// TTYCopyHandler handles tty status output for copy events.
type TTYCopyHandler struct {
        tty       *os.File
        committed sync.Map
        tracked   track.GraphTarget
}

// NewTTYCopyHandler returns a new handler for copy command.
func NewTTYCopyHandler(tty *os.File) CopyHandler <span class="cov10" title="8">{
        return &amp;TTYCopyHandler{
                tty: tty,
        }
}</span>

// StartTracking returns a tracked target from a graph target.
func (ch *TTYCopyHandler) StartTracking(gt oras.GraphTarget) (oras.GraphTarget, error) <span class="cov9" title="7">{
        prompt := map[progress.State]string{
                progress.StateInitialized:  copyPromptCopying,
                progress.StateTransmitting: copyPromptCopying,
                progress.StateTransmitted:  copyPromptCopied,
                progress.StateExists:       copyPromptExists,
                progress.StateSkipped:      copyPromptSkipped,
                progress.StateMounted:      copyPromptMounted,
        }
        var err error
        ch.tracked, err = track.NewTarget(gt, prompt, ch.tty)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="7">return ch.tracked, err</span>
}

// StopTracking ends the copy tracking for the target.
func (ch *TTYCopyHandler) StopTracking() error <span class="cov9" title="7">{
        return ch.tracked.Close()
}</span>

// OnCopySkipped is called when an object already exists.
func (ch *TTYCopyHandler) OnCopySkipped(_ context.Context, desc ocispec.Descriptor) error <span class="cov4" title="2">{
        ch.committed.Store(desc.Digest.String(), desc.Annotations[ocispec.AnnotationTitle])
        return ch.tracked.Report(desc, progress.StateExists)
}</span>

// PreCopy implements PreCopy of CopyHandler.
func (ch *TTYCopyHandler) PreCopy(context.Context, ocispec.Descriptor) error <span class="cov5" title="3">{
        return nil
}</span>

// PostCopy implements PostCopy of CopyHandler.
func (ch *TTYCopyHandler) PostCopy(ctx context.Context, desc ocispec.Descriptor) error <span class="cov5" title="3">{
        ch.committed.Store(desc.Digest.String(), desc.Annotations[ocispec.AnnotationTitle])
        successors, err := graph.FilteredSuccessors(ctx, desc, ch.tracked, DeduplicatedFilter(&amp;ch.committed))
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov4" title="2">for _, successor := range successors </span><span class="cov0" title="0">{
                if err = ch.tracked.Report(successor, progress.StateSkipped); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov4" title="2">return nil</span>
}

// OnMounted implements OnMounted of CopyHandler.
func (ch *TTYCopyHandler) OnMounted(_ context.Context, desc ocispec.Descriptor) error <span class="cov4" title="2">{
        ch.committed.Store(desc.Digest.String(), desc.Annotations[ocispec.AnnotationTitle])
        return ch.tracked.Report(desc, progress.StateMounted)
}</span>

// TTYBlobPushHandler handles tty status output for blob push events.
type TTYBlobPushHandler struct {
        desc    ocispec.Descriptor
        tty     *os.File
        tracked track.GraphTarget
}

// NewTTYBlobPushHandler returns a new handler for blob push command.
func NewTTYBlobPushHandler(tty *os.File, desc ocispec.Descriptor) BlobPushHandler <span class="cov1" title="1">{
        return &amp;TTYBlobPushHandler{
                tty:  tty,
                desc: desc,
        }
}</span>

// StartTracking returns a tracked target from a graph target.
func (bph *TTYBlobPushHandler) StartTracking(gt oras.GraphTarget) (oras.GraphTarget, error) <span class="cov1" title="1">{
        prompt := map[progress.State]string{
                progress.StateInitialized:  PushPromptUploading,
                progress.StateTransmitting: PushPromptUploading,
                progress.StateTransmitted:  PushPromptUploaded,
                progress.StateExists:       PushPromptExists,
        }
        tracked, err := track.NewTarget(gt, prompt, bph.tty)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">bph.tracked = tracked
        return bph.tracked, nil</span>
}

// StopTracking ends the blob push tracking for the target.
func (bph *TTYBlobPushHandler) StopTracking() error <span class="cov1" title="1">{
        return bph.tracked.Close()
}</span>

// OnBlobExists implements BlobPushHandler.
func (bph *TTYBlobPushHandler) OnBlobExists() error <span class="cov0" title="0">{
        return bph.tracked.Report(bph.desc, progress.StateExists)
}</span>

// OnBlobUploading implements BlobPushHandler.
func (bph *TTYBlobPushHandler) OnBlobUploading() error <span class="cov1" title="1">{
        return nil
}</span>

// OnBlobUploaded implements BlobPushHandler.
func (bph *TTYBlobPushHandler) OnBlobUploaded() error <span class="cov1" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package status

import (
        "sync"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
)

// Prompts for pull events.
const (
        PullPromptDownloading = "Downloading"
        PullPromptPulled      = "Pulled     "
        PullPromptProcessing  = "Processing "
        PullPromptSkipped     = "Skipped    "
        PullPromptRestored    = "Restored   "
        PullPromptDownloaded  = "Downloaded "
)

// Prompts for push/attach events.
const (
        PushPromptUploaded  = "Uploaded "
        PushPromptUploading = "Uploading"
        PushPromptSkipped   = "Skipped  "
        PushPromptExists    = "Exists   "
)

// Prompts for cp events.
const (
        copyPromptExists  = "Exists "
        copyPromptCopying = "Copying"
        copyPromptCopied  = "Copied "
        copyPromptSkipped = "Skipped"
        copyPromptMounted = "Mounted"
)

// Prompts for index events.
const (
        IndexPromptFetching = "Fetching "
        IndexPromptFetched  = "Fetched  "
        IndexPromptAdded    = "Added    "
        IndexPromptMerged   = "Merged   "
        IndexPromptRemoved  = "Removed  "
        IndexPromptPacked   = "Packed   "
        IndexPromptPushed   = "Pushed   "
        IndexPromptUpdated  = "Updated  "
)

// DeduplicatedFilter filters out deduplicated descriptors.
func DeduplicatedFilter(committed *sync.Map) func(desc ocispec.Descriptor) bool <span class="cov8" title="10">{
        return func(desc ocispec.Descriptor) bool </span><span class="cov10" title="17">{
                name := desc.Annotations[ocispec.AnnotationTitle]
                v, ok := committed.Load(desc.Digest.String())
                // committed but not printed == deduplicated
                return ok &amp;&amp; v != name
        }</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package errors

import (
        "errors"
        "fmt"
        "strings"

        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "oras.land/oras-go/v2/registry/remote/auth"
        "oras.land/oras-go/v2/registry/remote/errcode"
)

// OperationType stands for certain type of operations.
type OperationType int

const (
        // OperationTypeParseArtifactReference represents parsing artifact
        // reference operation.
        OperationTypeParseArtifactReference OperationType = iota + 1
)

// RegistryErrorPrefix is the commandline prefix for errors from registry.
const RegistryErrorPrefix = "Error response from registry:"

// UnsupportedFormatTypeError generates the error message for an invalid type.
type UnsupportedFormatTypeError string

// Error implements the error interface.
func (e UnsupportedFormatTypeError) Error() string <span class="cov5" title="6">{
        return "unsupported format type: " + string(e)
}</span>

// Error is the error type for CLI error messaging.
type Error struct {
        OperationType  OperationType
        Err            error
        Usage          string
        Recommendation string
}

// Unwrap implements the errors.Wrapper interface.
func (o *Error) Unwrap() error <span class="cov2" title="2">{
        return o.Err
}</span>

// Error implements the error interface.
func (o *Error) Error() string <span class="cov0" title="0">{
        ret := o.Err.Error()
        if o.Usage != "" </span><span class="cov0" title="0">{
                ret += fmt.Sprintf("\nUsage: %s", o.Usage)
        }</span>
        <span class="cov0" title="0">if o.Recommendation != "" </span><span class="cov0" title="0">{
                ret += fmt.Sprintf("\n%s", o.Recommendation)
        }</span>
        <span class="cov0" title="0">return ret</span>
}

// CheckArgs checks the args with the checker function.
func CheckArgs(checker func(args []string) (bool, string), Usage string) cobra.PositionalArgs <span class="cov0" title="0">{
        return func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                if ok, text := checker(args); !ok </span><span class="cov0" title="0">{
                        return &amp;Error{
                                Err:            fmt.Errorf(`%q requires %s but got %d`, cmd.CommandPath(), text, len(args)),
                                Usage:          fmt.Sprintf("%s %s", cmd.Parent().CommandPath(), cmd.Use),
                                Recommendation: fmt.Sprintf(`Please specify %s as %s. Run "%s -h" for more options and examples`, text, Usage, cmd.CommandPath()),
                        }
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

// Modifier modifies the error during cmd execution.
type Modifier interface {
        Modify(cmd *cobra.Command, err error) (modifiedErr error, modified bool)
}

// Command returns an error-handled cobra command.
func Command(cmd *cobra.Command, handler Modifier) *cobra.Command <span class="cov0" title="0">{
        runE := cmd.RunE
        cmd.RunE = func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                err := runE(cmd, args)
                if err != nil </span><span class="cov0" title="0">{
                        err, _ = handler.Modify(cmd, err)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return cmd</span>
}

// TrimErrResp tries to trim toTrim from err.
func TrimErrResp(err error, toTrim error) error <span class="cov4" title="4">{
        var inner error
        if errResp, ok := toTrim.(*errcode.ErrorResponse); ok </span><span class="cov4" title="4">{
                if len(errResp.Errors) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("recognizable error message not found: %w", toTrim)
                }</span>
                <span class="cov4" title="4">inner = errResp.Errors</span>
        } else<span class="cov0" title="0"> {
                return err
        }</span>
        <span class="cov4" title="4">return reWrap(err, toTrim, inner)</span>
}

// TrimErrBasicCredentialNotFound trims the credentials from err.
// Caller should make sure the err is auth.ErrBasicCredentialNotFound.
func TrimErrBasicCredentialNotFound(err error) error <span class="cov0" title="0">{
        toTrim := err
        inner := err
        for </span><span class="cov0" title="0">{
                switch x := inner.(type) </span>{
                case interface{ Unwrap() error }:<span class="cov0" title="0">
                        toTrim = inner
                        inner = x.Unwrap()
                        continue</span>
                case interface{ Unwrap() []error }:<span class="cov0" title="0">
                        for _, errItem := range x.Unwrap() </span><span class="cov0" title="0">{
                                if errors.Is(errItem, auth.ErrBasicCredentialNotFound) </span><span class="cov0" title="0">{
                                        toTrim = errItem
                                        inner = errItem
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">break</span>
        }
        <span class="cov0" title="0">return reWrap(err, toTrim, auth.ErrBasicCredentialNotFound)</span>
}

// reWrap re-wraps errA to errC and trims out errB, returns errC if scrub fails.
// +---------- errA ----------+
// |         +---- errB ----+ |      +---- errA ----+
// |         |    errC      | |  =&gt;  |     errC     |
// |         +--------------+ |      +--------------+
// +--------------------------+
func reWrap(errA, errB, errC error) error <span class="cov4" title="4">{
        // TODO: trim dedicated error type when
        // https://github.com/oras-project/oras-go/issues/677 is done
        contentA := errA.Error()
        contentB := errB.Error()
        if idx := strings.Index(contentA, contentB); idx &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%s%w", contentA[:idx], errC)
        }</span>
        <span class="cov4" title="4">return errC</span>
}

// NewErrEmptyTagOrDigest creates a new error based on the reference string.
func NewErrEmptyTagOrDigest(ref string, cmd *cobra.Command, needsTag bool) error <span class="cov0" title="0">{
        form := `"&lt;name&gt;@&lt;digest&gt;"`
        errMsg := `no digest specified`
        if needsTag </span><span class="cov0" title="0">{
                form = fmt.Sprintf(`"&lt;name&gt;:&lt;tag&gt;" or %s`, form)
                errMsg = "no tag or digest specified"
        }</span>
        <span class="cov0" title="0">return &amp;Error{
                OperationType:  OperationTypeParseArtifactReference,
                Err:            fmt.Errorf(`"%s": %s`, ref, errMsg),
                Usage:          fmt.Sprintf("%s %s", cmd.Parent().CommandPath(), cmd.Use),
                Recommendation: fmt.Sprintf(`Please specify a reference in the form of %s. Run "%s -h" for more options and examples`, form, cmd.CommandPath()),
        }</span>
}

// CheckMutuallyExclusiveFlags checks if any mutually exclusive flags are used
// at the same time, returns an error when detecting used exclusive flags.
func CheckMutuallyExclusiveFlags(fs *pflag.FlagSet, exclusiveFlagSet ...string) error <span class="cov6" title="9">{
        changedFlags, _ := checkChangedFlags(fs, exclusiveFlagSet...)
        if len(changedFlags) &gt;= 2 </span><span class="cov2" title="2">{
                flags := strings.Join(changedFlags, ", ")
                return fmt.Errorf("%s cannot be used at the same time", flags)
        }</span>
        <span class="cov6" title="7">return nil</span>
}

// CheckRequiredTogetherFlags checks if any flags required together are all used,
// returns an error when detecting any flags not used while other flags have been used.
func CheckRequiredTogetherFlags(fs *pflag.FlagSet, requiredTogetherFlags ...string) error <span class="cov4" title="4">{
        changed, unchanged := checkChangedFlags(fs, requiredTogetherFlags...)
        unchangedCount := len(unchanged)
        if unchangedCount != 0 &amp;&amp; unchangedCount != len(requiredTogetherFlags) </span><span class="cov1" title="1">{
                changed := strings.Join(changed, ", ")
                unchanged := strings.Join(unchanged, ", ")
                return fmt.Errorf("%s must be used in conjunction with %s", changed, unchanged)
        }</span>
        <span class="cov3" title="3">return nil</span>
}

func checkChangedFlags(fs *pflag.FlagSet, flagSet ...string) (changedFlags []string, unchangedFlags []string) <span class="cov7" title="13">{
        for _, flagName := range flagSet </span><span class="cov10" title="29">{
                if fs.Changed(flagName) </span><span class="cov6" title="8">{
                        changedFlags = append(changedFlags, fmt.Sprintf("--%s", flagName))
                }</span> else<span class="cov9" title="21"> {
                        unchangedFlags = append(unchangedFlags, fmt.Sprintf("--%s", flagName))
                }</span>
        }
        <span class="cov7" title="13">return</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">//go:build !windows

/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package fileref

import (
        "fmt"
        "strings"
)

// Parse parses file reference on unix.
func Parse(reference string, defaultMetadata string) (filePath, metadata string, err error) <span class="cov10" title="18">{
        i := strings.LastIndex(reference, ":")
        if i &lt; 0 </span><span class="cov5" title="4">{
                filePath, metadata = reference, defaultMetadata
        }</span> else<span class="cov9" title="14"> {
                filePath, metadata = reference[:i], reference[i+1:]
        }</span>
        <span class="cov10" title="18">if filePath == "" </span><span class="cov6" title="6">{
                return "", "", fmt.Errorf("found empty file path in %q", reference)
        }</span>
        <span class="cov8" title="12">return filePath, metadata, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package manifest

import (
        "encoding/json"
        "errors"
)

var (
        // ErrMediaTypeNotFound is returned when the media type is not specified.
        ErrMediaTypeNotFound = errors.New(`media type is not specified`)
        // ErrInvalidJSON is returned when the json file is malformed.
        ErrInvalidJSON = errors.New("not a valid json file")
)

// ExtractMediaType parses the media type field of bytes content in json format.
func ExtractMediaType(content []byte) (string, error) <span class="cov10" title="3">{
        var manifest struct {
                MediaType string `json:"mediaType"`
        }
        if err := json.Unmarshal(content, &amp;manifest); err != nil </span><span class="cov1" title="1">{
                return "", ErrInvalidJSON
        }</span>
        <span class="cov6" title="2">if manifest.MediaType == "" </span><span class="cov1" title="1">{
                return "", ErrMediaTypeNotFound
        }</span>
        <span class="cov1" title="1">return manifest.MediaType, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import (
        "errors"
        "fmt"
        "strings"

        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
)

var (
        errAnnotationFormat      = errors.New("annotation value doesn't match the required format")
        errAnnotationDuplication = errors.New("duplicate annotation key")
)

// Annotation option struct.
type Annotation struct {
        // ManifestAnnotations contains raw input of manifest annotation "key=value" pairs
        ManifestAnnotations []string

        // Annotations contains parsed manifest and config annotations
        Annotations map[string]map[string]string
}

// ApplyFlags applies flags to a command flag set.
func (opts *Annotation) ApplyFlags(fs *pflag.FlagSet) <span class="cov1" title="1">{
        fs.StringArrayVarP(&amp;opts.ManifestAnnotations, "annotation", "a", nil, "manifest annotations")
}</span>

// Parse parses the input annotation flags.
func (opts *Annotation) Parse(*cobra.Command) error <span class="cov7" title="5">{
        manifestAnnotations := make(map[string]string)
        for _, anno := range opts.ManifestAnnotations </span><span class="cov10" title="9">{
                key, val, success := strings.Cut(anno, "=")
                if !success </span><span class="cov3" title="2">{
                        return &amp;oerrors.Error{
                                Err:            errAnnotationFormat,
                                Recommendation: `Please use the correct format in the flag: --annotation "key=value"`,
                        }
                }</span>
                <span class="cov8" title="7">if _, ok := manifestAnnotations[key]; ok </span><span class="cov3" title="2">{
                        return fmt.Errorf("%w: %v, ", errAnnotationDuplication, key)
                }</span>
                <span class="cov7" title="5">manifestAnnotations[key] = val</span>
        }
        <span class="cov1" title="1">opts.Annotations = map[string]map[string]string{
                AnnotationManifest: manifestAnnotations,
        }
        return nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import (
        "github.com/spf13/pflag"
)

// FlagApplier applies flags to a command flag set.
type FlagApplier interface {
        ApplyFlags(*pflag.FlagSet)
}

// ApplyFlags applies applicable fields of the passed-in option pointer to the
// target flag set.
// NOTE: The option argument need to be a pointer to the options, so its value
// becomes addressable.
func ApplyFlags(optsPtr any, target *pflag.FlagSet) <span class="cov10" title="11">{
        for applier := range fields[FlagApplier](optsPtr) </span><span class="cov10" title="11">{
                applier.ApplyFlags(target)
        }</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import (
        "sync"

        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
)

// BinaryTarget struct contains flags and arguments specifying two registries or
// image layouts.
// BinaryTarget implements errors.Handler interface.
type BinaryTarget struct {
        From        Target
        To          Target
        resolveFlag []string
}

// EnsureSourceTargetReferenceNotEmpty ensures that from target reference is not empty.
func (target *BinaryTarget) EnsureSourceTargetReferenceNotEmpty(cmd *cobra.Command) error <span class="cov0" title="0">{
        if target.From.Reference == "" </span><span class="cov0" title="0">{
                return oerrors.NewErrEmptyTagOrDigest(target.From.RawReference, cmd, true)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// EnableDistributionSpecFlag set distribution specification flag as applicable.
func (target *BinaryTarget) EnableDistributionSpecFlag() <span class="cov0" title="0">{
        target.From.EnableDistributionSpecFlag()
        target.To.EnableDistributionSpecFlag()
}</span>

// ApplyFlags applies flags to a command flag set fs.
func (target *BinaryTarget) ApplyFlags(fs *pflag.FlagSet) <span class="cov0" title="0">{
        target.From.ApplyFlagsWithPrefix(fs, "from", "source")
        target.To.ApplyFlagsWithPrefix(fs, "to", "destination")
        fs.StringArrayVarP(&amp;target.resolveFlag, "resolve", "", nil, "base DNS rules formatted in `host:port:address[:address_port]` for --from-resolve and --to-resolve")
}</span>

// Parse parses user-provided flags and arguments into option struct.
func (target *BinaryTarget) Parse(cmd *cobra.Command) error <span class="cov0" title="0">{
        target.From.warned = make(map[string]*sync.Map)
        target.To.warned = target.From.warned
        // resolve are parsed in array order, latter will overwrite former
        target.From.resolveFlag = append(target.resolveFlag, target.From.resolveFlag...)
        target.To.resolveFlag = append(target.resolveFlag, target.To.resolveFlag...)
        return Parse(cmd, target)
}</span>

// Modify handles error during cmd execution.
func (target *BinaryTarget) Modify(cmd *cobra.Command, err error) (error, bool) <span class="cov0" title="0">{
        if modifiedErr, modified := target.From.Modify(cmd, err); modified </span><span class="cov0" title="0">{
                return modifiedErr, modified
        }</span>
        <span class="cov0" title="0">return target.To.Modify(cmd, err)</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import (
        "os"

        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/content/oci"
        "oras.land/oras/internal/cache"
)

type Cache struct {
        Root string
}

// CachedTarget gets the target storage with caching if cache root is specified.
func (opts *Cache) CachedTarget(src oras.ReadOnlyTarget) (oras.ReadOnlyTarget, error) <span class="cov10" title="2">{
        opts.Root = os.Getenv("ORAS_CACHE")
        if opts.Root != "" </span><span class="cov1" title="1">{
                ociStore, err := oci.New(opts.Root)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">return cache.New(src, ociStore), nil</span>
        }
        <span class="cov1" title="1">return src, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import (
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "oras.land/oras/cmd/oras/internal/output"
)

// Common option struct.
type Common struct {
        Printer *output.Printer
        Debug   bool
}

// ApplyFlags applies flags to a command flag set.
func (opts *Common) ApplyFlags(fs *pflag.FlagSet) <span class="cov0" title="0">{
        fs.BoolVarP(&amp;opts.Debug, "debug", "d", false, "output debug logs (implies --no-tty)")
}</span>

// Parse gets target options from user input.
func (opts *Common) Parse(cmd *cobra.Command) error <span class="cov0" title="0">{
        opts.Printer = output.NewPrinter(cmd.OutOrStdout(), cmd.OutOrStderr())
        return nil
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import (
        "bufio"
        "fmt"
        "io"
        "strings"

        "github.com/spf13/pflag"
)

// Confirmation option struct.
type Confirmation struct {
        Force bool
}

// ApplyFlags applies flags to a command flag set.
func (opts *Confirmation) ApplyFlags(fs *pflag.FlagSet) <span class="cov1" title="1">{
        fs.BoolVarP(&amp;opts.Force, "force", "f", false, "ignore nonexistent references, never prompt")
}</span>

// AskForConfirmation prints a propmt to ask for confirmation before doing an
// action and takes user input as response.
func (opts *Confirmation) AskForConfirmation(r io.Reader, prompt string) (bool, error) <span class="cov10" title="3">{
        if opts.Force </span><span class="cov1" title="1">{
                return true, nil
        }</span>

        <span class="cov6" title="2">fmt.Print(prompt, " [y/N] ")

        var response string
        scanner := bufio.NewScanner(r)
        if ok := scanner.Scan(); ok </span><span class="cov6" title="2">{
                response = scanner.Text()
        }</span>
        <span class="cov6" title="2">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov6" title="2">switch strings.ToLower(response) </span>{
        case "y", "yes":<span class="cov1" title="1">
                return true, nil</span>
        default:<span class="cov1" title="1">
                fmt.Println("Operation cancelled.")
                return false, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file60" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import (
        "encoding/json"
        "fmt"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/spf13/pflag"
)

// Descriptor option struct.
type Descriptor struct {
        OutputDescriptor bool
}

// ApplyFlags applies flags to a command flag set.
func (opts *Descriptor) ApplyFlags(fs *pflag.FlagSet) <span class="cov8" title="1">{
        fs.BoolVarP(&amp;opts.OutputDescriptor, "descriptor", "", false, "output the descriptor")
}</span>

// Marshal returns the JSON encoding of descriptor.
func (opts *Descriptor) Marshal(desc ocispec.Descriptor) ([]byte, error) <span class="cov8" title="1">{
        b, err := json.Marshal(desc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal descriptor: %w", err)
        }</span>
        <span class="cov8" title="1">return b, nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import (
        "bytes"
        "fmt"
        "strings"
        "text/tabwriter"

        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
)

// FormatType represents a format type.
type FormatType struct {
        // Name is the format type name.
        Name string
        // Usage is the usage string in help doc.
        Usage string
        // HasParams indicates whether the format type has parameters.
        HasParams bool
}

// WithUsage returns a new format type with provided usage string.
func (ft *FormatType) WithUsage(usage string) *FormatType <span class="cov0" title="0">{
        return &amp;FormatType{
                Name:      ft.Name,
                HasParams: ft.HasParams,
                Usage:     usage,
        }
}</span>

// format types
var (
        FormatTypeJSON = &amp;FormatType{
                Name:  "json",
                Usage: "Print in JSON format",
        }
        FormatTypeGoTemplate = &amp;FormatType{
                Name:      "go-template",
                Usage:     "Print output using the given Go template",
                HasParams: true,
        }
        // the table format is deprecated
        FormatTypeTable = &amp;FormatType{
                Name:  "table",
                Usage: "[Deprecated] Get referrers and output in table format",
        }
        FormatTypeTree = &amp;FormatType{
                Name:  "tree",
                Usage: "Get referrers and print in tree format",
        }
        FormatTypeText = &amp;FormatType{
                Name:  "text",
                Usage: "Print in text format",
        }
)

// Format contains input and parsed options for formatted output flags.
type Format struct {
        FormatFlag   string
        Type         string
        Template     string
        allowedTypes []*FormatType
}

// SetTypes sets the default format type and allowed format types.
func (f *Format) SetTypes(defaultType *FormatType, otherTypes ...*FormatType) <span class="cov0" title="0">{
        f.FormatFlag = defaultType.Name
        f.allowedTypes = append(otherTypes, defaultType)
}</span>

// ApplyFlags implements FlagProvider.ApplyFlag.
func (opts *Format) ApplyFlags(fs *pflag.FlagSet) <span class="cov0" title="0">{
        buf := bytes.NewBufferString("[Experimental] format output using a custom template:")
        w := tabwriter.NewWriter(buf, 0, 0, 2, ' ', 0)
        for _, t := range opts.allowedTypes </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(w, "\n'%s':\t%s", t.Name, t.Usage)
        }</span>
        <span class="cov0" title="0">_ = w.Flush()
        // apply flags
        fs.StringVar(&amp;opts.FormatFlag, "format", opts.FormatFlag, buf.String())
        fs.StringVar(&amp;opts.Template, "template", "", "[Experimental] template string used to format output")</span>
}

// Parse parses the input format flag.
func (opts *Format) Parse(cmd *cobra.Command) error <span class="cov0" title="0">{
        // print deprecation message for table format
        if opts.FormatFlag == FormatTypeTable.Name </span><span class="cov0" title="0">{
                _, _ = fmt.Fprint(cmd.ErrOrStderr(), "Format \"table\" is deprecated and will be removed in a future release.\n")
        }</span>
        <span class="cov0" title="0">if err := opts.parseFlag(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if opts.Type == FormatTypeText.Name </span><span class="cov0" title="0">{
                // flag not specified
                return nil
        }</span>

        <span class="cov0" title="0">if opts.Type == FormatTypeGoTemplate.Name &amp;&amp; opts.Template == "" </span><span class="cov0" title="0">{
                return &amp;oerrors.Error{
                        Err:            fmt.Errorf("%q format specified but no template given", opts.Type),
                        Recommendation: fmt.Sprintf("use `--format %s=TEMPLATE` to specify the template", opts.Type),
                }
        }</span>

        <span class="cov0" title="0">var optionalTypes []string
        for _, t := range opts.allowedTypes </span><span class="cov0" title="0">{
                if opts.Type == t.Name </span><span class="cov0" title="0">{
                        // type validation passed
                        return nil
                }</span>
                <span class="cov0" title="0">optionalTypes = append(optionalTypes, t.Name)</span>
        }
        <span class="cov0" title="0">return &amp;oerrors.Error{
                Err:            fmt.Errorf("invalid format type: %q", opts.Type),
                Recommendation: fmt.Sprintf("supported types: %s", strings.Join(optionalTypes, ", ")),
        }</span>
}

func (opts *Format) parseFlag() error <span class="cov0" title="0">{
        opts.Type = opts.FormatFlag
        if opts.Template != "" </span><span class="cov0" title="0">{
                // template explicitly set
                if opts.Type != FormatTypeGoTemplate.Name </span><span class="cov0" title="0">{
                        return fmt.Errorf("--template must be used with --format %s", FormatTypeGoTemplate.Name)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">for _, t := range opts.allowedTypes </span><span class="cov0" title="0">{
                if !t.HasParams </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">prefix := t.Name + "="
                if strings.HasPrefix(opts.FormatFlag, prefix) </span><span class="cov0" title="0">{
                        // parse type and add parameter to template
                        opts.Type = t.Name
                        opts.Template = opts.FormatFlag[len(prefix):]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "oras.land/oras-go/v2/content"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/fileref"
)

// Pre-defined annotation keys for annotation file
const (
        AnnotationManifest = "$manifest"
        AnnotationConfig   = "$config"
)

var (
        errAnnotationConflict = errors.New("`--annotation` and `--annotation-file` cannot be both specified")
        errPathValidation     = errors.New("absolute file path detected. If it's intentional, use --disable-path-validation flag to skip this check")
)

// Packer option struct.
type Packer struct {
        Annotation

        ManifestExportPath     string
        PathValidationDisabled bool
        AnnotationFilePath     string

        FileRefs []string
}

// ApplyFlags applies flags to a command flag set.
func (opts *Packer) ApplyFlags(fs *pflag.FlagSet) <span class="cov1" title="1">{
        opts.Annotation.ApplyFlags(fs)

        fs.StringVarP(&amp;opts.ManifestExportPath, "export-manifest", "", "", "`path` of the pushed manifest")
        fs.StringVarP(&amp;opts.AnnotationFilePath, "annotation-file", "", "", "path of the annotation file")
        fs.BoolVarP(&amp;opts.PathValidationDisabled, "disable-path-validation", "", false, "skip path validation")
}</span>

// ExportManifest saves the pushed manifest to a local file.
func (opts *Packer) ExportManifest(ctx context.Context, fetcher content.Fetcher, desc ocispec.Descriptor) error <span class="cov0" title="0">{
        if opts.ManifestExportPath == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">manifestBytes, err := content.FetchAll(ctx, fetcher, desc)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(opts.ManifestExportPath, manifestBytes, 0666)</span>
}

func (opts *Packer) Parse(cmd *cobra.Command) error <span class="cov1" title="1">{
        if !opts.PathValidationDisabled </span><span class="cov1" title="1">{
                var failedPaths []string
                for _, path := range opts.FileRefs </span><span class="cov0" title="0">{
                        // Remove the type if specified in the path &lt;file&gt;[:&lt;type&gt;] format
                        path, _, err := fileref.Parse(path, "")
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if filepath.IsAbs(path) </span><span class="cov0" title="0">{
                                failedPaths = append(failedPaths, path)
                        }</span>
                }
                <span class="cov1" title="1">if len(failedPaths) &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: %v", errPathValidation, strings.Join(failedPaths, ", "))
                }</span>
        }
        <span class="cov1" title="1">return opts.parseAnnotations(cmd)</span>
}

// parseAnnotations loads the manifest annotation map.
func (opts *Packer) parseAnnotations(cmd *cobra.Command) error <span class="cov10" title="9">{
        if opts.AnnotationFilePath != "" &amp;&amp; len(opts.ManifestAnnotations) != 0 </span><span class="cov3" title="2">{
                return errAnnotationConflict
        }</span>
        <span class="cov8" title="7">if opts.AnnotationFilePath != "" </span><span class="cov3" title="2">{
                if err := decodeJSON(opts.AnnotationFilePath, &amp;opts.Annotations); err != nil </span><span class="cov1" title="1">{
                        return &amp;oerrors.Error{
                                Err:            fmt.Errorf(`invalid annotation json file: failed to load annotations from %s`, opts.AnnotationFilePath),
                                Recommendation: `Annotation file doesn't match the required format. Please refer to the document at https://oras.land/docs/how_to_guides/manifest_annotations`,
                        }
                }</span>
        }
        <span class="cov8" title="6">if len(opts.ManifestAnnotations) != 0 </span><span class="cov7" title="5">{
                return opts.Annotation.Parse(cmd)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// decodeJSON decodes file contents into json.
func decodeJSON(filename string, v interface{}) (err error) <span class="cov7" title="5">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov3" title="2">{
                return err
        }</span>
        <span class="cov5" title="3">defer func() </span><span class="cov5" title="3">{
                closeErr := file.Close()
                if err == nil </span><span class="cov3" title="2">{
                        err = closeErr
                }</span>
        }()
        <span class="cov5" title="3">return json.NewDecoder(file).Decode(v)</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import (
        "iter"
        "reflect"

        "github.com/spf13/cobra"
)

// FlagParser parses flags in an option.
type FlagParser interface {
        Parse(cmd *cobra.Command) error
}

// Parse parses applicable fields of the passed-in option pointer and returns
// error during parsing.
func Parse(cmd *cobra.Command, optsPtr any) error <span class="cov2" title="2">{
        for parser := range fields[FlagParser](optsPtr) </span><span class="cov3" title="3">{
                if err := parser.Parse(cmd); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// fields returns an iterator that yields all fields of the given struct that
// implement the given interface.
func fields[T any](ptr any) iter.Seq[T] <span class="cov7" title="13">{
        return func(yield func(T) bool) </span><span class="cov7" title="13">{
                v := reflect.ValueOf(ptr).Elem()
                for i := range v.NumField() </span><span class="cov10" title="34">{
                        f := v.Field(i)
                        if f.CanSet() </span><span class="cov10" title="34">{
                                if opts, ok := f.Addr().Interface().(T); ok </span><span class="cov7" title="14">{
                                        if !yield(opts) </span><span class="cov1" title="1">{
                                                return
                                        }</span>
                                }
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file64" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import (
        "fmt"
        "runtime"
        "strings"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
)

// Platform option struct.
type Platform struct {
        platform        string
        Platform        *ocispec.Platform
        FlagDescription string
}

// ApplyFlags applies flags to a command flag set.
func (opts *Platform) ApplyFlags(fs *pflag.FlagSet) <span class="cov1" title="1">{
        if opts.FlagDescription == "" </span><span class="cov1" title="1">{
                opts.FlagDescription = "request platform"
        }</span>
        <span class="cov1" title="1">fs.StringVarP(&amp;opts.platform, "platform", "", "", opts.FlagDescription+" in the form of `os[/arch][/variant][:os_version]`")</span>
}

// Parse parses the input platform flag to an oci platform type.
func (opts *Platform) Parse(*cobra.Command) error <span class="cov10" title="12">{
        if opts.platform == "" </span><span class="cov1" title="1">{
                return nil
        }</span>

        // OS[/Arch[/Variant]][:OSVersion]
        // If Arch is not provided, will use GOARCH instead
        <span class="cov9" title="11">var platformStr string
        var p ocispec.Platform
        platformStr, p.OSVersion, _ = strings.Cut(opts.platform, ":")
        parts := strings.Split(platformStr, "/")
        switch len(parts) </span>{
        case 3:<span class="cov6" title="5">
                p.Variant = parts[2]
                fallthrough</span>
        case 2:<span class="cov8" title="9">
                p.Architecture = parts[1]</span>
        case 1:<span class="cov1" title="1">
                p.Architecture = runtime.GOARCH</span>
        default:<span class="cov1" title="1">
                return fmt.Errorf("failed to parse platform %q: expected format os[/arch[/variant]]", opts.platform)</span>
        }
        <span class="cov9" title="10">p.OS = parts[0]
        if p.OS == "" </span><span class="cov3" title="2">{
                return fmt.Errorf("invalid platform: OS cannot be empty")
        }</span>
        <span class="cov8" title="8">if p.Architecture == "" </span><span class="cov3" title="2">{
                return fmt.Errorf("invalid platform: Architecture cannot be empty")
        }</span>
        <span class="cov7" title="6">opts.Platform = &amp;p
        return nil</span>
}

// ArtifactPlatform option struct.
type ArtifactPlatform struct {
        Platform
}

// ApplyFlags applies flags to a command flag set.
func (opts *ArtifactPlatform) ApplyFlags(fs *pflag.FlagSet) <span class="cov0" title="0">{
        opts.FlagDescription = "set artifact platform"
        fs.StringVarP(&amp;opts.platform, "artifact-platform", "", "", "[Experimental] "+opts.FlagDescription+" in the form of `os[/arch][/variant][:os_version]`")
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import (
        "io"

        "github.com/spf13/pflag"
        "oras.land/oras/cmd/oras/internal/output"
)

// Pretty option struct.
type Pretty struct {
        Pretty bool
}

// ApplyFlags applies flags to a command flag set.
func (opts *Pretty) ApplyFlags(fs *pflag.FlagSet) <span class="cov1" title="1">{
        fs.BoolVarP(&amp;opts.Pretty, "pretty", "", false, "prettify JSON objects printed to stdout")
}</span>

// Output outputs the prettified content if `--pretty` flag is used. Otherwise
// outputs the original content.
func (opts *Pretty) Output(w io.Writer, content []byte) error <span class="cov10" title="2">{
        return output.PrintJSON(w, content, opts.Pretty)
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import (
        "context"
        "crypto/tls"
        "errors"
        "fmt"
        "io"
        "net"
        "net/http"
        "os"
        "strconv"
        "strings"
        "sync"

        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "oras.land/oras-go/v2/errdef"
        "oras.land/oras-go/v2/registry/remote"
        "oras.land/oras-go/v2/registry/remote/auth"
        "oras.land/oras-go/v2/registry/remote/credentials"
        "oras.land/oras-go/v2/registry/remote/errcode"
        "oras.land/oras-go/v2/registry/remote/retry"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/internal/credential"
        "oras.land/oras/internal/crypto"
        onet "oras.land/oras/internal/net"
        "oras.land/oras/internal/trace"
        "oras.land/oras/internal/version"
)

const (
        caFileFlag                 = "ca-file"
        certFileFlag               = "cert-file"
        keyFileFlag                = "key-file"
        usernameFlag               = "username"
        passwordFlag               = "password"
        passwordFromStdinFlag      = "password-stdin"
        identityTokenFlag          = "identity-token"
        identityTokenFromStdinFlag = "identity-token-stdin"
)

// Remote options struct contains flags and arguments specifying one registry.
// Remote implements oerrors.Handler and interface.
type Remote struct {
        DistributionSpec
        CACertFilePath  string
        CertFilePath    string
        KeyFilePath     string
        Insecure        bool
        Configs         []string
        Username        string
        secretFromStdin bool
        Secret          string
        flagPrefix      string

        resolveFlag           []string
        applyDistributionSpec bool
        headerFlags           []string
        headers               http.Header
        warned                map[string]*sync.Map
        plainHTTP             func() (plainHTTP bool, enforced bool)
        store                 credentials.Store
}

// EnableDistributionSpecFlag set distribution specification flag as applicable.
func (remo *Remote) EnableDistributionSpecFlag() <span class="cov0" title="0">{
        remo.applyDistributionSpec = true
}</span>

// ApplyFlags applies flags to a command flag set.
func (remo *Remote) ApplyFlags(fs *pflag.FlagSet) <span class="cov6" title="6">{
        remo.ApplyFlagsWithPrefix(fs, "", "")
        fs.BoolVar(&amp;remo.secretFromStdin, passwordFromStdinFlag, false, "read password from stdin")
        fs.BoolVar(&amp;remo.secretFromStdin, identityTokenFromStdinFlag, false, "read identity token from stdin")
}</span>

func applyPrefix(prefix, description string) (flagPrefix, notePrefix string) <span class="cov6" title="7">{
        if prefix == "" </span><span class="cov6" title="7">{
                return "", ""
        }</span>
        <span class="cov0" title="0">return prefix + "-", description + " "</span>
}

// ApplyFlagsWithPrefix applies flags to a command flag set with a prefix string.
// Commonly used for non-unary remote targets.
func (remo *Remote) ApplyFlagsWithPrefix(fs *pflag.FlagSet, prefix, description string) <span class="cov6" title="6">{
        var (
                shortUser     string
                shortPassword string
                shortHeader   string
                notePrefix    string
        )
        if prefix == "" </span><span class="cov6" title="6">{
                shortUser, shortPassword = "u", "p"
                shortHeader = "H"
        }</span>
        <span class="cov6" title="6">remo.flagPrefix, notePrefix = applyPrefix(prefix, description)

        if remo.applyDistributionSpec </span><span class="cov0" title="0">{
                remo.DistributionSpec.ApplyFlagsWithPrefix(fs, prefix, description)
        }</span>
        <span class="cov6" title="6">fs.StringVarP(&amp;remo.Username, remo.flagPrefix+usernameFlag, shortUser, "", notePrefix+"registry username")
        fs.StringVarP(&amp;remo.Secret, remo.flagPrefix+passwordFlag, shortPassword, "", notePrefix+"registry password or identity token")
        fs.StringVar(&amp;remo.Secret, remo.flagPrefix+identityTokenFlag, "", notePrefix+"registry identity token")
        fs.BoolVar(&amp;remo.Insecure, remo.flagPrefix+"insecure", false, "allow connections to "+notePrefix+"SSL registry without certs")
        plainHTTPFlagName := remo.flagPrefix + "plain-http"
        plainHTTP := fs.Bool(plainHTTPFlagName, false, "allow insecure connections to "+notePrefix+"registry without SSL check")
        remo.plainHTTP = func() (bool, bool) </span><span class="cov0" title="0">{
                return *plainHTTP, fs.Changed(plainHTTPFlagName)
        }</span>
        <span class="cov6" title="6">fs.StringVar(&amp;remo.CACertFilePath, remo.flagPrefix+caFileFlag, "", "server certificate authority file for the remote "+notePrefix+"registry")
        fs.StringVarP(&amp;remo.CertFilePath, remo.flagPrefix+certFileFlag, "", "", "client certificate file for the remote "+notePrefix+"registry")
        fs.StringVarP(&amp;remo.KeyFilePath, remo.flagPrefix+keyFileFlag, "", "", "client private key file for the remote "+notePrefix+"registry")
        fs.StringArrayVar(&amp;remo.resolveFlag, remo.flagPrefix+"resolve", nil, "customized DNS for "+notePrefix+"registry, formatted in `host:port:address[:address_port]`")
        fs.StringArrayVar(&amp;remo.Configs, remo.flagPrefix+"registry-config", nil, "`path` of the authentication file for "+notePrefix+"registry")
        fs.StringArrayVarP(&amp;remo.headerFlags, remo.flagPrefix+"header", shortHeader, nil, "add custom headers to "+notePrefix+"requests")</span>
}

// CheckStdinConflict checks if PasswordFromStdin or IdentityTokenFromStdin of a
// *pflag.FlagSet conflicts with read file from input.
func CheckStdinConflict(flags *pflag.FlagSet) error <span class="cov0" title="0">{
        switch </span>{
        case flags.Changed(passwordFromStdinFlag):<span class="cov0" title="0">
                return fmt.Errorf("`-` read file from input and `--%s` read password from input cannot be both used", passwordFromStdinFlag)</span>
        case flags.Changed(identityTokenFromStdinFlag):<span class="cov0" title="0">
                return fmt.Errorf("`-` read file from input and `--%s` read identity token from input cannot be both used", identityTokenFromStdinFlag)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Parse tries to read password with optional cmd prompt.
func (remo *Remote) Parse(cmd *cobra.Command) error <span class="cov1" title="1">{
        usernameAndIdTokenFlags := []string{remo.flagPrefix + usernameFlag, remo.flagPrefix + identityTokenFlag}
        passwordAndIdTokenFlags := []string{remo.flagPrefix + passwordFlag, remo.flagPrefix + identityTokenFlag}
        certFileAndKeyFileFlags := []string{remo.flagPrefix + certFileFlag, remo.flagPrefix + keyFileFlag}
        if cmd.Flags().Lookup(identityTokenFromStdinFlag) != nil </span><span class="cov1" title="1">{
                usernameAndIdTokenFlags = append(usernameAndIdTokenFlags, identityTokenFromStdinFlag)
                passwordAndIdTokenFlags = append(passwordAndIdTokenFlags, identityTokenFromStdinFlag)
        }</span>
        <span class="cov1" title="1">if cmd.Flags().Lookup(passwordFromStdinFlag) != nil </span><span class="cov1" title="1">{
                passwordAndIdTokenFlags = append(passwordAndIdTokenFlags, passwordFromStdinFlag)
        }</span>
        <span class="cov1" title="1">if err := oerrors.CheckMutuallyExclusiveFlags(cmd.Flags(), usernameAndIdTokenFlags...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := oerrors.CheckMutuallyExclusiveFlags(cmd.Flags(), passwordAndIdTokenFlags...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := remo.parseCustomHeaders(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := oerrors.CheckRequiredTogetherFlags(cmd.Flags(), certFileAndKeyFileFlags...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return remo.readSecret(cmd)</span>
}

// readSecret tries to read password or identity token with
// optional cmd prompt.
func (remo *Remote) readSecret(cmd *cobra.Command) (err error) <span class="cov1" title="1">{
        if cmd.Flags().Changed(identityTokenFlag) </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(cmd.ErrOrStderr(), "WARNING! Using --identity-token via the CLI is insecure. Use --identity-token-stdin.")
        }</span> else<span class="cov1" title="1"> if cmd.Flags().Changed(passwordFlag) </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(cmd.ErrOrStderr(), "WARNING! Using --password via the CLI is insecure. Use --password-stdin.")
        }</span> else<span class="cov1" title="1"> if remo.secretFromStdin </span><span class="cov0" title="0">{
                // Prompt for credential
                secret, err := io.ReadAll(os.Stdin)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">remo.Secret = strings.TrimSuffix(string(secret), "\n")
                remo.Secret = strings.TrimSuffix(remo.Secret, "\r")</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// parseResolve parses resolve flag.
func (remo *Remote) parseResolve(baseDial onet.DialFunc) (onet.DialFunc, error) <span class="cov9" title="18">{
        if len(remo.resolveFlag) == 0 </span><span class="cov6" title="7">{
                return baseDial, nil
        }</span>

        <span class="cov8" title="11">formatError := func(param, message string) error </span><span class="cov7" title="8">{
                return fmt.Errorf("failed to parse resolve flag %q: %s", param, message)
        }</span>
        <span class="cov8" title="11">var dialer onet.Dialer
        for _, r := range remo.resolveFlag </span><span class="cov8" title="11">{
                parts := strings.SplitN(r, ":", 4)
                length := len(parts)
                if length &lt; 3 </span><span class="cov1" title="1">{
                        return nil, formatError(r, "expecting host:port:address[:address_port]")
                }</span>
                <span class="cov8" title="10">host := parts[0]
                hostPort, err := strconv.Atoi(parts[1])
                if err != nil </span><span class="cov6" title="6">{
                        return nil, formatError(r, "expecting uint64 host port")
                }</span>
                // ipv6 zone is not parsed
                <span class="cov5" title="4">address := net.ParseIP(parts[2])
                if address == nil </span><span class="cov1" title="1">{
                        return nil, formatError(r, "invalid IP address")
                }</span>
                <span class="cov4" title="3">addressPort := hostPort
                if length &gt; 3 </span><span class="cov1" title="1">{
                        addressPort, err = strconv.Atoi(parts[3])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, formatError(r, "expecting uint64 address port")
                        }</span>
                }
                <span class="cov4" title="3">dialer.Add(host, hostPort, address, addressPort)</span>
        }
        <span class="cov4" title="3">dialer.BaseDialContext = baseDial
        return dialer.DialContext, nil</span>
}

// tlsConfig assembles the tls config.
func (remo *Remote) tlsConfig() (*tls.Config, error) <span class="cov7" title="8">{
        config := &amp;tls.Config{
                InsecureSkipVerify: remo.Insecure,
        }
        if remo.CACertFilePath != "" </span><span class="cov5" title="5">{
                var err error
                config.RootCAs, err = crypto.LoadCertPool(remo.CACertFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov7" title="8">if remo.CertFilePath != "" &amp;&amp; remo.KeyFilePath != "" </span><span class="cov1" title="1">{
                cert, err := tls.LoadX509KeyPair(remo.CertFilePath, remo.KeyFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">config.Certificates = []tls.Certificate{cert}</span>
        }
        <span class="cov7" title="8">return config, nil</span>
}

// authClient assembles a oras auth client.
func (remo *Remote) authClient(registry string, debug bool) (client *auth.Client, err error) <span class="cov7" title="8">{
        config, err := remo.tlsConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="8">baseTransport := http.DefaultTransport.(*http.Transport).Clone()
        baseTransport.TLSClientConfig = config
        dialContext, err := remo.parseResolve(baseTransport.DialContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="8">baseTransport.DialContext = dialContext
        client = &amp;auth.Client{
                Client: &amp;http.Client{
                        // http.RoundTripper with a retry using the DefaultPolicy
                        // see: https://pkg.go.dev/oras.land/oras-go/v2/registry/remote/retry#Policy
                        Transport: retry.NewTransport(baseTransport),
                },
                Cache:  auth.NewCache(),
                Header: remo.headers,
        }
        client.SetUserAgent("oras/" + version.GetVersion())
        if debug </span><span class="cov0" title="0">{
                client.Client.Transport = trace.NewTransport(client.Client.Transport)
        }</span>

        <span class="cov7" title="8">cred := remo.Credential()
        if cred != auth.EmptyCredential </span><span class="cov1" title="1">{
                client.Credential = func(ctx context.Context, s string) (auth.Credential, error) </span><span class="cov1" title="1">{
                        return cred, nil
                }</span>
        } else<span class="cov6" title="7"> {
                var err error
                remo.store, err = credential.NewStore(remo.Configs...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov6" title="7">client.Credential = credentials.Credential(remo.store)</span>
        }
        <span class="cov7" title="8">return</span>
}

// ConfigPath returns the config path of the credential store.
func (remo *Remote) ConfigPath() (string, error) <span class="cov0" title="0">{
        if remo.store == nil </span><span class="cov0" title="0">{
                return "", errors.New("no credential store initialized")
        }</span>
        <span class="cov0" title="0">if ds, ok := remo.store.(*credentials.DynamicStore); ok </span><span class="cov0" title="0">{
                return ds.ConfigPath(), nil
        }</span>
        <span class="cov0" title="0">return "", errors.New("store doesn't support getting config path")</span>
}

func (remo *Remote) parseCustomHeaders() error <span class="cov9" title="14">{
        if len(remo.headerFlags) != 0 </span><span class="cov8" title="12">{
                headers := map[string][]string{}
                for _, h := range remo.headerFlags </span><span class="cov10" title="19">{
                        name, value, found := strings.Cut(h, ":")
                        if !found || strings.TrimSpace(name) == "" </span><span class="cov4" title="3">{
                                // In conformance to the RFC 2616 specification
                                // Reference: https://www.rfc-editor.org/rfc/rfc2616#section-4.2
                                return fmt.Errorf("invalid header: %q", h)
                        }</span>
                        <span class="cov9" title="16">headers[name] = append(headers[name], value)</span>
                }
                <span class="cov7" title="9">remo.headers = headers</span>
        }
        <span class="cov8" title="11">return nil</span>
}

// Credential returns a credential based on the remote options.
func (remo *Remote) Credential() auth.Credential <span class="cov7" title="8">{
        return credential.Credential(remo.Username, remo.Secret)
}</span>

func (remo *Remote) handleWarning(registry string, logger logrus.FieldLogger) func(warning remote.Warning) <span class="cov5" title="4">{
        if remo.warned == nil </span><span class="cov5" title="4">{
                remo.warned = make(map[string]*sync.Map)
        }</span>
        <span class="cov5" title="4">warned := remo.warned[registry]
        if warned == nil </span><span class="cov5" title="4">{
                warned = &amp;sync.Map{}
                remo.warned[registry] = warned
        }</span>
        <span class="cov5" title="4">logger = logger.WithField("registry", registry)
        return func(warning remote.Warning) </span><span class="cov0" title="0">{
                if _, loaded := warned.LoadOrStore(warning.WarningValue, struct{}{}); !loaded </span><span class="cov0" title="0">{
                        logger.Warn(warning.Text)
                }</span>
        }
}

// NewRegistry assembles a oras remote registry.
func (remo *Remote) NewRegistry(registry string, common Common, logger logrus.FieldLogger) (reg *remote.Registry, err error) <span class="cov1" title="1">{
        reg, err = remote.NewRegistry(registry)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">registry = reg.Reference.Registry
        reg.PlainHTTP = remo.isPlainHttp(registry)
        reg.HandleWarning = remo.handleWarning(registry, logger)
        if reg.Client, err = remo.authClient(registry, common.Debug); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return</span>
}

// NewRepository assembles a oras remote repository.
func (remo *Remote) NewRepository(reference string, common Common, logger logrus.FieldLogger) (repo *remote.Repository, err error) <span class="cov4" title="3">{
        repo, err = remote.NewRepository(reference)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Unwrap(err) == errdef.ErrInvalidReference </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%q: %v", reference, err)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov4" title="3">registry := repo.Reference.Registry
        repo.PlainHTTP = remo.isPlainHttp(registry)
        repo.HandleWarning = remo.handleWarning(registry, logger)
        if repo.Client, err = remo.authClient(registry, common.Debug); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="3">repo.SkipReferrersGC = true
        if remo.ReferrersAPI != nil </span><span class="cov0" title="0">{
                if err := repo.SetReferrersCapability(*remo.ReferrersAPI); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov4" title="3">return</span>
}

// isPlainHttp returns the plain http flag for a given registry.
func (remo *Remote) isPlainHttp(registry string) bool <span class="cov8" title="10">{
        plainHTTP, enforced := remo.plainHTTP()
        if enforced </span><span class="cov5" title="4">{
                return plainHTTP
        }</span>
        <span class="cov6" title="6">host, _, _ := net.SplitHostPort(registry)
        if host == "localhost" || registry == "localhost" </span><span class="cov3" title="2">{
                // not specified, defaults to plain http for localhost
                return true
        }</span>
        <span class="cov5" title="4">return plainHTTP</span>
}

// Modify modifies error during cmd execution.
func (remo *Remote) Modify(cmd *cobra.Command, err error) (error, bool) <span class="cov0" title="0">{
        var errResp *errcode.ErrorResponse

        if errors.Is(err, auth.ErrBasicCredentialNotFound) </span><span class="cov0" title="0">{
                return remo.DecorateCredentialError(err), true
        }</span>

        <span class="cov0" title="0">if errors.As(err, &amp;errResp) </span><span class="cov0" title="0">{
                cmd.SetErrPrefix(oerrors.RegistryErrorPrefix)
                return &amp;oerrors.Error{
                        Err: oerrors.TrimErrResp(err, errResp),
                }, true
        }</span>
        <span class="cov0" title="0">return err, false</span>
}

// DecorateCredentialError decorate error with recommendation.
func (remo *Remote) DecorateCredentialError(err error) *oerrors.Error <span class="cov0" title="0">{
        configPath := " "
        if path, pathErr := remo.ConfigPath(); pathErr == nil </span><span class="cov0" title="0">{
                configPath += fmt.Sprintf("at %q ", path)
        }</span>
        <span class="cov0" title="0">return &amp;oerrors.Error{
                Err:            oerrors.TrimErrBasicCredentialNotFound(err),
                Recommendation: fmt.Sprintf(`Please check whether the registry credential stored in the authentication file%sis correct`, configPath),
        }</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import (
        "fmt"
        "strings"

        "github.com/spf13/pflag"
        "oras.land/oras-go/v2"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
)

const (
        ImageSpecV1_1 = "v1.1"
        ImageSpecV1_0 = "v1.0"
)

const (
        DistributionSpecReferrersTagV1_1 = "v1.1-referrers-tag"
        DistributionSpecReferrersAPIV1_1 = "v1.1-referrers-api"
)

// ImageSpec option struct which implements pflag.Value interface.
type ImageSpec struct {
        Flag        string
        PackVersion oras.PackManifestVersion
}

// Set validates and sets the flag value from a string argument.
func (is *ImageSpec) Set(value string) error <span class="cov0" title="0">{
        is.Flag = value
        switch value </span>{
        case ImageSpecV1_1:<span class="cov0" title="0">
                is.PackVersion = oras.PackManifestVersion1_1</span>
        case ImageSpecV1_0:<span class="cov0" title="0">
                is.PackVersion = oras.PackManifestVersion1_0</span>
        default:<span class="cov0" title="0">
                return &amp;oerrors.Error{
                        Err:            fmt.Errorf("unknown image specification flag: %s", value),
                        Recommendation: fmt.Sprintf("Available options: %s", is.Options()),
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Type returns the string value of the inner flag.
func (is *ImageSpec) Type() string <span class="cov0" title="0">{
        return "string"
}</span>

// Options returns the string of usable options for the flag.
func (is *ImageSpec) Options() string <span class="cov0" title="0">{
        return strings.Join([]string{
                ImageSpecV1_1,
                ImageSpecV1_0,
        }, ", ")
}</span>

// String returns the string representation of the flag.
func (is *ImageSpec) String() string <span class="cov0" title="0">{
        // to avoid printing default value in usage doc
        return ""
}</span>

// ApplyFlags applies flags to a command flag set.
func (is *ImageSpec) ApplyFlags(fs *pflag.FlagSet) <span class="cov0" title="0">{
        // default to v1.1, unless --config is used and --artifact-type is not used
        is.PackVersion = oras.PackManifestVersion1_1
        is.Flag = ImageSpecV1_1
        fs.Var(is, "image-spec", `[Preview] specify manifest type for building artifact. Options: v1.1, v1.0 (default v1.1, overridden to v1.0 if --config is used without --artifact-type)`)
}</span>

// DistributionSpec option struct which implements pflag.Value interface.
type DistributionSpec struct {
        // ReferrersAPI indicates the preference of the implementation of the Referrers API.
        // Set to true for referrers API, false for referrers tag scheme, and nil for auto fallback.
        ReferrersAPI *bool

        // specFlag should be provided in form of`&lt;version&gt;-&lt;api&gt;-&lt;option&gt;`
        flag string
}

// Set validates and sets the flag value from a string argument.
func (ds *DistributionSpec) Set(value string) error <span class="cov0" title="0">{
        ds.flag = value
        switch ds.flag </span>{
        case DistributionSpecReferrersTagV1_1:<span class="cov0" title="0">
                isApi := false
                ds.ReferrersAPI = &amp;isApi</span>
        case DistributionSpecReferrersAPIV1_1:<span class="cov0" title="0">
                isApi := true
                ds.ReferrersAPI = &amp;isApi</span>
        default:<span class="cov0" title="0">
                return &amp;oerrors.Error{
                        Err:            fmt.Errorf("unknown distribution specification flag: %s", value),
                        Recommendation: fmt.Sprintf("Available options: %s", ds.Options()),
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Type returns the string value of the inner flag.
func (ds *DistributionSpec) Type() string <span class="cov0" title="0">{
        return "string"
}</span>

// Options returns the string of usable options for the flag.
func (ds *DistributionSpec) Options() string <span class="cov0" title="0">{
        return strings.Join([]string{
                DistributionSpecReferrersTagV1_1,
                DistributionSpecReferrersAPIV1_1,
        }, ", ")
}</span>

// String returns the string representation of the flag.
func (ds *DistributionSpec) String() string <span class="cov0" title="0">{
        return ds.flag
}</span>

// ApplyFlagsWithPrefix applies flags to a command flag set with a prefix string.
func (ds *DistributionSpec) ApplyFlagsWithPrefix(fs *pflag.FlagSet, prefix, description string) <span class="cov0" title="0">{
        flagPrefix, notePrefix := applyPrefix(prefix, description)
        fs.Var(ds, flagPrefix+"distribution-spec", fmt.Sprintf("[Preview] set OCI distribution spec version and API option for %starget. Options: %s", notePrefix, ds.Options()))
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import (
        "context"
        "errors"
        "fmt"
        "io"
        "io/fs"
        "net/http"
        "os"
        "strings"

        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"

        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/content/oci"
        "oras.land/oras-go/v2/errdef"
        "oras.land/oras-go/v2/registry"
        "oras.land/oras-go/v2/registry/remote"
        "oras.land/oras-go/v2/registry/remote/auth"
        "oras.land/oras-go/v2/registry/remote/errcode"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/fileref"
)

const (
        TargetTypeRemote    = "registry"
        TargetTypeOCILayout = "oci-layout"
)

// Target struct contains flags and arguments specifying one registry or image
// layout.
// Target implements oerrors.Handler interface.
type Target struct {
        Remote
        RawReference string
        Type         string
        Reference    string //contains tag or digest
        // Path contains
        //  - path to the OCI image layout target, or
        //  - registry and repository for the remote target
        Path string

        IsOCILayout bool
}

// ApplyFlags applies flags to a command flag set for unary target
func (target *Target) ApplyFlags(fs *pflag.FlagSet) <span class="cov1" title="1">{
        target.applyFlagsWithPrefix(fs, "", "")
        target.Remote.ApplyFlags(fs)
}</span>

// GetDisplayReference returns full printable reference.
func (target *Target) GetDisplayReference() string <span class="cov0" title="0">{
        return fmt.Sprintf("[%s] %s", target.Type, target.RawReference)
}</span>

// applyFlagsWithPrefix applies flags to fs with prefix and description.
// The complete form of the `target` flag is designed to be
//
//        --target type=&lt;type&gt;[[,&lt;key&gt;=&lt;value&gt;][...]]
//
// For better UX, the boolean flag `--oci-layout` is introduced as an alias of
// `--target type=oci-layout`.
// Since there is only one target type besides the default `registry` type,
// the full form is not implemented until a new type comes in.
func (target *Target) applyFlagsWithPrefix(fs *pflag.FlagSet, prefix, description string) <span class="cov1" title="1">{
        flagPrefix, notePrefix := applyPrefix(prefix, description)
        fs.BoolVarP(&amp;target.IsOCILayout, flagPrefix+"oci-layout", "", false, "set "+notePrefix+"target as an OCI image layout")
        fs.StringVar(&amp;target.Path, flagPrefix+"oci-layout-path", "", "[Experimental] set the path for the "+notePrefix+"OCI image layout target")
}</span>

// ApplyFlagsWithPrefix applies flags to a command flag set with a prefix string.
// Commonly used for non-unary remote targets.
func (target *Target) ApplyFlagsWithPrefix(fs *pflag.FlagSet, prefix, description string) <span class="cov0" title="0">{
        target.applyFlagsWithPrefix(fs, prefix, description)
        target.Remote.ApplyFlagsWithPrefix(fs, prefix, description)
}</span>

// Parse gets target options from user input.
func (target *Target) Parse(cmd *cobra.Command) error <span class="cov7" title="5">{
        if err := oerrors.CheckMutuallyExclusiveFlags(cmd.Flags(), target.flagPrefix+"oci-layout-path", target.flagPrefix+"oci-layout"); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="4">switch </span>{
        case target.IsOCILayout:<span class="cov1" title="1">
                target.Type = TargetTypeOCILayout
                if len(target.headerFlags) != 0 </span><span class="cov0" title="0">{
                        return errors.New("custom header flags cannot be used on an OCI image layout target")
                }</span>
                <span class="cov1" title="1">return target.parseOCILayoutReference()</span>
        case target.Path != "":<span class="cov1" title="1">
                target.Type = TargetTypeOCILayout
                target.Reference = target.RawReference
                return nil</span>
        default:<span class="cov4" title="2">
                target.Type = TargetTypeRemote
                if ref, err := registry.ParseReference(target.RawReference); err != nil </span><span class="cov1" title="1">{
                        return &amp;oerrors.Error{
                                OperationType:  oerrors.OperationTypeParseArtifactReference,
                                Err:            fmt.Errorf("%q: %w", target.RawReference, err),
                                Recommendation: "Please make sure the provided reference is in the form of &lt;registry&gt;/&lt;repo&gt;[:tag|@digest]",
                        }
                }</span> else<span class="cov1" title="1"> {
                        target.Reference = ref.Reference
                        ref.Reference = ""
                        target.Path = ref.String()
                }</span>
                <span class="cov1" title="1">return target.Remote.Parse(cmd)</span>
        }
}

// parseOCILayoutReference parses the raw in format of &lt;path&gt;[:&lt;tag&gt;|@&lt;digest&gt;]
func (target *Target) parseOCILayoutReference() error <span class="cov10" title="8">{
        raw := target.RawReference
        var path string
        var ref string
        if idx := strings.LastIndex(raw, "@"); idx != -1 </span><span class="cov5" title="3">{
                // `digest` found
                path = raw[:idx]
                ref = raw[idx+1:]
        }</span> else<span class="cov7" title="5"> {
                // find `tag`
                var err error
                path, ref, err = fileref.Parse(raw, "")
                if err != nil </span><span class="cov5" title="3">{
                        return errors.Join(err, errdef.ErrInvalidReference)
                }</span>
        }
        <span class="cov7" title="5">target.Path = path
        target.Reference = ref
        return nil</span>
}

func (target *Target) newOCIStore() (*oci.Store, error) <span class="cov0" title="0">{
        return oci.New(target.Path)
}</span>

func (target *Target) newRepository(common Common, logger logrus.FieldLogger) (*remote.Repository, error) <span class="cov0" title="0">{
        return target.NewRepository(target.RawReference, common, logger)
}</span>

// NewTarget generates a new target based on target.
func (target *Target) NewTarget(common Common, logger logrus.FieldLogger) (oras.GraphTarget, error) <span class="cov0" title="0">{
        switch target.Type </span>{
        case TargetTypeOCILayout:<span class="cov0" title="0">
                return target.newOCIStore()</span>
        case TargetTypeRemote:<span class="cov0" title="0">
                return target.newRepository(common, logger)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown target type: %q", target.Type)</span>
}

// NewBlobDeleter generates a new blob deleter based on target.
func (target *Target) NewBlobDeleter(common Common, logger logrus.FieldLogger) (ResolvableDeleter, error) <span class="cov0" title="0">{
        switch target.Type </span>{
        case TargetTypeOCILayout:<span class="cov0" title="0">
                return target.newOCIStore()</span>
        case TargetTypeRemote:<span class="cov0" title="0">
                repo, err := target.newRepository(common, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return repo.Blobs(), nil</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown target type: %q", target.Type)</span>
}

// NewManifestDeleter generates a new blob deleter based on target.
func (target *Target) NewManifestDeleter(common Common, logger logrus.FieldLogger) (ResolvableDeleter, error) <span class="cov0" title="0">{
        switch target.Type </span>{
        case TargetTypeOCILayout:<span class="cov0" title="0">
                return target.newOCIStore()</span>
        case TargetTypeRemote:<span class="cov0" title="0">
                repo, err := target.newRepository(common, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return repo.Manifests(), nil</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown target type: %q", target.Type)</span>
}

// NewReadonlyTarget generates a new read only target based on target.
func (target *Target) NewReadonlyTarget(ctx context.Context, common Common, logger logrus.FieldLogger) (ReadOnlyGraphTagFinderTarget, error) <span class="cov0" title="0">{
        switch target.Type </span>{
        case TargetTypeOCILayout:<span class="cov0" title="0">
                info, err := os.Stat(target.Path)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, fs.ErrNotExist) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid argument %q: failed to find path %q: %w", target.RawReference, target.Path, err)
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return oci.NewFromFS(ctx, os.DirFS(target.Path))
                }</span>
                <span class="cov0" title="0">store, err := oci.NewFromTar(ctx, target.Path)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, io.ErrUnexpectedEOF) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("%q does not look like a tar archive: %w", target.Path, err)
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov0" title="0">return store, nil</span>
        case TargetTypeRemote:<span class="cov0" title="0">
                return target.NewRepository(target.RawReference, common, logger)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown target type: %q", target.Type)</span>
}

// EnsureReferenceNotEmpty returns formalized error when the reference is empty.
func (target *Target) EnsureReferenceNotEmpty(cmd *cobra.Command, allowTag bool) error <span class="cov0" title="0">{
        if target.Reference == "" </span><span class="cov0" title="0">{
                return oerrors.NewErrEmptyTagOrDigest(target.RawReference, cmd, allowTag)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Modify handles error during cmd execution.
func (target *Target) Modify(cmd *cobra.Command, err error) (error, bool) <span class="cov9" title="7">{
        if target.IsOCILayout </span><span class="cov0" title="0">{
                return err, false
        }</span>

        <span class="cov9" title="7">if errors.Is(err, auth.ErrBasicCredentialNotFound) </span><span class="cov0" title="0">{
                return target.DecorateCredentialError(err), true
        }</span>

        <span class="cov9" title="7">if errors.Is(err, errdef.ErrNotFound) </span><span class="cov0" title="0">{
                cmd.SetErrPrefix(oerrors.RegistryErrorPrefix)
                return err, true
        }</span>

        <span class="cov9" title="7">var errResp *errcode.ErrorResponse
        if errors.As(err, &amp;errResp) </span><span class="cov8" title="6">{
                ref := registry.Reference{Registry: target.RawReference}
                if errResp.URL.Host != ref.Host() </span><span class="cov7" title="4">{
                        // raw reference is not registry host
                        var parseErr error
                        ref, parseErr = registry.ParseReference(target.RawReference)
                        if parseErr != nil </span><span class="cov1" title="1">{
                                // this should not happen
                                return err, false
                        }</span>
                        <span class="cov5" title="3">if errResp.URL.Host != ref.Host() </span><span class="cov1" title="1">{
                                // not handle if the error is not from the target
                                return err, false
                        }</span>
                }

                <span class="cov7" title="4">cmd.SetErrPrefix(oerrors.RegistryErrorPrefix)
                ret := &amp;oerrors.Error{
                        Err: oerrors.TrimErrResp(err, errResp),
                }

                if ref.Registry == "docker.io" &amp;&amp; errResp.StatusCode == http.StatusUnauthorized </span><span class="cov5" title="3">{
                        if ref.Repository != "" &amp;&amp; !strings.Contains(ref.Repository, "/") </span><span class="cov1" title="1">{
                                // docker.io/xxx -&gt; docker.io/library/xxx
                                ref.Repository = "library/" + ref.Repository
                                ret.Recommendation = fmt.Sprintf("Namespace seems missing. Do you mean `%s %s`?", cmd.CommandPath(), ref)
                        }</span>
                }
                <span class="cov7" title="4">return ret, true</span>
        }
        <span class="cov1" title="1">return err, false</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import (
        "os"

        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "golang.org/x/term"
)

const NoTTYFlag = "no-tty"

// Terminal option struct.
type Terminal struct {
        TTY *os.File

        noTTY       bool
        ttyEnforced bool
}

// ApplyFlags applies flags to a command flag set.
func (opts *Terminal) ApplyFlags(fs *pflag.FlagSet) <span class="cov0" title="0">{
        fs.BoolVarP(&amp;opts.noTTY, NoTTYFlag, "", false, "[Preview] disable progress bars")
}</span>

// Parse parses the input notty flag.
func (opts *Terminal) Parse(cmd *cobra.Command) error <span class="cov1" title="1">{
        opts.ttyEnforced = cmd.Flags().Changed(NoTTYFlag) &amp;&amp; !opts.noTTY
        // use STDERR as TTY output since STDOUT is reserved for pipeable output
        if !opts.noTTY </span><span class="cov1" title="1">{
                f := os.Stderr
                if term.IsTerminal(int(f.Fd())) </span><span class="cov0" title="0">{
                        opts.TTY = f
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// DisableTTY updates the TTY value, given the status of --debug flag, --no-tty flag and output
// path value.TTY value is set to nil if
// 1. --no-tty flag is set to true
// 2. --debug flag is used
// 3. output path is set to stdout and --no-tty flag is not explicitly set to false
// (i.e. not --no-tty=false)
func (opts *Terminal) DisableTTY(debugEnabled, toSTDOUT bool) <span class="cov10" title="7">{
        if debugEnabled || opts.noTTY || (toSTDOUT &amp;&amp; !opts.ttyEnforced) </span><span class="cov7" title="4">{
                opts.TTY = nil
        }</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package option

import "github.com/spf13/pflag"

// AddDeprecatedVerboseFlag adds the deprecated verbose flag to a command
func AddDeprecatedVerboseFlag(flags *pflag.FlagSet) <span class="cov0" title="0">{
        // ignoring the variable of the verbose flag, since we will not use it
        _ = flags.BoolP("verbose", "v", false, "verbose output")
        _ = flags.MarkDeprecated("verbose", "and will be removed in a future release.")
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package output

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
)

// PrintPrettyJSON prints the object to the writer in JSON format.
func PrintPrettyJSON(out io.Writer, object any) error <span class="cov5" title="2">{
        encoder := json.NewEncoder(out)
        encoder.SetIndent("", "  ")
        return encoder.Encode(object)
}</span>

// PrintJSON writes the data to the output stream, optionally prettifying it.
func PrintJSON(out io.Writer, data []byte, pretty bool) error <span class="cov10" title="4">{
        if pretty </span><span class="cov5" title="2">{
                buf := bytes.NewBuffer(nil)
                if err := json.Indent(buf, data, "", "  "); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to prettify: %w", err)
                }</span>
                <span class="cov5" title="2">buf.WriteByte('\n')
                data = buf.Bytes()</span>
        }
        <span class="cov10" title="4">_, err := out.Write(data)
        return err</span>
}

// ToMap converts the data to a map[string]any with json tag as key.
func ToMap(data any) (map[string]any, error) <span class="cov8" title="3">{
        // slow but easy
        content, err := json.Marshal(data)
        if err != nil </span><span class="cov5" title="2">{
                return nil, err
        }</span>
        <span class="cov1" title="1">var ret map[string]any
        if err = json.Unmarshal(content, &amp;ret); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package output

import (
        "fmt"
        "io"
        "sync"

        "oras.land/oras/internal/descriptor"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
)

// Printer prints for status handlers.
type Printer struct {
        Verbose bool

        out  io.Writer
        err  io.Writer
        lock sync.Mutex
}

// NewPrinter creates a new Printer.
func NewPrinter(out io.Writer, err io.Writer) *Printer <span class="cov8" title="14">{
        return &amp;Printer{out: out, err: err}
}</span>

// Write implements the io.Writer interface.
func (p *Printer) Write(b []byte) (int, error) <span class="cov0" title="0">{
        p.lock.Lock()
        defer p.lock.Unlock()
        return p.out.Write(b)
}</span>

// Println prints objects concurrent-safely with newline.
func (p *Printer) Println(a ...any) error <span class="cov10" title="26">{
        p.lock.Lock()
        defer p.lock.Unlock()
        _, err := fmt.Fprintln(p.out, a...)
        if err != nil </span><span class="cov2" title="2">{
                err = fmt.Errorf("display output error: %w", err)
                _, _ = fmt.Fprint(p.err, err)
                return err
        }</span>
        <span class="cov9" title="24">return nil</span>
}

// Printf prints objects concurrent-safely with newline.
func (p *Printer) Printf(format string, a ...any) error <span class="cov2" title="2">{
        p.lock.Lock()
        defer p.lock.Unlock()
        _, err := fmt.Fprintf(p.out, format, a...)
        if err != nil </span><span class="cov1" title="1">{
                err = fmt.Errorf("display output error: %w", err)
                _, _ = fmt.Fprint(p.err, err)
        }</span>
        // Errors are handled above, so return nil
        <span class="cov2" title="2">return nil</span>
}

// PrintVerbose prints when verbose is true.
func (p *Printer) PrintVerbose(a ...any) error <span class="cov4" title="4">{
        if !p.Verbose </span><span class="cov4" title="3">{
                return nil
        }</span>
        <span class="cov1" title="1">return p.Println(a...)</span>
}

// PrintStatus prints transfer status.
func (p *Printer) PrintStatus(desc ocispec.Descriptor, status string) error <span class="cov8" title="15">{
        name, isTitle := descriptor.GetTitleOrMediaType(desc)
        if !isTitle </span><span class="cov1" title="1">{
                return p.PrintVerbose(status, descriptor.ShortDigest(desc), name)
        }</span>
        <span class="cov8" title="14">return p.Println(status, descriptor.ShortDigest(desc), name)</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package output

import (
        "io"
        "text/template"

        "github.com/Masterminds/sprig/v3"
)

func ParseAndWrite(out io.Writer, object any, templateStr string) error <span class="cov8" title="1">{
        // parse template
        t, err := template.New("format output").Funcs(sprig.FuncMap()).Parse(templateStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // convert object to map[string]any
        <span class="cov8" title="1">converted, err := ToMap(object)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">return t.Execute(out, converted)</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "context"
        "os"
        "os/signal"

        "oras.land/oras/cmd/oras/root"
)

func run() error <span class="cov0" title="0">{
        ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
        defer cancel()
        return root.New().ExecuteContext(ctx)
}</span>

func main() <span class="cov0" title="0">{
        if err := run(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package root

import (
        "context"
        "errors"
        "fmt"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/spf13/cobra"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/content"
        "oras.land/oras-go/v2/content/file"
        "oras.land/oras-go/v2/registry/remote/auth"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        "oras.land/oras/cmd/oras/internal/display"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/internal/graph"
        "oras.land/oras/internal/registryutil"
)

type attachOptions struct {
        option.Common
        option.Packer
        option.Target
        option.Format
        option.Platform
        option.Terminal

        artifactType string
        concurrency  int
        // Deprecated: verbose is deprecated and will be removed in the future.
        verbose bool
}

func attachCmd() *cobra.Command <span class="cov0" title="0">{
        var opts attachOptions
        cmd := &amp;cobra.Command{
                Use:   "attach [flags] --artifact-type=&lt;type&gt; &lt;name&gt;{:&lt;tag&gt;|@&lt;digest&gt;} {&lt;file&gt;[:&lt;layer_media_type&gt;]|--annotation &lt;key&gt;=&lt;value&gt;} [...]",
                Short: "[Preview] Attach files to an existing artifact",
                Long: `[Preview] Attach files to an existing artifact

** This command is in preview and under development. **

Example - Attach file 'hi.txt' with artifact type 'doc/example' to manifest 'hello:v1' in registry 'localhost:5000':
  oras attach --artifact-type doc/example localhost:5000/hello:v1 hi.txt

Example - Attach file 'hi.txt' to a specific artifact with platform 'linux/amd64' in multi-arch index 'hello:v1'
  oras attach --artifact-type doc/example --platform linux/amd64 localhost:5000/hello:v1 hi.txt

Example - Push file "hi.txt" with the custom layer media type 'application/vnd.me.hi':
  oras attach --artifact-type doc/example localhost:5000/hello:v1 hi.txt:application/vnd.me.hi

Example - Attach file "hi.txt" using a specific method for the Referrers API:
  oras attach --artifact-type doc/example --distribution-spec v1.1-referrers-api localhost:5000/hello:v1 hi.txt # via API
  oras attach --artifact-type doc/example --distribution-spec v1.1-referrers-tag localhost:5000/hello:v1 hi.txt # via tag scheme

Example - Attach file 'hi.txt' and add annotations from file 'annotation.json':
  oras attach --artifact-type doc/example --annotation-file annotation.json localhost:5000/hello:v1 hi.txt

Example - Attach an artifact with manifest annotations:
  oras attach --artifact-type doc/example --annotation "key1=val1" --annotation "key2=val2" localhost:5000/hello:v1

Example - Attach file 'hi.txt' and add manifest annotations:
  oras attach --artifact-type doc/example --annotation "key=val" localhost:5000/hello:v1 hi.txt

Example - [Experimental] Attach file 'hi.txt' and format output in JSON:
  oras attach --artifact-type doc/example localhost:5000/hello:v1 hi.txt --format json

Example - [Experimental] Attach file 'hi.txt' and format output with Go template:
  oras attach --artifact-type doc/example localhost:5000/hello:v1 hi.txt --format go-template --template "{{.digest}}"

Example - Attach file 'hi.txt' and export the pushed manifest to 'manifest.json':
  oras attach --artifact-type doc/example --export-manifest manifest.json localhost:5000/hello:v1 hi.txt

Example - Attach file to the manifest tagged 'v1' in an OCI image layout folder 'layout-dir':
  oras attach --oci-layout --artifact-type doc/example layout-dir:v1 hi.txt

Example - Attach file to the manifest tagged 'example.com:v1' in an OCI image layout folder 'layout-dir':
  oras attach --artifact-type doc/example --oci-layout-path layout-dir example.com:v1 hi.txt
`,
                Args: oerrors.CheckArgs(argument.AtLeast(1), "the destination artifact for attaching."),
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        opts.RawReference = args[0]
                        opts.FileRefs = args[1:]
                        err := option.Parse(cmd, &amp;opts)
                        if err == nil </span><span class="cov0" title="0">{
                                opts.DisableTTY(opts.Debug, false)
                                if err = opts.EnsureReferenceNotEmpty(cmd, true); err == nil </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                        }
                        <span class="cov0" title="0">if len(opts.FileRefs) == 0 </span><span class="cov0" title="0">{
                                // no file argument provided
                                if err, ok := err.(*oerrors.Error); ok &amp;&amp; err.OperationType == oerrors.OperationTypeParseArtifactReference </span><span class="cov0" title="0">{
                                        // invalid reference
                                        err.Recommendation = fmt.Sprintf("Are you missing an artifact reference to attach to? %s", err.Recommendation)
                                }</span>
                        }
                        <span class="cov0" title="0">return err</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        opts.Printer.Verbose = opts.verbose
                        return runAttach(cmd, &amp;opts)
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;opts.artifactType, "artifact-type", "", "", "artifact type")
        cmd.Flags().IntVarP(&amp;opts.concurrency, "concurrency", "", 5, "concurrency level")
        cmd.Flags().BoolVarP(&amp;opts.verbose, "verbose", "v", true, "print status output for unnamed blobs")
        opts.FlagDescription = "[Preview] attach to an arch-specific subject"
        _ = cmd.MarkFlagRequired("artifact-type")
        _ = cmd.Flags().MarkDeprecated("verbose", "and will be removed in a future release.")
        opts.EnableDistributionSpecFlag()
        opts.SetTypes(option.FormatTypeText, option.FormatTypeJSON, option.FormatTypeGoTemplate)
        option.ApplyFlags(&amp;opts, cmd.Flags())
        return oerrors.Command(cmd, &amp;opts.Target)</span>
}

func runAttach(cmd *cobra.Command, opts *attachOptions) error <span class="cov0" title="0">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)
        if len(opts.FileRefs) == 0 &amp;&amp; len(opts.Annotations[option.AnnotationManifest]) == 0 </span><span class="cov0" title="0">{
                return &amp;oerrors.Error{
                        Err:            errors.New(`neither file nor annotation provided in the command`),
                        Usage:          fmt.Sprintf("%s %s", cmd.Parent().CommandPath(), cmd.Use),
                        Recommendation: `To attach to an existing artifact, please provide files via argument or annotations via flag "--annotation". Run "oras attach -h" for more options and examples`,
                }
        }</span>

        // prepare manifest
        <span class="cov0" title="0">store, err := file.New("")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = store.Close() }</span>()

        <span class="cov0" title="0">dst, err := opts.NewTarget(opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // add both pull and push scope hints for dst repository
        // to save potential push-scope token requests during copy
        <span class="cov0" title="0">ctx = registryutil.WithScopeHint(ctx, dst, auth.ActionPull, auth.ActionPush)
        fetchOpts := oras.DefaultResolveOptions
        fetchOpts.TargetPlatform = opts.Platform.Platform
        subject, err := oras.Resolve(ctx, dst, opts.Reference, fetchOpts)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to resolve %s: %w", opts.Reference, err)
        }</span>
        <span class="cov0" title="0">statusHandler, metadataHandler, err := display.NewAttachHandler(opts.Printer, opts.Format, opts.TTY, store)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">descs, err := loadFiles(ctx, store, opts.Annotations, opts.FileRefs, statusHandler)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // prepare push
        <span class="cov0" title="0">dst, stopTrack, err := statusHandler.TrackTarget(dst)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">graphCopyOptions := oras.DefaultCopyGraphOptions
        graphCopyOptions.Concurrency = opts.concurrency
        graphCopyOptions.OnCopySkipped = statusHandler.OnCopySkipped
        graphCopyOptions.PreCopy = statusHandler.PreCopy
        graphCopyOptions.PostCopy = statusHandler.PostCopy

        packOpts := oras.PackManifestOptions{
                Subject:             &amp;subject,
                ManifestAnnotations: opts.Annotations[option.AnnotationManifest],
                Layers:              descs,
        }
        pack := func() (ocispec.Descriptor, error) </span><span class="cov0" title="0">{
                return oras.PackManifest(ctx, store, oras.PackManifestVersion1_1, opts.artifactType, packOpts)
        }</span>

        <span class="cov0" title="0">copy := func(root ocispec.Descriptor) error </span><span class="cov0" title="0">{
                graphCopyOptions.FindSuccessors = func(ctx context.Context, fetcher content.Fetcher, node ocispec.Descriptor) ([]ocispec.Descriptor, error) </span><span class="cov0" title="0">{
                        if content.Equal(node, root) </span><span class="cov0" title="0">{
                                // skip duplicated Resolve on subject
                                successors, _, config, err := graph.Successors(ctx, fetcher, node)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">if config != nil </span><span class="cov0" title="0">{
                                        successors = append(successors, *config)
                                }</span>
                                <span class="cov0" title="0">return successors, nil</span>
                        }
                        <span class="cov0" title="0">return content.Successors(ctx, fetcher, node)</span>
                }
                <span class="cov0" title="0">return oras.CopyGraph(ctx, store, dst, root, graphCopyOptions)</span>
        }

        // Attach
        <span class="cov0" title="0">root, err := doPush(dst, stopTrack, pack, copy)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">metadataHandler.OnAttached(&amp;opts.Target, root, subject)
        err = metadataHandler.Render()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Export manifest
        <span class="cov0" title="0">return opts.ExportManifest(ctx, store, root)</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package blob

import (
        "github.com/spf13/cobra"
)

func Cmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "blob [command]",
                Short: "Blob operations",
        }

        cmd.AddCommand(
                deleteCmd(),
                fetchCmd(),
                pushCmd(),
        )
        return cmd
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package blob

import (
        "errors"
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "oras.land/oras-go/v2/errdef"
        "oras.land/oras-go/v2/registry/remote/auth"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        "oras.land/oras/cmd/oras/internal/display"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/internal/registryutil"
)

type deleteBlobOptions struct {
        option.Common
        option.Confirmation
        option.Descriptor
        option.Pretty
        option.Target
}

func deleteCmd() *cobra.Command <span class="cov0" title="0">{
        var opts deleteBlobOptions
        cmd := &amp;cobra.Command{
                Use:     "delete [flags] &lt;name&gt;@&lt;digest&gt;",
                Aliases: []string{"remove", "rm"},
                Short:   "Delete a blob from a remote registry",
                Long: `Delete a blob from a remote registry

Example - Delete a blob:
  oras blob delete localhost:5000/hello@sha256:9a201d228ebd966211f7d1131be19f152be428bd373a92071c71d8deaf83b3e5

Example - Delete a blob without prompting confirmation:
  oras blob delete --force localhost:5000/hello@sha256:9a201d228ebd966211f7d1131be19f152be428bd373a92071c71d8deaf83b3e5

Example - Delete a blob and print its descriptor:
  oras blob delete --descriptor --force localhost:5000/hello@sha256:9a201d228ebd966211f7d1131be19f152be428bd373a92071c71d8deaf83b3e5
  `,
                Args: oerrors.CheckArgs(argument.Exactly(1), "the target blob to delete"),
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        opts.RawReference = args[0]
                        if opts.OutputDescriptor &amp;&amp; !opts.Force </span><span class="cov0" title="0">{
                                return errors.New("must apply --force to confirm the deletion if the descriptor is outputted")
                        }</span>
                        <span class="cov0" title="0">return option.Parse(cmd, &amp;opts)</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        return deleteBlob(cmd, &amp;opts)
                }</span>,
        }

        <span class="cov0" title="0">option.AddDeprecatedVerboseFlag(cmd.Flags())
        option.ApplyFlags(&amp;opts, cmd.Flags())
        return oerrors.Command(cmd, &amp;opts.Target)</span>
}

func deleteBlob(cmd *cobra.Command, opts *deleteBlobOptions) (err error) <span class="cov0" title="0">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)
        blobs, err := opts.NewBlobDeleter(opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := opts.EnsureReferenceNotEmpty(cmd, false); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">metadataHandler := display.NewBlobDeleteHandler(opts.Printer, &amp;opts.Target)

        // add both pull and delete scope hints for dst repository to save potential delete-scope token requests during deleting
        ctx = registryutil.WithScopeHint(ctx, blobs, auth.ActionPull, auth.ActionDelete)
        desc, err := blobs.Resolve(ctx, opts.Reference)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errdef.ErrNotFound) </span><span class="cov0" title="0">{
                        if opts.Force &amp;&amp; !opts.OutputDescriptor </span><span class="cov0" title="0">{
                                return metadataHandler.OnBlobMissing()
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("%s: the specified blob does not exist", opts.RawReference)</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">prompt := fmt.Sprintf("Are you sure you want to delete the blob %q?", desc.Digest)
        confirmed, err := opts.AskForConfirmation(os.Stdin, prompt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !confirmed </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err = blobs.Delete(ctx, desc); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete %s: %w", opts.RawReference, err)
        }</span>

        <span class="cov0" title="0">if opts.OutputDescriptor </span><span class="cov0" title="0">{
                descJSON, err := opts.Marshal(desc)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return opts.Output(os.Stdout, descJSON)</span>
        }

        <span class="cov0" title="0">return metadataHandler.OnBlobDeleted()</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package blob

import (
        "context"
        "errors"
        "io"
        "os"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/spf13/cobra"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/content"
        "oras.land/oras-go/v2/registry/remote"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        "oras.land/oras/cmd/oras/internal/display/status/track"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/internal/progress"
)

type fetchBlobOptions struct {
        option.Cache
        option.Common
        option.Descriptor
        option.Pretty
        option.Target
        option.Terminal

        outputPath string
}

func fetchCmd() *cobra.Command <span class="cov0" title="0">{
        var opts fetchBlobOptions
        cmd := &amp;cobra.Command{
                Use:   "fetch [flags] {--output &lt;file&gt; | --descriptor} &lt;name&gt;@&lt;digest&gt;",
                Short: "Fetch a blob from a registry or an OCI image layout",
                Long: `Fetch a blob from a registry or an OCI image layout

Example - Fetch a blob from registry and save it to a local file:
  oras blob fetch --output blob.tar.gz localhost:5000/hello@sha256:9a201d228ebd966211f7d1131be19f152be428bd373a92071c71d8deaf83b3e5

Example - Fetch a blob from registry and print the raw blob content:
  oras blob fetch --output - localhost:5000/hello@sha256:9a201d228ebd966211f7d1131be19f152be428bd373a92071c71d8deaf83b3e5

Example - Fetch and print the descriptor of a blob:
  oras blob fetch --descriptor localhost:5000/hello@sha256:9a201d228ebd966211f7d1131be19f152be428bd373a92071c71d8deaf83b3e5

Example - Fetch a blob, save it to a local file and print the descriptor:
  oras blob fetch --output blob.tar.gz --descriptor localhost:5000/hello@sha256:9a201d228ebd966211f7d1131be19f152be428bd373a92071c71d8deaf83b3e5

Example - Fetch and print a blob from OCI image layout folder 'layout-dir':
  oras blob fetch --oci-layout --output - layout-dir@sha256:9a201d228ebd966211f7d1131be19f152be428bd373a92071c71d8deaf83b3e5

Example - Fetch and print a blob from OCI image layout archive file 'layout.tar':
  oras blob fetch --oci-layout --output - layout.tar@sha256:9a201d228ebd966211f7d1131be19f152be428bd373a92071c71d8deaf83b3e5
`,
                Args: oerrors.CheckArgs(argument.Exactly(1), "the target blob to fetch"),
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if opts.outputPath == "" &amp;&amp; !opts.OutputDescriptor </span><span class="cov0" title="0">{
                                return errors.New("either `--output` or `--descriptor` must be provided")
                        }</span>

                        <span class="cov0" title="0">if opts.outputPath == "-" &amp;&amp; opts.OutputDescriptor </span><span class="cov0" title="0">{
                                return errors.New("`--output -` cannot be used with `--descriptor` at the same time")
                        }</span>
                        <span class="cov0" title="0">opts.RawReference = args[0]
                        if err := option.Parse(cmd, &amp;opts); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">opts.DisableTTY(opts.Debug, opts.outputPath == "-")
                        return nil</span>
                },
                Aliases: []string{"get"},
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        return fetchBlob(cmd, &amp;opts)
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;opts.outputPath, "output", "o", "", "output file `path`, use - for stdout")
        option.AddDeprecatedVerboseFlag(cmd.Flags())
        option.ApplyFlags(&amp;opts, cmd.Flags())
        return oerrors.Command(cmd, &amp;opts.Target)</span>
}

func fetchBlob(cmd *cobra.Command, opts *fetchBlobOptions) (fetchErr error) <span class="cov0" title="0">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)
        var target oras.ReadOnlyTarget
        target, err := opts.NewReadonlyTarget(ctx, opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := opts.EnsureReferenceNotEmpty(cmd, false); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if repo, ok := target.(*remote.Repository); ok </span><span class="cov0" title="0">{
                target = repo.Blobs()
        }</span>
        <span class="cov0" title="0">src, err := opts.CachedTarget(target)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">desc, err := opts.doFetch(ctx, src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // outputs blob's descriptor if `--descriptor` is used
        <span class="cov0" title="0">if opts.OutputDescriptor </span><span class="cov0" title="0">{
                descJSON, err := opts.Marshal(desc)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := opts.Output(os.Stdout, descJSON); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (opts *fetchBlobOptions) doFetch(ctx context.Context, src oras.ReadOnlyTarget) (desc ocispec.Descriptor, fetchErr error) <span class="cov8" title="1">{
        var err error
        if opts.outputPath == "" </span><span class="cov0" title="0">{
                // fetch blob descriptor only
                return oras.Resolve(ctx, src, opts.Reference, oras.DefaultResolveOptions)
        }</span>
        // fetch blob content
        <span class="cov8" title="1">var rc io.ReadCloser
        desc, rc, err = oras.Fetch(ctx, src, opts.Reference, oras.DefaultFetchOptions)
        if err != nil </span><span class="cov0" title="0">{
                return ocispec.Descriptor{}, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = rc.Close() }</span>()
        <span class="cov8" title="1">vr := content.NewVerifyReader(rc, desc)

        // outputs blob content if "--output -" is used
        writer := os.Stdout
        if opts.outputPath != "-" </span><span class="cov8" title="1">{
                // save blob content into the local file if the output path is provided
                file, err := os.Create(opts.outputPath)
                if err != nil </span><span class="cov0" title="0">{
                        return ocispec.Descriptor{}, err
                }</span>
                <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                        if err := file.Close(); fetchErr == nil </span><span class="cov8" title="1">{
                                fetchErr = err
                        }</span>
                }()
                <span class="cov8" title="1">writer = file</span>
        }

        <span class="cov8" title="1">if opts.TTY == nil </span><span class="cov0" title="0">{
                // none TTY output
                if _, err = io.Copy(writer, vr); err != nil </span><span class="cov0" title="0">{
                        return ocispec.Descriptor{}, err
                }</span>
        } else<span class="cov8" title="1"> {
                // TTY output
                trackedReader, err := track.NewReader(vr, desc, "Downloading", "Downloaded ", opts.TTY)
                if err != nil </span><span class="cov0" title="0">{
                        return ocispec.Descriptor{}, err
                }</span>
                <span class="cov8" title="1">defer trackedReader.StopManager()
                if err := progress.Start(trackedReader.Tracker()); err != nil </span><span class="cov0" title="0">{
                        return ocispec.Descriptor{}, err
                }</span>
                <span class="cov8" title="1">if _, err = io.Copy(writer, trackedReader); err != nil </span><span class="cov0" title="0">{
                        return ocispec.Descriptor{}, err
                }</span>
                <span class="cov8" title="1">if err := progress.Done(trackedReader.Tracker()); err != nil </span><span class="cov0" title="0">{
                        return ocispec.Descriptor{}, err
                }</span>
        }
        <span class="cov8" title="1">if err := vr.Verify(); err != nil </span><span class="cov0" title="0">{
                return ocispec.Descriptor{}, err
        }</span>
        <span class="cov8" title="1">return desc, nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package blob

import (
        "context"
        "errors"
        "io"
        "os"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/spf13/cobra"
        "oras.land/oras-go/v2"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        "oras.land/oras/cmd/oras/internal/display"
        "oras.land/oras/cmd/oras/internal/display/status"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/internal/file"
)

type pushBlobOptions struct {
        option.Common
        option.Descriptor
        option.Pretty
        option.Target
        option.Terminal

        fileRef   string
        mediaType string
        size      int64
        // Deprecated: verbose is deprecated and will be removed in the future.
        verbose bool
}

func pushCmd() *cobra.Command <span class="cov0" title="0">{
        var opts pushBlobOptions
        cmd := &amp;cobra.Command{
                Use:   "push [flags] &lt;name&gt;[@digest] &lt;file&gt;",
                Short: "Push a blob to a registry or an OCI image layout",
                Long: `Push a blob to a registry or an OCI image layout

Example - Push blob 'hi.txt' to a registry:
  oras blob push localhost:5000/hello hi.txt

Example - Push blob 'hi.txt' with the specific digest:
  oras blob push localhost:5000/hello@sha256:9a201d228ebd966211f7d1131be19f152be428bd373a92071c71d8deaf83b3e5 hi.txt

Example - Push blob from stdin with blob size and digest:
  oras blob push --size 12 localhost:5000/hello@sha256:9a201d228ebd966211f7d1131be19f152be428bd373a92071c71d8deaf83b3e5 -

Example - Push blob 'hi.txt' and output the descriptor:
  oras blob push --descriptor localhost:5000/hello hi.txt

Example - Push blob 'hi.txt' with the specific returned media type in the descriptor:
  oras blob push --media-type application/vnd.oci.image.config.v1+json --descriptor localhost:5000/hello hi.txt

Example - Push blob 'hi.txt' and output the prettified descriptor:
  oras blob push --descriptor --pretty localhost:5000/hello hi.txt

Example - Push blob without TLS:
  oras blob push --insecure localhost:5000/hello hi.txt

Example - Push blob 'hi.txt' into an OCI image layout folder 'layout-dir':
  oras blob push --oci-layout layout-dir hi.txt
`,
                Args: oerrors.CheckArgs(argument.Exactly(2), "the destination to push to and the file to read blob content from"),
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        opts.RawReference = args[0]
                        opts.fileRef = args[1]
                        if opts.fileRef == "-" </span><span class="cov0" title="0">{
                                if err := option.CheckStdinConflict(cmd.Flags()); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if opts.size &lt; 0 </span><span class="cov0" title="0">{
                                        return errors.New("`--size` must be provided if the blob is read from stdin")
                                }</span>
                        }
                        <span class="cov0" title="0">if err := option.Parse(cmd, &amp;opts); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">opts.DisableTTY(opts.Debug, false)
                        return nil</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        opts.Printer.Verbose = opts.verbose &amp;&amp; !opts.OutputDescriptor
                        return pushBlob(cmd, &amp;opts)
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().Int64VarP(&amp;opts.size, "size", "", -1, "provide the blob size")
        cmd.Flags().StringVarP(&amp;opts.mediaType, "media-type", "", ocispec.MediaTypeImageLayer, "specify the returned media type in the descriptor if --descriptor is used")
        cmd.Flags().BoolVarP(&amp;opts.verbose, "verbose", "v", true, "print status output for unnamed blobs")
        _ = cmd.Flags().MarkDeprecated("verbose", "and will be removed in a future release.")
        option.ApplyFlags(&amp;opts, cmd.Flags())
        return oerrors.Command(cmd, &amp;opts.Target)</span>
}

func pushBlob(cmd *cobra.Command, opts *pushBlobOptions) (err error) <span class="cov0" title="0">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)

        target, err := opts.NewTarget(opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // prepare blob content
        <span class="cov0" title="0">desc, rc, err := file.PrepareBlobContent(opts.fileRef, opts.mediaType, opts.Reference, opts.size)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = rc.Close() }</span>()

        <span class="cov0" title="0">statusHandler, metadataHandler := display.NewBlobPushHandler(opts.Printer, opts.OutputDescriptor, opts.Pretty.Pretty, desc, opts.TTY)
        if err := doPush(ctx, statusHandler, target, desc, rc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // outputs blob's descriptor
        <span class="cov0" title="0">if opts.OutputDescriptor </span><span class="cov0" title="0">{
                descJSON, err := opts.Marshal(desc)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return opts.Output(os.Stdout, descJSON)</span>
        }

        <span class="cov0" title="0">if err := metadataHandler.OnBlobPushed(&amp;opts.Target); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return metadataHandler.Render()</span>
}

func doPush(ctx context.Context, statusHandler status.BlobPushHandler, t oras.GraphTarget, desc ocispec.Descriptor, r io.Reader) (err error) <span class="cov8" title="1">{
        gt, err := statusHandler.StartTracking(t)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                stopErr := statusHandler.StopTracking()
                if err == nil </span><span class="cov8" title="1">{
                        err = stopErr
                }</span>
        }()
        <span class="cov8" title="1">exists, err := gt.Exists(ctx, desc)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov0" title="0">{
                return statusHandler.OnBlobExists()
        }</span>
        <span class="cov8" title="1">if err := statusHandler.OnBlobUploading(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := gt.Push(ctx, desc, r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return statusHandler.OnBlobUploaded()</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package root

import (
        "github.com/spf13/cobra"
        "oras.land/oras/cmd/oras/root/blob"
        "oras.land/oras/cmd/oras/root/manifest"
        "oras.land/oras/cmd/oras/root/repo"
)

func New() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:          "oras [command]",
                SilenceUsage: true,
        }
        cmd.AddCommand(
                pullCmd(),
                pushCmd(),
                loginCmd(),
                logoutCmd(),
                versionCmd(),
                discoverCmd(),
                resolveCmd(),
                copyCmd(),
                tagCmd(),
                attachCmd(),
                blob.Cmd(),
                manifest.Cmd(),
                repo.Cmd(),
        )
        return cmd
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package root

import (
        "context"
        "encoding/json"
        "fmt"
        "slices"
        "strings"

        "github.com/opencontainers/go-digest"
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/spf13/cobra"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/content"
        "oras.land/oras-go/v2/registry"
        "oras.land/oras-go/v2/registry/remote"
        "oras.land/oras-go/v2/registry/remote/auth"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        "oras.land/oras/cmd/oras/internal/display"
        "oras.land/oras/cmd/oras/internal/display/status"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/internal/docker"
        "oras.land/oras/internal/graph"
        "oras.land/oras/internal/listener"
        "oras.land/oras/internal/registryutil"
)

type copyOptions struct {
        option.Common
        option.Platform
        option.BinaryTarget
        option.Terminal

        recursive   bool
        concurrency int
        extraRefs   []string
        // Deprecated: verbose is deprecated and will be removed in the future.
        verbose bool
}

func copyCmd() *cobra.Command <span class="cov0" title="0">{
        var opts copyOptions
        cmd := &amp;cobra.Command{
                Use:     "cp [flags] &lt;from&gt;{:&lt;tag&gt;|@&lt;digest&gt;} &lt;to&gt;[:&lt;tag&gt;[,&lt;tag&gt;][...]]",
                Aliases: []string{"copy"},
                Short:   "Copy artifacts from one target to another",
                Long: `Copy artifacts from one target to another. When copying an image index, all of its manifests will be copied

Example - Copy an artifact between registries:
  oras cp localhost:5000/net-monitor:v1 localhost:6000/net-monitor-copy:v1

Example - Download an artifact into an OCI image layout folder:
  oras cp --to-oci-layout localhost:5000/net-monitor:v1 ./downloaded:v1

Example - Upload an artifact from an OCI image layout folder:
  oras cp --from-oci-layout ./to-upload:v1 localhost:5000/net-monitor:v1

Example - Upload an artifact from an OCI layout tar archive:
  oras cp --from-oci-layout ./to-upload.tar:v1 localhost:5000/net-monitor:v1

Example - Copy an artifact and its referrers:
  oras cp -r localhost:5000/net-monitor:v1 localhost:6000/net-monitor-copy:v1

Example - Copy an artifact and referrers using specific methods for the Referrers API:
  oras cp -r --from-distribution-spec v1.1-referrers-api --to-distribution-spec v1.1-referrers-tag \
    localhost:5000/net-monitor:v1 localhost:6000/net-monitor-copy:v1

Example - Copy certain platform of an artifact:
  oras cp --platform linux/arm/v5 localhost:5000/net-monitor:v1 localhost:6000/net-monitor-copy:v1

Example - Copy an artifact with multiple tags:
  oras cp localhost:5000/net-monitor:v1 localhost:6000/net-monitor-copy:tag1,tag2,tag3

Example - Copy an artifact with multiple tags with concurrency tuned:
  oras cp --concurrency 10 localhost:5000/net-monitor:v1 localhost:5000/net-monitor-copy:tag1,tag2,tag3
`,
                Args: oerrors.CheckArgs(argument.Exactly(2), "the source and destination for copying"),
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        opts.From.RawReference = args[0]
                        refs := strings.Split(args[1], ",")
                        opts.To.RawReference = refs[0]
                        opts.extraRefs = refs[1:]
                        err := option.Parse(cmd, &amp;opts)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">opts.DisableTTY(opts.Debug, false)
                        return nil</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        opts.Printer.Verbose = opts.verbose
                        return runCopy(cmd, &amp;opts)
                }</span>,
        }
        <span class="cov0" title="0">cmd.Flags().BoolVarP(&amp;opts.recursive, "recursive", "r", false, "[Preview] recursively copy the artifact and its referrer artifacts")
        cmd.Flags().IntVarP(&amp;opts.concurrency, "concurrency", "", 3, "concurrency level")
        cmd.Flags().BoolVarP(&amp;opts.verbose, "verbose", "v", true, "print status output for unnamed blobs")
        _ = cmd.Flags().MarkDeprecated("verbose", "and will be removed in a future release.")
        opts.EnableDistributionSpecFlag()
        option.ApplyFlags(&amp;opts, cmd.Flags())
        return oerrors.Command(cmd, &amp;opts.BinaryTarget)</span>
}

func runCopy(cmd *cobra.Command, opts *copyOptions) error <span class="cov0" title="0">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)

        // Prepare source
        src, err := opts.From.NewReadonlyTarget(ctx, opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := opts.EnsureSourceTargetReferenceNotEmpty(cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Prepare destination
        <span class="cov0" title="0">dst, err := opts.To.NewTarget(opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ctx = registryutil.WithScopeHint(ctx, dst, auth.ActionPull, auth.ActionPush)
        statusHandler, metadataHandler := display.NewCopyHandler(opts.Printer, opts.TTY, dst)

        desc, err := doCopy(ctx, statusHandler, src, dst, opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if from, err := digest.Parse(opts.From.Reference); err == nil &amp;&amp; from != desc.Digest </span><span class="cov0" title="0">{
                // correct source digest
                opts.From.RawReference = fmt.Sprintf("%s@%s", opts.From.Path, desc.Digest.String())
        }</span>

        <span class="cov0" title="0">if err := metadataHandler.OnCopied(&amp;opts.BinaryTarget, desc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(opts.extraRefs) != 0 </span><span class="cov0" title="0">{
                tagNOpts := oras.DefaultTagNOptions
                tagNOpts.Concurrency = opts.concurrency
                tagListener := listener.NewTaggedListener(dst, metadataHandler.OnTagged)
                if _, err = oras.TagN(ctx, tagListener, opts.To.Reference, opts.extraRefs, tagNOpts); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return metadataHandler.Render()</span>
}

func doCopy(ctx context.Context, copyHandler status.CopyHandler, src oras.ReadOnlyGraphTarget, dst oras.GraphTarget, opts *copyOptions) (desc ocispec.Descriptor, err error) <span class="cov6" title="3">{
        // Prepare copy options
        extendedCopyOptions := oras.DefaultExtendedCopyOptions
        extendedCopyOptions.Concurrency = opts.concurrency
        extendedCopyOptions.FindPredecessors = func(ctx context.Context, src content.ReadOnlyGraphStorage, desc ocispec.Descriptor) ([]ocispec.Descriptor, error) </span><span class="cov0" title="0">{
                return registry.Referrers(ctx, src, desc, "")
        }</span>

        <span class="cov6" title="3">srcRepo, srcIsRemote := src.(*remote.Repository)
        dstRepo, dstIsRemote := dst.(*remote.Repository)
        if srcIsRemote &amp;&amp; dstIsRemote &amp;&amp; srcRepo.Reference.Registry == dstRepo.Reference.Registry </span><span class="cov1" title="1">{
                extendedCopyOptions.MountFrom = func(ctx context.Context, desc ocispec.Descriptor) ([]string, error) </span><span class="cov1" title="1">{
                        return []string{srcRepo.Reference.Repository}, nil
                }</span>
        }
        <span class="cov6" title="3">dst, err = copyHandler.StartTracking(dst)
        if err != nil </span><span class="cov0" title="0">{
                return desc, err
        }</span>
        <span class="cov6" title="3">defer func() </span><span class="cov6" title="3">{
                stopErr := copyHandler.StopTracking()
                if err == nil </span><span class="cov6" title="3">{
                        err = stopErr
                }</span>
        }()
        <span class="cov6" title="3">extendedCopyOptions.OnCopySkipped = copyHandler.OnCopySkipped
        extendedCopyOptions.PreCopy = copyHandler.PreCopy
        extendedCopyOptions.PostCopy = copyHandler.PostCopy
        extendedCopyOptions.OnMounted = copyHandler.OnMounted

        rOpts := oras.DefaultResolveOptions
        rOpts.TargetPlatform = opts.Platform.Platform
        if opts.recursive </span><span class="cov0" title="0">{
                desc, err = oras.Resolve(ctx, src, opts.From.Reference, rOpts)
                if err != nil </span><span class="cov0" title="0">{
                        return ocispec.Descriptor{}, fmt.Errorf("failed to resolve %s: %w", opts.From.Reference, err)
                }</span>
                <span class="cov0" title="0">err = recursiveCopy(ctx, src, dst, opts.To.Reference, desc, extendedCopyOptions)</span>
        } else<span class="cov6" title="3"> {
                if opts.To.Reference == "" </span><span class="cov6" title="3">{
                        desc, err = oras.Resolve(ctx, src, opts.From.Reference, rOpts)
                        if err != nil </span><span class="cov0" title="0">{
                                return ocispec.Descriptor{}, fmt.Errorf("failed to resolve %s: %w", opts.From.Reference, err)
                        }</span>
                        <span class="cov6" title="3">err = oras.CopyGraph(ctx, src, dst, desc, extendedCopyOptions.CopyGraphOptions)</span>
                } else<span class="cov0" title="0"> {
                        copyOptions := oras.CopyOptions{
                                CopyGraphOptions: extendedCopyOptions.CopyGraphOptions,
                        }
                        if opts.Platform.Platform != nil </span><span class="cov0" title="0">{
                                copyOptions.WithTargetPlatform(opts.Platform.Platform)
                        }</span>
                        <span class="cov0" title="0">desc, err = oras.Copy(ctx, src, opts.From.Reference, dst, opts.To.Reference, copyOptions)</span>
                }
        }
        <span class="cov6" title="3">return desc, err</span>
}

// recursiveCopy copies an artifact and its referrers from one target to another.
// If the artifact is a manifest list or index, referrers of its manifests are copied as well.
func recursiveCopy(ctx context.Context, src oras.ReadOnlyGraphTarget, dst oras.Target, dstRef string, root ocispec.Descriptor, opts oras.ExtendedCopyOptions) error <span class="cov0" title="0">{
        var err error
        if opts, err = prepareCopyOption(ctx, src, dst, root, opts); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if dstRef == "" || dstRef == root.Digest.String() </span><span class="cov0" title="0">{
                err = oras.ExtendedCopyGraph(ctx, src, dst, root, opts.ExtendedCopyGraphOptions)
        }</span> else<span class="cov0" title="0"> {
                _, err = oras.ExtendedCopy(ctx, src, root.Digest.String(), dst, dstRef, opts)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func prepareCopyOption(ctx context.Context, src oras.ReadOnlyGraphTarget, dst oras.Target, root ocispec.Descriptor, opts oras.ExtendedCopyOptions) (oras.ExtendedCopyOptions, error) <span class="cov10" title="6">{
        if root.MediaType != ocispec.MediaTypeImageIndex &amp;&amp; root.MediaType != docker.MediaTypeManifestList </span><span class="cov1" title="1">{
                return opts, nil
        }</span>

        <span class="cov9" title="5">fetched, err := content.FetchAll(ctx, src, root)
        if err != nil </span><span class="cov4" title="2">{
                return opts, err
        }</span>
        <span class="cov6" title="3">var index ocispec.Index
        if err = json.Unmarshal(fetched, &amp;index); err != nil </span><span class="cov1" title="1">{
                return opts, err
        }</span>

        <span class="cov4" title="2">if len(index.Manifests) == 0 </span><span class="cov0" title="0">{
                // no child manifests, thus no child referrers
                return opts, nil
        }</span>

        <span class="cov4" title="2">referrers, err := graph.FindPredecessors(ctx, src, index.Manifests, opts)
        if err != nil </span><span class="cov1" title="1">{
                return opts, err
        }</span>

        <span class="cov1" title="1">referrers = slices.DeleteFunc(referrers, func(desc ocispec.Descriptor) bool </span><span class="cov0" title="0">{
                return content.Equal(desc, root)
        }</span>)

        <span class="cov1" title="1">if len(referrers) == 0 </span><span class="cov1" title="1">{
                // no child referrers
                return opts, nil
        }</span>

        <span class="cov0" title="0">findPredecessor := opts.FindPredecessors
        opts.FindPredecessors = func(ctx context.Context, src content.ReadOnlyGraphStorage, desc ocispec.Descriptor) ([]ocispec.Descriptor, error) </span><span class="cov0" title="0">{
                descs, err := findPredecessor(ctx, src, desc)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if content.Equal(desc, root) </span><span class="cov0" title="0">{
                        // make sure referrers of child manifests are copied by pointing them to root
                        descs = append(descs, referrers...)
                }</span>
                <span class="cov0" title="0">return descs, nil</span>
        }
        <span class="cov0" title="0">return opts, nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package root

import (
        "context"
        "errors"
        "fmt"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/spf13/cobra"

        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/registry"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        "oras.land/oras/cmd/oras/internal/display"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
)

type discoverOptions struct {
        option.Common
        option.Platform
        option.Target
        option.Format
        option.Terminal

        artifactType string
        depth        int
        // Deprecated: verbose is deprecated and will be removed in the future.
        verbose bool
}

func discoverCmd() *cobra.Command <span class="cov0" title="0">{
        var opts discoverOptions
        cmd := &amp;cobra.Command{
                Use:   "discover [flags] &lt;name&gt;{:&lt;tag&gt;|@&lt;digest&gt;}",
                Short: "[Preview] Discover referrers of a manifest in a registry or an OCI image layout",
                Long: `[Preview] Discover referrers of a manifest in a registry or an OCI image layout

** This command is in preview and under development. **

Example - Discover referrers of manifest 'hello:v1' in registry 'localhost:5000', displayed in a tree view:
  oras discover localhost:5000/hello:v1

Example - Discover referrers via referrers API:
  oras discover --distribution-spec v1.1-referrers-api localhost:5000/hello:v1

Example - Discover referrers via tag scheme:
  oras discover --distribution-spec v1.1-referrers-tag localhost:5000/hello:v1

Example - [Experimental] Discover referrers and display in a table view:
  oras discover localhost:5000/hello:v1 --format table

Example - [Experimental] Discover referrers and format output with Go template:
  oras discover localhost:5000/hello:v1 --format go-template --template "{{.referrers}}"

Example - [Experimental] Discover only direct referrers, displayed in json view:
  oras discover localhost:5000/hello:v1 --format json --depth 1

Example - Discover referrers with type 'test-artifact' of manifest 'hello:v1' in registry 'localhost:5000':
  oras discover --artifact-type test-artifact localhost:5000/hello:v1

Example - Discover referrers of the manifest tagged 'v1' in an OCI image layout folder 'layout-dir':
  oras discover --oci-layout layout-dir:v1

Example - Discover referrers of the manifest tagged 'example.com:v1' in an OCI image layout folder 'layout-dir':
  oras discover example.com:v1 --oci-layout-path layout-dir
`,
                Args: oerrors.CheckArgs(argument.Exactly(1), "the target artifact to discover referrers from"),
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if err := oerrors.CheckMutuallyExclusiveFlags(cmd.Flags(), "format", "output"); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if cmd.Flags().Changed("depth") &amp;&amp; opts.depth &lt; 1 </span><span class="cov0" title="0">{
                                return errors.New("depth value should be at least 1")
                        }</span>
                        // only show direct referrers for table format
                        <span class="cov0" title="0">if opts.FormatFlag == option.FormatTypeTable.Name </span><span class="cov0" title="0">{
                                opts.depth = 1
                        }</span>
                        <span class="cov0" title="0">opts.RawReference = args[0]
                        if err := option.Parse(cmd, &amp;opts); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if cmd.Flags().Changed("output") </span><span class="cov0" title="0">{
                                switch opts.Format.Type </span>{
                                case option.FormatTypeTree.Name, option.FormatTypeJSON.Name, option.FormatTypeTable.Name:<span class="cov0" title="0">
                                        _, _ = fmt.Fprintf(cmd.ErrOrStderr(), "[DEPRECATED] --output is deprecated, try `--format %s` instead\n", opts.Template)</span>
                                default:<span class="cov0" title="0">
                                        return errors.New("output type can only be tree, table or json")</span>
                                }
                        }
                        <span class="cov0" title="0">opts.DisableTTY(opts.Debug, false)
                        return nil</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        return runDiscover(cmd, &amp;opts)
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;opts.artifactType, "artifact-type", "", "", "artifact type")
        cmd.Flags().StringVarP(&amp;opts.FormatFlag, "output", "o", "tree", "[Deprecated] format in which to display referrers (table, json, or tree).")
        cmd.Flags().BoolVarP(&amp;opts.verbose, "verbose", "v", true, "display full metadata of referrers")
        cmd.Flags().IntVarP(&amp;opts.depth, "depth", "", 0, "[Experimental] level of referrers to display, if unused shows referrers of all levels")
        _ = cmd.Flags().MarkDeprecated("verbose", "and will be removed in a future release.")
        opts.SetTypes(
                option.FormatTypeTree,
                option.FormatTypeTable,
                option.FormatTypeJSON.WithUsage("Get referrers and output in JSON format"),
                option.FormatTypeGoTemplate.WithUsage("Print referrers using the given Go template"),
        )
        opts.EnableDistributionSpecFlag()
        option.ApplyFlags(&amp;opts, cmd.Flags())
        cmd.Flags().Lookup(option.NoTTYFlag).Usage = "[Preview] disable colors"
        return oerrors.Command(cmd, &amp;opts.Target)</span>
}

func runDiscover(cmd *cobra.Command, opts *discoverOptions) error <span class="cov0" title="0">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)
        repo, err := opts.NewReadonlyTarget(ctx, opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := opts.EnsureReferenceNotEmpty(cmd, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // discover artifacts
        <span class="cov0" title="0">resolveOpts := oras.DefaultResolveOptions
        resolveOpts.TargetPlatform = opts.Platform.Platform
        desc, err := oras.Resolve(ctx, repo, opts.Reference, resolveOpts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">handler, err := display.NewDiscoverHandler(opts.Printer, opts.Format, opts.Path, opts.RawReference, desc, opts.verbose, opts.TTY)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := fetchAllReferrers(ctx, repo, desc, opts.artifactType, handler, opts.depth); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return handler.Render()</span>
}

func fetchAllReferrers(ctx context.Context, repo oras.ReadOnlyGraphTarget, desc ocispec.Descriptor, artifactType string, handler metadata.DiscoverHandler, depth int) error <span class="cov0" title="0">{
        results, err := registry.Referrers(ctx, repo, desc, artifactType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var nextDepth int
        if depth &gt; 0 </span><span class="cov0" title="0">{
                nextDepth = depth - 1
        }</span>
        <span class="cov0" title="0">for _, r := range results </span><span class="cov0" title="0">{
                if err := handler.OnDiscovered(r, desc); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if depth == 1 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if err := fetchAllReferrers(ctx, repo, ocispec.Descriptor{
                        Digest:    r.Digest,
                        Size:      r.Size,
                        MediaType: r.MediaType,
                }, artifactType, handler, nextDepth); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package root

import (
        "context"
        "errors"
        "io/fs"
        "path/filepath"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras-go/v2/content/file"
        "oras.land/oras/cmd/oras/internal/display/status"
        "oras.land/oras/cmd/oras/internal/fileref"
)

func loadFiles(ctx context.Context, store *file.Store, annotations map[string]map[string]string, fileRefs []string, displayStatus status.PushHandler) ([]ocispec.Descriptor, error) <span class="cov0" title="0">{
        var files []ocispec.Descriptor
        for _, fileRef := range fileRefs </span><span class="cov0" title="0">{
                filename, mediaType, err := fileref.Parse(fileRef, "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // get shortest absolute path as unique name
                <span class="cov0" title="0">name := filepath.Clean(filename)
                if !filepath.IsAbs(name) </span><span class="cov0" title="0">{
                        name = filepath.ToSlash(name)
                }</span>

                <span class="cov0" title="0">err = displayStatus.OnFileLoading(name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">file, err := addFile(ctx, store, name, mediaType, filename)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if value, ok := annotations[filename]; ok </span><span class="cov0" title="0">{
                        if file.Annotations == nil </span><span class="cov0" title="0">{
                                file.Annotations = value
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range value </span><span class="cov0" title="0">{
                                        file.Annotations[k] = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">files = append(files, file)</span>
        }
        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                if err := displayStatus.OnEmptyArtifact(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return files, nil</span>
}

func addFile(ctx context.Context, store *file.Store, name string, mediaType string, filename string) (ocispec.Descriptor, error) <span class="cov0" title="0">{
        file, err := store.Add(ctx, name, mediaType, filename)
        if err != nil </span><span class="cov0" title="0">{
                var pathErr *fs.PathError
                if errors.As(err, &amp;pathErr) </span><span class="cov0" title="0">{
                        err = pathErr
                }</span>
                <span class="cov0" title="0">return ocispec.Descriptor{}, err</span>
        }
        <span class="cov0" title="0">return file, nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package root

import (
        "errors"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/spf13/cobra"
        "golang.org/x/term"
        "oras.land/oras-go/v2/registry/remote/credentials"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/internal/credential"
        orasio "oras.land/oras/internal/io"
)

type loginOptions struct {
        option.Common
        option.Remote
        Hostname string
}

func loginCmd() *cobra.Command <span class="cov0" title="0">{
        var opts loginOptions
        cmd := &amp;cobra.Command{
                Use:   "login [flags] &lt;registry&gt;",
                Short: "Log in to a remote registry",
                Long: `Log in to a remote registry

Example - Log in with username and password from command line flags:
  oras login -u username -p password localhost:5000

Example - Log in with username and password from stdin:
  oras login -u username --password-stdin localhost:5000

Example - Log in with identity token from command line flags:
  oras login --identity-token token localhost:5000

Example - Log in with identity token from stdin:
  oras login --identity-token-stdin localhost:5000

Example - Log in with username and password in an interactive terminal:
  oras login localhost:5000

Example - Log in with username and password in an interactive terminal and no TLS check:
  oras login --insecure localhost:5000
`,
                Args: oerrors.CheckArgs(argument.Exactly(1), "the registry to log in to"),
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return option.Parse(cmd, &amp;opts)
                }</span>,
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        opts.Hostname = args[0]
                        return runLogin(cmd, opts)
                }</span>,
        }
        <span class="cov0" title="0">option.AddDeprecatedVerboseFlag(cmd.Flags())
        option.ApplyFlags(&amp;opts, cmd.Flags())
        return oerrors.Command(cmd, &amp;opts.Remote)</span>
}

func runLogin(cmd *cobra.Command, opts loginOptions) (err error) <span class="cov0" title="0">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)

        // prompt for credential
        if opts.Secret == "" </span><span class="cov0" title="0">{
                if opts.Username == "" </span><span class="cov0" title="0">{
                        // prompt for username
                        username, err := readLine(opts.Printer, "Username: ", false)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">opts.Username = strings.TrimSpace(username)</span>
                }
                <span class="cov0" title="0">if opts.Username == "" </span><span class="cov0" title="0">{
                        // prompt for token
                        if opts.Secret, err = readLine(opts.Printer, "Token: ", true); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span> else<span class="cov0" title="0"> if opts.Secret == "" </span><span class="cov0" title="0">{
                                return errors.New("token required")
                        }</span>
                } else<span class="cov0" title="0"> {
                        // prompt for password
                        if opts.Secret, err = readLine(opts.Printer, "Password: ", true); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span> else<span class="cov0" title="0"> if opts.Secret == "" </span><span class="cov0" title="0">{
                                return errors.New("password required")
                        }</span>
                }
        }

        <span class="cov0" title="0">store, err := credential.NewStore(opts.Configs...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">remote, err := opts.NewRegistry(opts.Hostname, opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err = credentials.Login(ctx, store, remote, opts.Credential()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_ = opts.Printer.Println("Login Succeeded")
        return nil</span>
}

func readLine(outWriter io.Writer, prompt string, silent bool) (string, error) <span class="cov0" title="0">{
        _, _ = fmt.Fprint(outWriter, prompt)
        fd := int(os.Stdin.Fd())
        var bytes []byte
        var err error
        if silent &amp;&amp; term.IsTerminal(fd) </span><span class="cov0" title="0">{
                if bytes, err = term.ReadPassword(fd); err == nil </span><span class="cov0" title="0">{
                        _, err = fmt.Fprintln(outWriter)
                }</span>
        } else<span class="cov0" title="0"> {
                bytes, err = orasio.ReadLine(os.Stdin)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(bytes), nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package root

import (
        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "oras.land/oras-go/v2/registry/remote/credentials"
        "oras.land/oras/cmd/oras/internal/argument"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/internal/credential"
)

type logoutOptions struct {
        hostname string

        debug   bool
        configs []string
}

func logoutCmd() *cobra.Command <span class="cov0" title="0">{
        var opts logoutOptions
        cmd := &amp;cobra.Command{
                Use:   "logout [flags] &lt;registry&gt;",
                Short: "Log out from a remote registry",
                Long: `Log out from a remote registry

Example - Logout:
  oras logout localhost:5000
`,
                Args: oerrors.CheckArgs(argument.Exactly(1), "the registry you want to log out"),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        opts.hostname = args[0]
                        return runLogout(cmd, opts)
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().BoolVarP(&amp;opts.debug, "debug", "d", false, "debug mode")
        cmd.Flags().StringArrayVarP(&amp;opts.configs, "registry-config", "", nil, "auth config path")
        return cmd</span>
}

func runLogout(cmd *cobra.Command, opts logoutOptions) error <span class="cov0" title="0">{
        ctx := cmd.Context()
        if opts.debug </span><span class="cov0" title="0">{
                logrus.SetLevel(logrus.DebugLevel)
        }</span>

        <span class="cov0" title="0">store, err := credential.NewStore(opts.configs...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return credentials.Logout(ctx, store, opts.hostname)</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package manifest

import (
        "github.com/spf13/cobra"
        "oras.land/oras/cmd/oras/root/manifest/index"
)

func Cmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "manifest [command]",
                Short: "Manifest operations",
        }

        cmd.AddCommand(
                deleteCmd(),
                fetchCmd(),
                fetchConfigCmd(),
                pushCmd(),
                index.Cmd(),
        )
        return cmd
}</span>
</pre>
		
		<pre class="file" id="file87" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package manifest

import (
        "errors"
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "oras.land/oras-go/v2/errdef"
        "oras.land/oras-go/v2/registry/remote/auth"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        "oras.land/oras/cmd/oras/internal/display"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/internal/registryutil"
)

type deleteOptions struct {
        option.Common
        option.Confirmation
        option.Descriptor
        option.Pretty
        option.Target
}

func deleteCmd() *cobra.Command <span class="cov0" title="0">{
        var opts deleteOptions
        cmd := &amp;cobra.Command{
                Use:     "delete [flags] &lt;name&gt;{:&lt;tag&gt;|@&lt;digest&gt;}",
                Aliases: []string{"remove", "rm"},
                Short:   "Delete a manifest from remote registry",
                Long: `Delete a manifest from remote registry

Example - Delete a manifest tagged with 'v1' from repository 'localhost:5000/hello':
  oras manifest delete localhost:5000/hello:v1

Example - Delete a manifest without prompting confirmation:
  oras manifest delete --force localhost:5000/hello:v1

Example - Delete a manifest and print its descriptor:
  oras manifest delete --descriptor localhost:5000/hello:v1

Example - Delete a manifest by digest 'sha256:99e4703fbf30916f549cd6bfa9cdbab614b5392fbe64fdee971359a77073cdf9' from repository 'localhost:5000/hello':
  oras manifest delete localhost:5000/hello@sha:99e4703fbf30916f549cd6bfa9cdbab614b5392fbe64fdee971359a77073cdf9
`,
                Args: oerrors.CheckArgs(argument.Exactly(1), "the manifest to delete"),
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        opts.RawReference = args[0]
                        if opts.OutputDescriptor &amp;&amp; !opts.Force </span><span class="cov0" title="0">{
                                return errors.New("must apply --force to confirm the deletion if the descriptor is outputted")
                        }</span>
                        <span class="cov0" title="0">return option.Parse(cmd, &amp;opts)</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        return deleteManifest(cmd, &amp;opts)
                }</span>,
        }

        <span class="cov0" title="0">opts.EnableDistributionSpecFlag()
        option.ApplyFlags(&amp;opts, cmd.Flags())
        option.AddDeprecatedVerboseFlag(cmd.Flags())
        return oerrors.Command(cmd, &amp;opts.Target)</span>
}

func deleteManifest(cmd *cobra.Command, opts *deleteOptions) error <span class="cov0" title="0">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)
        manifests, err := opts.NewManifestDeleter(opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := opts.EnsureReferenceNotEmpty(cmd, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">metadataHandler := display.NewManifestDeleteHandler(opts.Printer, &amp;opts.Target)

        // add both pull and delete scope hints for dst repository to save potential delete-scope token requests during deleting
        hints := []string{auth.ActionPull, auth.ActionDelete}
        if opts.ReferrersAPI == nil || !*opts.ReferrersAPI </span><span class="cov0" title="0">{
                // possibly needed when adding a new referrers index
                hints = append(hints, auth.ActionPush)
        }</span>
        <span class="cov0" title="0">ctx = registryutil.WithScopeHint(ctx, manifests, hints...)
        desc, err := manifests.Resolve(ctx, opts.Reference)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errdef.ErrNotFound) </span><span class="cov0" title="0">{
                        if opts.Force &amp;&amp; !opts.OutputDescriptor </span><span class="cov0" title="0">{
                                return metadataHandler.OnManifestMissing()
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("%s: the specified manifest does not exist", opts.RawReference)</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">prompt := fmt.Sprintf("Are you sure you want to delete the manifest %q and all tags associated with it?", desc.Digest)
        confirmed, err := opts.AskForConfirmation(os.Stdin, prompt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !confirmed </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err = manifests.Delete(ctx, desc); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete %s: %w", opts.RawReference, err)
        }</span>

        <span class="cov0" title="0">if opts.OutputDescriptor </span><span class="cov0" title="0">{
                descJSON, err := opts.Marshal(desc)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return opts.Output(os.Stdout, descJSON)</span>
        }
        <span class="cov0" title="0">return metadataHandler.OnManifestDeleted()</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package manifest

import (
        "fmt"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/spf13/cobra"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/registry/remote"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        "oras.land/oras/cmd/oras/internal/display"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
)

type fetchOptions struct {
        option.Cache
        option.Common
        option.Descriptor
        option.Platform
        option.Pretty
        option.Target
        option.Format

        mediaTypes []string
        outputPath string
}

func fetchCmd() *cobra.Command <span class="cov0" title="0">{
        var opts fetchOptions
        cmd := &amp;cobra.Command{
                Use:   "fetch [flags] &lt;name&gt;{:&lt;tag&gt;|@&lt;digest&gt;}",
                Short: "Fetch manifest of the target artifact",
                Long: `Fetch manifest of the target artifact

Example - Fetch raw manifest from a registry:
  oras manifest fetch localhost:5000/hello:v1

Example - Fetch the descriptor of a manifest from a registry:
  oras manifest fetch --descriptor localhost:5000/hello:v1

Example - [Experimental] Fetch the manifest digest from a registry similar to the resolve command:
  oras manifest fetch --format go-template --template '{{ .digest }}' localhost:5000/hello:v1

Example - [Experimental] Fetch manifest and output metadata encoded in JSON:
  oras manifest fetch localhost:5000/hello:v1 --format json

Example - Fetch manifest from a registry with specified media type:
  oras manifest fetch --media-type 'application/vnd.oci.image.manifest.v1+json' localhost:5000/hello:v1

Example - Fetch manifest from a registry with certain platform:
  oras manifest fetch --platform 'linux/arm/v5' localhost:5000/hello:v1

Example - Fetch manifest from a registry with prettified json result:
  oras manifest fetch --pretty localhost:5000/hello:v1

Example - Fetch raw manifest from an OCI image layout folder 'layout-dir':
  oras manifest fetch --oci-layout layout-dir:v1

Example - Fetch raw manifest from an OCI layout archive file 'layout.tar':
  oras manifest fetch --oci-layout layout.tar:v1

Example - Fetch raw manifest tagged 'example.com:v1' from an OCI image layout folder 'layout-dir':
  oras manifest fetch example.com:v1 --oci-layout-path layout-dir
`,
                Args: oerrors.CheckArgs(argument.Exactly(1), "the manifest to fetch"),
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        switch </span>{
                        case opts.outputPath == "-" &amp;&amp; opts.FormatFlag != option.FormatTypeText.Name:<span class="cov0" title="0">
                                return fmt.Errorf("`--output -` cannot be used with `--format %s` at the same time", opts.Template)</span>
                        case opts.outputPath == "-" &amp;&amp; opts.OutputDescriptor:<span class="cov0" title="0">
                                return fmt.Errorf("`--descriptor` cannot be used with `--output -` at the same time")</span>
                        }
                        <span class="cov0" title="0">if err := oerrors.CheckMutuallyExclusiveFlags(cmd.Flags(), "format", "pretty"); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := oerrors.CheckMutuallyExclusiveFlags(cmd.Flags(), "format", "descriptor"); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">opts.RawReference = args[0]
                        return option.Parse(cmd, &amp;opts)</span>
                },
                Aliases: []string{"get", "show"},
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        return fetchManifest(cmd, &amp;opts)
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().StringSliceVarP(&amp;opts.mediaTypes, "media-type", "", nil, "accepted media types")
        cmd.Flags().StringVarP(&amp;opts.outputPath, "output", "o", "", "file `path` to write the fetched manifest to, use - for stdout")
        opts.SetTypes(
                option.FormatTypeText,
                option.FormatTypeJSON.WithUsage("Print in prettified JSON format"),
                option.FormatTypeGoTemplate.WithUsage("Print using the given Go template"),
        )
        option.AddDeprecatedVerboseFlag(cmd.Flags())
        option.ApplyFlags(&amp;opts, cmd.Flags())
        return oerrors.Command(cmd, &amp;opts.Target)</span>
}

func fetchManifest(cmd *cobra.Command, opts *fetchOptions) (fetchErr error) <span class="cov8" title="1">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)
        metadataHandler, contentHandler, err := display.NewManifestFetchHandler(opts.Printer, opts.Format, opts.OutputDescriptor, opts.Pretty.Pretty, opts.outputPath)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">target, err := opts.NewReadonlyTarget(ctx, opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := opts.EnsureReferenceNotEmpty(cmd, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if repo, ok := target.(*remote.Repository); ok </span><span class="cov0" title="0">{
                repo.ManifestMediaTypes = opts.mediaTypes
        }</span> else<span class="cov0" title="0"> if opts.mediaTypes != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("`--media-type` cannot be used with `--oci-layout` at the same time")
        }</span>

        <span class="cov0" title="0">src, err := opts.CachedTarget(target)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var desc ocispec.Descriptor
        var content []byte
        if opts.OutputDescriptor &amp;&amp; opts.outputPath == "" </span><span class="cov0" title="0">{
                // fetch manifest descriptor only
                fetchOpts := oras.DefaultResolveOptions
                fetchOpts.TargetPlatform = opts.Platform.Platform
                desc, err = oras.Resolve(ctx, src, opts.Reference, fetchOpts)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find %q: %w", opts.RawReference, err)
                }</span>
        } else<span class="cov0" title="0"> {
                // fetch manifest descriptor and content
                fetchOpts := oras.DefaultFetchBytesOptions
                fetchOpts.TargetPlatform = opts.Platform.Platform
                desc, content, err = oras.FetchBytes(ctx, src, opts.Reference, fetchOpts)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to fetch the content of %q: %w", opts.RawReference, err)
                }</span>
                <span class="cov0" title="0">if err = contentHandler.OnContentFetched(desc, content); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return metadataHandler.OnFetched(opts.Path, desc, content)</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package manifest

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "os"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/spf13/cobra"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/content"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/internal/descriptor"
)

type fetchConfigOptions struct {
        option.Cache
        option.Common
        option.Descriptor
        option.Platform
        option.Pretty
        option.Target

        outputPath string
}

func fetchConfigCmd() *cobra.Command <span class="cov0" title="0">{
        var opts fetchConfigOptions
        cmd := &amp;cobra.Command{
                Use:     "fetch-config [flags] &lt;name&gt;{:&lt;tag&gt;|@&lt;digest&gt;}",
                Aliases: []string{"get-config"},
                Short:   "Fetch the config of a manifest from a registry or an OCI image layout",
                Long: `Fetch the config of a manifest from a registry or an OCI image layout

Example - Fetch the config:
  oras manifest fetch-config localhost:5000/hello:v1

Example - Fetch the config of certain platform:
  oras manifest fetch-config --platform 'linux/arm/v5' localhost:5000/hello:v1

Example - Fetch and print the prettified config:
  oras manifest fetch-config --pretty localhost:5000/hello:v1

Example - Fetch the config and save it to a local file:
  oras manifest fetch-config --output config.json localhost:5000/hello:v1

Example - Fetch the descriptor of the config:
  oras manifest fetch-config --descriptor localhost:5000/hello:v1

Example - Fetch and print the prettified descriptor of the config:
  oras manifest fetch-config --descriptor --pretty localhost:5000/hello:v1
`,
                Args: oerrors.CheckArgs(argument.Exactly(1), "the manifest config to fetch"),
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if opts.outputPath == "-" &amp;&amp; opts.OutputDescriptor </span><span class="cov0" title="0">{
                                return errors.New("`--output -` cannot be used with `--descriptor` at the same time")
                        }</span>
                        <span class="cov0" title="0">opts.RawReference = args[0]
                        return option.Parse(cmd, &amp;opts)</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        return fetchConfig(cmd, &amp;opts)
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;opts.outputPath, "output", "o", "", "file `path` to write the fetched config to, use - for stdout")
        option.AddDeprecatedVerboseFlag(cmd.Flags())
        option.ApplyFlags(&amp;opts, cmd.Flags())
        return oerrors.Command(cmd, &amp;opts.Target)</span>
}

func fetchConfig(cmd *cobra.Command, opts *fetchConfigOptions) (fetchErr error) <span class="cov0" title="0">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)

        repo, err := opts.NewReadonlyTarget(ctx, opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := opts.EnsureReferenceNotEmpty(cmd, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">src, err := opts.CachedTarget(repo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // fetch config descriptor
        <span class="cov0" title="0">configDesc, err := fetchConfigDesc(ctx, src, opts.Reference, opts.Platform.Platform)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !opts.OutputDescriptor || opts.outputPath != "" </span><span class="cov0" title="0">{
                // fetch config content
                contentBytes, err := content.FetchAll(ctx, src, configDesc)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if opts.outputPath == "" || opts.outputPath == "-" </span><span class="cov0" title="0">{
                        // output config content
                        return opts.Output(os.Stdout, contentBytes)
                }</span>

                // save config into the local file if the output path is provided
                <span class="cov0" title="0">if err = os.WriteFile(opts.outputPath, contentBytes, 0666); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if opts.OutputDescriptor </span><span class="cov0" title="0">{
                // output config's descriptor
                descBytes, err := json.Marshal(configDesc)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return opts.Output(os.Stdout, descBytes)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func fetchConfigDesc(ctx context.Context, src oras.ReadOnlyTarget, reference string, targetPlatform *ocispec.Platform) (ocispec.Descriptor, error) <span class="cov0" title="0">{
        // fetch manifest descriptor and content
        fetchOpts := oras.DefaultFetchBytesOptions
        fetchOpts.TargetPlatform = targetPlatform
        manifestDesc, manifestContent, err := oras.FetchBytes(ctx, src, reference, fetchOpts)
        if err != nil </span><span class="cov0" title="0">{
                return ocispec.Descriptor{}, err
        }</span>

        <span class="cov0" title="0">if !descriptor.IsImageManifest(manifestDesc) </span><span class="cov0" title="0">{
                return ocispec.Descriptor{}, fmt.Errorf("%q is not an image manifest and does not have a config", manifestDesc.Digest)
        }</span>

        // unmarshal manifest content to extract config descriptor
        <span class="cov0" title="0">var manifest ocispec.Manifest
        if err := json.Unmarshal(manifestContent, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                return ocispec.Descriptor{}, err
        }</span>
        <span class="cov0" title="0">return manifest.Config, nil</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package index

import (
        "github.com/spf13/cobra"
)

func Cmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "index [command]",
                Short: "[Experimental] Index operations",
        }

        cmd.AddCommand(
                createCmd(),
                updateCmd(),
        )
        return cmd
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package index

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/opencontainers/image-spec/specs-go"
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/spf13/cobra"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/content"
        "oras.land/oras-go/v2/errdef"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        "oras.land/oras/cmd/oras/internal/display"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/display/status"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/internal/contentutil"
        "oras.land/oras/internal/descriptor"
        "oras.land/oras/internal/listener"
)

var maxConfigSize int64 = 4 * 1024 * 1024 // 4 MiB

type createOptions struct {
        option.Common
        option.Target
        option.Pretty
        option.Annotation

        sources    []string
        extraRefs  []string
        outputPath string
}

func createCmd() *cobra.Command <span class="cov0" title="0">{
        var opts createOptions
        cmd := &amp;cobra.Command{
                Use:   "create [flags] &lt;target&gt;[:&lt;tag[,&lt;tag&gt;][...]] &lt;sources&gt;[{&lt;tag&gt;|&lt;digest&gt;}...]",
                Short: "[Experimental] Create and push an index from provided manifests",
                Long: `[Experimental] Create and push an index from provided manifests. All manifests should be in the same repository

Example - Create an index from source manifests tagged 'linux-amd64' and 'linux-arm64', and push without tagging:
  oras manifest index create localhost:5000/hello linux-amd64 linux-arm64

Example - Create an index from source manifests tagged 'linux-amd64' and 'linux-arm64', and push with the tag 'v1':
  oras manifest index create localhost:5000/hello:v1 linux-amd64 linux-arm64

Example - Create an index from source manifests using both tags and digests, and push with tag 'v1':
  oras manifest index create localhost:5000/hello:v1 linux-amd64 sha256:99e4703fbf30916f549cd6bfa9cdbab614b5392fbe64fdee971359a77073cdf9

Example - Create an index and push it with multiple tags:
  oras manifest index create localhost:5000/hello:tag1,tag2,tag3 linux-amd64 linux-arm64 sha256:99e4703fbf30916f549cd6bfa9cdbab614b5392fbe64fdee971359a77073cdf9

Example - Create and push an index with annotations:
  oras manifest index create localhost:5000/hello:v1 linux-amd64 --annotation "key=val"

Example - Create an index and push to an OCI image layout folder 'layout-dir' and tag with 'v1':
  oras manifest index create layout-dir:v1 linux-amd64 sha256:99e4703fbf30916f549cd6bfa9cdbab614b5392fbe64fdee971359a77073cdf9 --oci-layout
  
Example - Create an index and save it locally to index.json, auto push will be disabled:
  oras manifest index create localhost:5000/hello linux-amd64 linux-arm64 --output index.json

Example - Create an index and output the index to stdout, auto push will be disabled:
  oras manifest index create localhost:5000/hello linux-arm64 --output - --pretty
`,
                Args: oerrors.CheckArgs(argument.AtLeast(1), "the destination index to create."),
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        refs := strings.Split(args[0], ",")
                        opts.RawReference = refs[0]
                        opts.extraRefs = refs[1:]
                        opts.sources = args[1:]
                        return option.Parse(cmd, &amp;opts)
                }</span>,
                Aliases: []string{"pack"},
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        return createIndex(cmd, opts)
                }</span>,
        }
        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;opts.outputPath, "output", "o", "", "file `path` to write the created index to, use - for stdout")
        option.ApplyFlags(&amp;opts, cmd.Flags())
        return oerrors.Command(cmd, &amp;opts.Target)</span>
}

func createIndex(cmd *cobra.Command, opts createOptions) error <span class="cov0" title="0">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)
        target, err := opts.NewTarget(opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">displayStatus, displayMetadata, displayContent := display.NewManifestIndexCreateHandler(opts.outputPath, opts.Printer, opts.Pretty.Pretty)
        manifests, err := fetchSourceManifests(ctx, displayStatus, target, opts.sources)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">index := ocispec.Index{
                Versioned: specs.Versioned{
                        SchemaVersion: 2,
                },
                MediaType:   ocispec.MediaTypeImageIndex,
                Manifests:   manifests,
                Annotations: opts.Annotations[option.AnnotationManifest],
        }
        indexBytes, err := json.Marshal(index)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">desc := content.NewDescriptorFromBytes(ocispec.MediaTypeImageIndex, indexBytes)
        if err := displayStatus.OnIndexPacked(desc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := displayContent.OnContentCreated(indexBytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if opts.outputPath == "" </span><span class="cov0" title="0">{
                if err := pushIndex(ctx, displayStatus, displayMetadata, target, desc, indexBytes, opts.Reference, opts.extraRefs, opts.GetDisplayReference()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">displayMetadata.OnIndexCreated(desc)
        return displayMetadata.Render()</span>
}

func fetchSourceManifests(ctx context.Context, displayStatus status.ManifestIndexCreateHandler, target oras.ReadOnlyTarget, sources []string) ([]ocispec.Descriptor, error) <span class="cov10" title="3">{
        resolved := []ocispec.Descriptor{}
        for _, source := range sources </span><span class="cov10" title="3">{
                if err := displayStatus.OnFetching(source); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov6" title="2">desc, content, err := oras.FetchBytes(ctx, target, source, oras.DefaultFetchBytesOptions)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("could not find the manifest %s: %w", source, err)
                }</span>
                <span class="cov6" title="2">if !descriptor.IsManifest(desc) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s is not a manifest", source)
                }</span>
                <span class="cov6" title="2">if err := displayStatus.OnFetched(source, desc); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">if desc, err = enrichDescriptor(ctx, target, desc, content); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">resolved = append(resolved, desc)</span>
        }
        <span class="cov0" title="0">return resolved, nil</span>
}

func getPlatform(ctx context.Context, target oras.ReadOnlyTarget, manifestBytes []byte) (*ocispec.Platform, error) <span class="cov1" title="1">{
        // extract config descriptor
        var manifest ocispec.Manifest
        if err := json.Unmarshal(manifestBytes, &amp;manifest); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        // if config size is larger than 4 MiB, discontinue the fetch
        <span class="cov0" title="0">if manifest.Config.Size &gt; maxConfigSize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config size %v exceeds MaxBytes %v: %w", manifest.Config.Size, maxConfigSize, errdef.ErrSizeExceedsLimit)
        }</span>
        // fetch config content
        <span class="cov0" title="0">contentBytes, err := content.FetchAll(ctx, target, manifest.Config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var platform ocispec.Platform
        if err := json.Unmarshal(contentBytes, &amp;platform); err != nil || (platform.Architecture == "" &amp;&amp; platform.OS == "") </span><span class="cov0" title="0">{
                // ignore if the manifest does not have platform information
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;platform, nil</span>
}

func pushIndex(ctx context.Context, displayStatus status.ManifestIndexCreateHandler, taggedHandler metadata.TaggedHandler,
        target oras.Target, desc ocispec.Descriptor, content []byte, ref string, extraRefs []string, path string) error <span class="cov0" title="0">{
        // push the index
        var err error
        if ref == "" || contentutil.IsDigest(ref) </span><span class="cov0" title="0">{
                err = target.Push(ctx, desc, bytes.NewReader(content))
        }</span> else<span class="cov0" title="0"> {
                _, err = oras.TagBytes(ctx, target, desc.MediaType, content, ref)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := displayStatus.OnIndexPushed(path); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(extraRefs) != 0 </span><span class="cov0" title="0">{
                tagListener := listener.NewTaggedListener(target, taggedHandler.OnTagged)
                if _, err = oras.TagBytesN(ctx, tagListener, desc.MediaType, content, extraRefs, oras.DefaultTagBytesNOptions); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func enrichDescriptor(ctx context.Context, target oras.ReadOnlyTarget, desc ocispec.Descriptor, manifestBytes []byte) (ocispec.Descriptor, error) <span class="cov1" title="1">{
        desc = descriptor.Plain(desc)
        if descriptor.IsImageManifest(desc) </span><span class="cov1" title="1">{
                var err error
                desc.Platform, err = getPlatform(ctx, target, manifestBytes)
                if err != nil </span><span class="cov1" title="1">{
                        return ocispec.Descriptor{}, err
                }</span>
        }
        <span class="cov0" title="0">return desc, nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package index

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/opencontainers/go-digest"
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/content"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        "oras.land/oras/cmd/oras/internal/display"
        "oras.land/oras/cmd/oras/internal/display/status"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/internal/contentutil"
        "oras.land/oras/internal/descriptor"
)

type updateOptions struct {
        option.Common
        option.Target
        option.Pretty

        addArguments    []string
        mergeArguments  []string
        removeArguments []string
        tags            []string
        outputPath      string
}

func updateCmd() *cobra.Command <span class="cov0" title="0">{
        var opts updateOptions
        cmd := &amp;cobra.Command{
                Use:   "update &lt;index&gt;{:&lt;tag&gt;|@&lt;digest&gt;} [{--add|--merge|--remove} &lt;manifest&gt;{&lt;tag&gt;|&lt;digest&gt;}] [...]",
                Short: "[Experimental] Update and push an image index",
                Long: `[Experimental] Update and push an image index. All manifests should be in the same repository
                
Example - Remove a manifest and add two manifests from an index tagged 'v1'. The tag will point to the updated index:
  oras manifest index update localhost:5000/hello:v1 --add linux-amd64 --add linux-arm64 --remove sha256:99e4703fbf30916f549cd6bfa9cdbab614b5392fbe64fdee971359a77073cdf9

Example - Create a new index by updating an existing index specified by its digest:
  oras manifest index update localhost:5000/hello@sha256:99e4703fbf30916f549cd6bfa9cdbab614b5392fbe64fdee971359a77073cdf9 --add linux-amd64 --remove sha256:fd6ed2f36b5465244d5dc86cb4e7df0ab8a9d24adc57825099f522fe009a22bb

Example - Merge manifests from the index 'v2-windows' to the index 'v2':
  oras manifest index update localhost:5000/hello:v2 --merge v2-windows

Example - Update an index and tag the updated index as 'v2.1.0' and 'v2':
  oras manifest index update localhost:5000/hello@sha256:99e4703fbf30916f549cd6bfa9cdbab614b5392fbe64fdee971359a77073cdf9 --add linux-amd64 --tag "v2.1.0" --tag "v2"

Example - Update an index and push to an OCI image layout folder 'layout-dir' and tag with 'v2':
  oras manifest index update layout-dir@99e4703fbf30916f549cd6bfa9cdbab614b5392fbe64fdee971359a77073cdf9 --add linux-arm64 --tag "v2" --oci-layout

Example - Update an index and save it locally to index.json, auto push will be disabled:
  oras manifest index update localhost:5000/hello:v2 --add v2-linux-amd64 --output index.json

Example - Update an index and output the index to stdout, auto push will be disabled:
  oras manifest index update localhost:5000/hello:v2 --remove sha256:99e4703fbf30916f549cd6bfa9cdbab614b5392fbe64fdee971359a77073cdf9 --output - --pretty
  `,
                Args: oerrors.CheckArgs(argument.Exactly(1), "the target index to update"),
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if err := oerrors.CheckMutuallyExclusiveFlags(cmd.Flags(), "tag", "output"); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">opts.RawReference = args[0]
                        for _, manifestRef := range opts.removeArguments </span><span class="cov0" title="0">{
                                if !contentutil.IsDigest(manifestRef) </span><span class="cov0" title="0">{
                                        return fmt.Errorf("remove: %s is not a digest", manifestRef)
                                }</span>
                        }
                        <span class="cov0" title="0">return option.Parse(cmd, &amp;opts)</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        return updateIndex(cmd, opts)
                }</span>,
        }
        <span class="cov0" title="0">option.ApplyFlags(&amp;opts, cmd.Flags())
        cmd.Flags().StringArrayVarP(&amp;opts.addArguments, "add", "", nil, "manifests to add to the index")
        cmd.Flags().StringArrayVarP(&amp;opts.mergeArguments, "merge", "", nil, "indexes to be merged into the index")
        cmd.Flags().StringArrayVarP(&amp;opts.removeArguments, "remove", "", nil, "manifests to remove from the index, must be digests")
        cmd.Flags().StringArrayVarP(&amp;opts.tags, "tag", "", nil, "extra tags for the updated index")
        cmd.Flags().StringVarP(&amp;opts.outputPath, "output", "o", "", "file `path` to write the created index to, use - for stdout")
        return oerrors.Command(cmd, &amp;opts.Target)</span>
}

func updateIndex(cmd *cobra.Command, opts updateOptions) error <span class="cov0" title="0">{
        // if no update flag is used, do nothing
        if !updateFlagsUsed(cmd.Flags()) </span><span class="cov0" title="0">{
                _ = opts.Printer.Println("Nothing to update as no change is requested")
                return nil
        }</span>
        <span class="cov0" title="0">ctx, logger := command.GetLogger(cmd, &amp;opts.Common)
        target, err := opts.NewTarget(opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := opts.EnsureReferenceNotEmpty(cmd, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">displayStatus, displayMetadata, displayContent := display.NewManifestIndexUpdateHandler(opts.outputPath, opts.Printer, opts.Pretty.Pretty)
        index, err := fetchIndex(ctx, displayStatus, target, opts.Reference)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">manifests, err := removeManifests(displayStatus, index.Manifests, target, opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">manifests, err = addManifests(ctx, displayStatus, manifests, target, opts.addArguments)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">manifests, err = mergeIndexes(ctx, displayStatus, manifests, target, opts.mergeArguments)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">index.Manifests = manifests
        indexBytes, err := json.Marshal(index)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">desc := content.NewDescriptorFromBytes(index.MediaType, indexBytes)
        if err := displayStatus.OnIndexPacked(desc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">path := getPushPath(opts.RawReference, opts.Type, opts.Reference, opts.Path)
        if err := displayContent.OnContentCreated(indexBytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if opts.outputPath == "" </span><span class="cov0" title="0">{
                if err := pushIndex(ctx, displayStatus, displayMetadata, target, desc, indexBytes, opts.Reference, opts.tags, path); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">displayMetadata.OnIndexCreated(desc)
        return displayMetadata.Render()</span>
}

func fetchIndex(ctx context.Context, handler status.ManifestIndexUpdateHandler, target oras.ReadOnlyTarget, reference string) (ocispec.Index, error) <span class="cov4" title="3">{
        if err := handler.OnFetching(reference); err != nil </span><span class="cov1" title="1">{
                return ocispec.Index{}, err
        }</span>
        <span class="cov2" title="2">desc, content, err := oras.FetchBytes(ctx, target, reference, oras.DefaultFetchBytesOptions)
        if err != nil </span><span class="cov0" title="0">{
                return ocispec.Index{}, fmt.Errorf("could not find the index %s: %w", reference, err)
        }</span>
        <span class="cov2" title="2">if !descriptor.IsIndex(desc) </span><span class="cov0" title="0">{
                return ocispec.Index{}, fmt.Errorf("%s is not an index", reference)
        }</span>
        <span class="cov2" title="2">if err := handler.OnFetched(reference, desc); err != nil </span><span class="cov1" title="1">{
                return ocispec.Index{}, err
        }</span>
        <span class="cov1" title="1">var index ocispec.Index
        if err := json.Unmarshal(content, &amp;index); err != nil </span><span class="cov1" title="1">{
                return ocispec.Index{}, err
        }</span>
        <span class="cov0" title="0">return index, nil</span>
}

func addManifests(ctx context.Context, displayStatus status.ManifestIndexUpdateHandler, manifests []ocispec.Descriptor, target oras.ReadOnlyTarget, addArguments []string) ([]ocispec.Descriptor, error) <span class="cov0" title="0">{
        for _, manifestRef := range addArguments </span><span class="cov0" title="0">{
                if err := displayStatus.OnFetching(manifestRef); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">desc, content, err := oras.FetchBytes(ctx, target, manifestRef, oras.DefaultFetchBytesOptions)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("could not find the manifest %s: %w", manifestRef, err)
                }</span>
                <span class="cov0" title="0">if !descriptor.IsManifest(desc) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s is not a manifest", manifestRef)
                }</span>
                <span class="cov0" title="0">if err := displayStatus.OnFetched(manifestRef, desc); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if desc, err = enrichDescriptor(ctx, target, desc, content); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">manifests = append(manifests, desc)
                if err := displayStatus.OnManifestAdded(manifestRef, desc); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return manifests, nil</span>
}

func mergeIndexes(ctx context.Context, displayStatus status.ManifestIndexUpdateHandler, manifests []ocispec.Descriptor, target oras.ReadOnlyTarget, mergeArguments []string) ([]ocispec.Descriptor, error) <span class="cov4" title="3">{
        for _, indexRef := range mergeArguments </span><span class="cov4" title="3">{
                if err := displayStatus.OnFetching(indexRef); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov2" title="2">desc, content, err := oras.FetchBytes(ctx, target, indexRef, oras.DefaultFetchBytesOptions)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("could not find the index %s: %w", indexRef, err)
                }</span>
                <span class="cov2" title="2">if !descriptor.IsIndex(desc) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s is not an index", indexRef)
                }</span>
                <span class="cov2" title="2">if err := displayStatus.OnFetched(indexRef, desc); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">var index ocispec.Index
                if err := json.Unmarshal(content, &amp;index); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">manifests = append(manifests, index.Manifests...)
                if err := displayStatus.OnIndexMerged(indexRef, desc); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return manifests, nil</span>
}

func removeManifests(handler status.ManifestIndexUpdateHandler, manifests []ocispec.Descriptor, target oras.ReadOnlyTarget, opts updateOptions) ([]ocispec.Descriptor, error) <span class="cov0" title="0">{
        // create a set of digests to speed up the remove
        digestToRemove := make(map[digest.Digest]bool)
        for _, manifestRef := range opts.removeArguments </span><span class="cov0" title="0">{
                digestToRemove[digest.Digest(manifestRef)] = false
        }</span>
        <span class="cov0" title="0">return doRemoveManifests(manifests, digestToRemove, handler, opts.Reference)</span>
}

func doRemoveManifests(originalManifests []ocispec.Descriptor, digestToRemove map[digest.Digest]bool, handler status.ManifestIndexUpdateHandler, indexRef string) ([]ocispec.Descriptor, error) <span class="cov6" title="7">{
        manifests := []ocispec.Descriptor{}
        for _, m := range originalManifests </span><span class="cov10" title="26">{
                if _, exists := digestToRemove[m.Digest]; exists </span><span class="cov8" title="14">{
                        digestToRemove[m.Digest] = true
                }</span> else<span class="cov7" title="12"> {
                        manifests = append(manifests, m)
                }</span>
        }
        <span class="cov6" title="7">for digest, removed := range digestToRemove </span><span class="cov7" title="9">{
                if !removed </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("%s does not exist in the index %s", digest, indexRef)
                }</span>
                <span class="cov6" title="8">if err := handler.OnManifestRemoved(digest); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov5" title="5">return manifests, nil</span>
}

func updateFlagsUsed(flags *pflag.FlagSet) bool <span class="cov0" title="0">{
        return flags.Changed("add") || flags.Changed("remove") || flags.Changed("merge")
}</span>

func getPushPath(rawReference string, targetType string, reference string, path string) string <span class="cov0" title="0">{
        if contentutil.IsDigest(reference) </span><span class="cov0" title="0">{
                return fmt.Sprintf("[%s] %s", targetType, path)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("[%s] %s", targetType, rawReference)</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package manifest

import (
        "context"
        "errors"
        "fmt"
        "os"
        "strings"

        digest "github.com/opencontainers/go-digest"
        "github.com/spf13/cobra"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/content"
        "oras.land/oras-go/v2/errdef"
        "oras.land/oras-go/v2/registry/remote"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        "oras.land/oras/cmd/oras/internal/display"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/manifest"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/internal/file"
        "oras.land/oras/internal/listener"
)

type pushOptions struct {
        option.Common
        option.Descriptor
        option.Pretty
        option.Target

        concurrency int
        extraRefs   []string
        fileRef     string
        mediaType   string
        // Deprecated: verbose is deprecated and will be removed in the future.
        verbose bool
}

func pushCmd() *cobra.Command <span class="cov0" title="0">{
        var opts pushOptions
        cmd := &amp;cobra.Command{
                Use:   "push [flags] &lt;name&gt;[:&lt;tag&gt;[,&lt;tag&gt;][...]|@&lt;digest&gt;] &lt;file&gt;",
                Short: "Push a manifest to a registry or an OCI image layout",
                Long: `Push a manifest to a registry or an OCI image layout

Example - Push a manifest to repository 'localhost:5000/hello' and tag with 'v1':
  oras manifest push localhost:5000/hello:v1 manifest.json

Example - Push a manifest using a specific method for the Referrers API:
  oras manifest push --distribution-spec v1.1-referrers-api localhost:5000/hello:v1 manifest.json
  oras manifest push --distribution-spec v1.1-referrers-tag localhost:5000/hello:v1 manifest.json

Example - Push a manifest with content read from stdin:
  oras manifest push localhost:5000/hello:v1 -

Example - Push a manifest and output its descriptor:
  oras manifest push --descriptor localhost:5000/hello:v1 manifest.json

Example - Push a manifest to repository 'localhost:5000/hello' and output the prettified descriptor:
  oras manifest push --descriptor --pretty localhost:5000/hello manifest.json

Example - Push a manifest with specified media type to repository 'localhost:5000/hello' and tag with 'v1':
  oras manifest push --media-type application/vnd.cncf.oras.artifact.manifest.v1+json localhost:5000/hello:v1 oras_manifest.json

Example - Push a manifest to repository 'localhost:5000/hello' and tag with 'tag1', 'tag2', 'tag3':
  oras manifest push localhost:5000/hello:tag1,tag2,tag3 manifest.json

Example - Push a manifest to repository 'localhost:5000/hello' and tag with 'tag1', 'tag2', 'tag3' and concurrency level tuned:
  oras manifest push --concurrency 6 localhost:5000/hello:tag1,tag2,tag3 manifest.json

Example - Push a manifest to an OCI image layout folder 'layout-dir' and tag with 'v1':
  oras manifest push --oci-layout layout-dir:v1 manifest.json

Example - Push a manifest to an OCI image layout folder 'layout-dir' and tag with 'example.com:v1':
  oras manifest push example.com:v1 manifest.json --oci-layout-path layout-dir
`,
                Args: oerrors.CheckArgs(argument.Exactly(2), "the destination to push to and the file to read manifest content from"),
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        opts.fileRef = args[1]
                        if opts.fileRef == "-" </span><span class="cov0" title="0">{
                                if err := option.CheckStdinConflict(cmd.Flags()); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">refs := strings.Split(args[0], ",")
                        opts.RawReference = refs[0]
                        opts.extraRefs = refs[1:]
                        return option.Parse(cmd, &amp;opts)</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        opts.Printer.Verbose = opts.verbose
                        return pushManifest(cmd, opts)
                }</span>,
        }

        <span class="cov0" title="0">opts.EnableDistributionSpecFlag()
        option.ApplyFlags(&amp;opts, cmd.Flags())
        cmd.Flags().StringVarP(&amp;opts.mediaType, "media-type", "", "", "media type of manifest")
        cmd.Flags().IntVarP(&amp;opts.concurrency, "concurrency", "", 5, "concurrency level")
        cmd.Flags().BoolVarP(&amp;opts.verbose, "verbose", "v", true, "print status output for unnamed blobs")
        _ = cmd.Flags().MarkDeprecated("verbose", "and will be removed in a future release.")
        return oerrors.Command(cmd, &amp;opts.Target)</span>
}

func pushManifest(cmd *cobra.Command, opts pushOptions) error <span class="cov0" title="0">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)
        var target oras.Target
        var err error
        target, err = opts.NewTarget(opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if repo, ok := target.(*remote.Repository); ok </span><span class="cov0" title="0">{
                target = repo.Manifests()
        }</span>

        // prepare manifest content
        <span class="cov0" title="0">contentBytes, err := file.PrepareManifestContent(opts.fileRef)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // get manifest media type
        <span class="cov0" title="0">mediaType := opts.mediaType
        if opts.mediaType == "" </span><span class="cov0" title="0">{
                mediaType, err = manifest.ExtractMediaType(contentBytes)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, manifest.ErrMediaTypeNotFound) </span><span class="cov0" title="0">{
                                return &amp;oerrors.Error{
                                        Err:            fmt.Errorf(`%w via the flag "--media-type" nor in %q`, err, opts.fileRef),
                                        Usage:          fmt.Sprintf("%s %s", cmd.Parent().CommandPath(), cmd.Use),
                                        Recommendation: `Please specify a valid media type in the manifest JSON or via the "--media-type" flag`,
                                }
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }

        // prepare manifest descriptor
        <span class="cov0" title="0">desc := content.NewDescriptorFromBytes(mediaType, contentBytes)
        statusHandler, metadataHandler := display.NewManifestPushHandler(opts.Printer, opts.OutputDescriptor, opts.Pretty.Pretty, desc, &amp;opts.Target)

        ref := opts.Reference
        if ref == "" </span><span class="cov0" title="0">{
                ref = desc.Digest.String()
        }</span>
        <span class="cov0" title="0">match, err := matchDigest(ctx, target, ref, desc.Digest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if match </span><span class="cov0" title="0">{
                if err := statusHandler.OnManifestPushSkipped(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                if err = statusHandler.OnManifestPushing(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, err := oras.TagBytes(ctx, target, mediaType, contentBytes, ref); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err = statusHandler.OnManifestPushed(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">tagBytesNOpts := oras.DefaultTagBytesNOptions
        tagBytesNOpts.Concurrency = opts.concurrency

        // outputs manifest's descriptor
        if opts.OutputDescriptor </span><span class="cov0" title="0">{
                if len(opts.extraRefs) != 0 </span><span class="cov0" title="0">{
                        if _, err = oras.TagBytesN(ctx, target, mediaType, contentBytes, opts.extraRefs, tagBytesNOpts); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">descJSON, err := opts.Marshal(desc)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return opts.Output(os.Stdout, descJSON)</span>
        }
        <span class="cov0" title="0">if err := metadataHandler.OnManifestPushed(desc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(opts.extraRefs) != 0 </span><span class="cov0" title="0">{
                tagListener := listener.NewTaggedListener(target, metadataHandler.OnTagged)
                if _, err = oras.TagBytesN(ctx, tagListener, mediaType, contentBytes, opts.extraRefs, tagBytesNOpts); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return metadataHandler.Render()</span>
}

// matchDigest checks whether the manifest's digest matches to it in the remote
// repository.
func matchDigest(ctx context.Context, resolver content.Resolver, reference string, digest digest.Digest) (bool, error) <span class="cov0" title="0">{
        got, err := resolver.Resolve(ctx, reference)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errdef.ErrNotFound) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov0" title="0">return got.Digest == digest, nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package root

import (
        "context"
        "errors"
        "fmt"
        "io"
        "sync"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/spf13/cobra"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/content"
        "oras.land/oras-go/v2/content/file"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        "oras.land/oras/cmd/oras/internal/display"
        "oras.land/oras/cmd/oras/internal/display/metadata"
        "oras.land/oras/cmd/oras/internal/display/status"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/fileref"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/internal/descriptor"
        "oras.land/oras/internal/graph"
)

type pullOptions struct {
        option.Cache
        option.Common
        option.Platform
        option.Target
        option.Format
        option.Terminal

        concurrency       int
        KeepOldFiles      bool
        IncludeSubject    bool
        PathTraversal     bool
        Output            string
        ManifestConfigRef string
        // Deprecated: verbose is deprecated and will be removed in the future.
        verbose bool
}

func pullCmd() *cobra.Command <span class="cov0" title="0">{
        var opts pullOptions
        cmd := &amp;cobra.Command{
                Use:   "pull [flags] &lt;name&gt;{:&lt;tag&gt;|@&lt;digest&gt;}",
                Short: "Pull files from a registry or an OCI image layout",
                Long: `Pull files from a registry or an OCI image layout

Example - Pull artifact files from a registry:
  oras pull localhost:5000/hello:v1

Example - Recursively pulling all files from a registry, including subjects of hello:v1:
  oras pull --include-subject localhost:5000/hello:v1

Example - Pull files from an insecure registry:
  oras pull --insecure localhost:5000/hello:v1

Example - Pull files from the HTTP registry:
  oras pull --plain-http localhost:5000/hello:v1

Example - Pull files from a registry with local cache:
  export ORAS_CACHE=~/.oras/cache
  oras pull localhost:5000/hello:v1

Example - Pull files from a registry with certain platform:
  oras pull --platform linux/arm/v5 localhost:5000/hello:v1

Example - Pull all files with concurrency level tuned:
  oras pull --concurrency 6 localhost:5000/hello:v1

Example - [Experimental] Pull files and format output in JSON:
  oras pull localhost:5000/hello:v1 --format json

Example - [Experimental] Pull files and format output with Go template:
  oras pull localhost:5000/hello:v1 --format go-template="{{.reference}}"

Example - Pull artifact files from an OCI image layout folder 'layout-dir':
  oras pull --oci-layout layout-dir:v1

Example - Pull artifact files from an OCI layout archive 'layout.tar':
  oras pull --oci-layout layout.tar:v1

Example - Pull artifact files tagged 'example.com:v1' from an OCI image layout folder 'layout-dir':
  oras pull example.com:v1 --oci-layout-path layout-dir
`,
                Args: oerrors.CheckArgs(argument.Exactly(1), "the artifact reference you want to pull"),
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        opts.RawReference = args[0]
                        err := option.Parse(cmd, &amp;opts)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">opts.DisableTTY(opts.Debug, false)
                        return nil</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        opts.Printer.Verbose = opts.verbose
                        return runPull(cmd, &amp;opts)
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().BoolVarP(&amp;opts.KeepOldFiles, "keep-old-files", "k", false, "do not replace existing files when pulling, treat them as errors")
        cmd.Flags().BoolVarP(&amp;opts.PathTraversal, "allow-path-traversal", "T", false, "allow storing files out of the output directory")
        cmd.Flags().BoolVarP(&amp;opts.IncludeSubject, "include-subject", "", false, "[Preview] recursively pull the subject of artifacts")
        cmd.Flags().StringVarP(&amp;opts.Output, "output", "o", ".", "output directory")
        cmd.Flags().StringVarP(&amp;opts.ManifestConfigRef, "config", "", "", "output manifest config file")
        cmd.Flags().IntVarP(&amp;opts.concurrency, "concurrency", "", 3, "concurrency level")
        cmd.Flags().BoolVarP(&amp;opts.verbose, "verbose", "v", true, "print status output for unnamed blobs")
        _ = cmd.Flags().MarkDeprecated("verbose", "and will be removed in a future release.")
        opts.SetTypes(option.FormatTypeText, option.FormatTypeJSON, option.FormatTypeGoTemplate)
        option.ApplyFlags(&amp;opts, cmd.Flags())
        return oerrors.Command(cmd, &amp;opts.Target)</span>
}

func runPull(cmd *cobra.Command, opts *pullOptions) (pullError error) <span class="cov8" title="1">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)
        statusHandler, metadataHandler, err := display.NewPullHandler(opts.Printer, opts.Format, opts.Path, opts.TTY)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Copy Options
        <span class="cov0" title="0">copyOptions := oras.DefaultCopyOptions
        copyOptions.Concurrency = opts.concurrency
        if opts.Platform.Platform != nil </span><span class="cov0" title="0">{
                copyOptions.WithTargetPlatform(opts.Platform.Platform)
        }</span>
        <span class="cov0" title="0">target, err := opts.NewReadonlyTarget(ctx, opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := opts.EnsureReferenceNotEmpty(cmd, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">src, err := opts.CachedTarget(target)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">dst, err := file.New(opts.Output)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := dst.Close(); pullError == nil </span><span class="cov0" title="0">{
                        pullError = err
                }</span>
        }()
        <span class="cov0" title="0">dst.AllowPathTraversalOnWrite = opts.PathTraversal
        dst.DisableOverwrite = opts.KeepOldFiles

        desc, err := doPull(ctx, src, dst, copyOptions, metadataHandler, statusHandler, opts)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, file.ErrPathTraversalDisallowed) </span><span class="cov0" title="0">{
                        err = fmt.Errorf("%s: %w", "use flag --allow-path-traversal to allow insecurely pulling files outside of working directory", err)
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">metadataHandler.OnPulled(&amp;opts.Target, desc)
        return metadataHandler.Render()</span>
}

func doPull(ctx context.Context, src oras.ReadOnlyTarget, dst oras.GraphTarget, opts oras.CopyOptions, metadataHandler metadata.PullHandler, statusHandler status.PullHandler, po *pullOptions) (ocispec.Descriptor, error) <span class="cov0" title="0">{
        var configPath, configMediaType string
        var err error

        if po.ManifestConfigRef != "" </span><span class="cov0" title="0">{
                configPath, configMediaType, err = fileref.Parse(po.ManifestConfigRef, "")
                if err != nil </span><span class="cov0" title="0">{
                        return ocispec.Descriptor{}, err
                }</span>
        }
        <span class="cov0" title="0">dst, stopTrack, err := statusHandler.TrackTarget(dst)
        if err != nil </span><span class="cov0" title="0">{
                return ocispec.Descriptor{}, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = stopTrack()
        }</span>()
        <span class="cov0" title="0">var printed sync.Map
        var getConfigOnce sync.Once
        opts.FindSuccessors = func(ctx context.Context, fetcher content.Fetcher, desc ocispec.Descriptor) ([]ocispec.Descriptor, error) </span><span class="cov0" title="0">{
                statusFetcher := content.FetcherFunc(func(ctx context.Context, target ocispec.Descriptor) (fetched io.ReadCloser, fetchErr error) </span><span class="cov0" title="0">{
                        if _, ok := printed.LoadOrStore(descriptor.GenerateContentKey(target), true); ok </span><span class="cov0" title="0">{
                                return fetcher.Fetch(ctx, target)
                        }</span>
                        <span class="cov0" title="0">if err := statusHandler.OnNodeDownloading(target); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">rc, err := fetcher.Fetch(ctx, target)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                                if fetchErr != nil </span><span class="cov0" title="0">{
                                        _ = rc.Close()
                                }</span>
                        }()
                        <span class="cov0" title="0">return rc, statusHandler.OnNodeProcessing(target)</span>
                })

                <span class="cov0" title="0">nodes, subject, config, err := graph.Successors(ctx, statusFetcher, desc)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if subject != nil &amp;&amp; po.IncludeSubject </span><span class="cov0" title="0">{
                        nodes = append(nodes, *subject)
                }</span>
                <span class="cov0" title="0">if config != nil </span><span class="cov0" title="0">{
                        getConfigOnce.Do(func() </span><span class="cov0" title="0">{
                                if configPath != "" &amp;&amp; (configMediaType == "" || config.MediaType == configMediaType) </span><span class="cov0" title="0">{
                                        if config.Annotations == nil </span><span class="cov0" title="0">{
                                                config.Annotations = make(map[string]string)
                                        }</span>
                                        <span class="cov0" title="0">config.Annotations[ocispec.AnnotationTitle] = configPath</span>
                                }
                        })
                        <span class="cov0" title="0">if config.Size != ocispec.DescriptorEmptyJSON.Size || config.Digest != ocispec.DescriptorEmptyJSON.Digest || config.Annotations[ocispec.AnnotationTitle] != "" </span><span class="cov0" title="0">{
                                nodes = append(nodes, *config)
                        }</span>
                }

                <span class="cov0" title="0">var ret []ocispec.Descriptor
                for _, s := range nodes </span><span class="cov0" title="0">{
                        if s.Annotations[ocispec.AnnotationTitle] == "" </span><span class="cov0" title="0">{
                                if content.Equal(s, ocispec.DescriptorEmptyJSON) </span><span class="cov0" title="0">{
                                        // empty layer
                                        continue</span>
                                }
                                <span class="cov0" title="0">if s.Annotations[ocispec.AnnotationTitle] == "" </span><span class="cov0" title="0">{
                                        // unnamed layers are skipped
                                        if err = metadataHandler.OnLayerSkipped(s); err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                }
                                <span class="cov0" title="0">ss, err := content.Successors(ctx, fetcher, s)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">if len(ss) == 0 </span><span class="cov0" title="0">{
                                        // skip s if it is unnamed AND has no successors.
                                        if err := notifyOnce(&amp;printed, s, statusHandler.OnNodeSkipped); err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov0" title="0">continue</span>
                                }
                        }
                        <span class="cov0" title="0">ret = append(ret, s)</span>
                }
                <span class="cov0" title="0">return ret, nil</span>
        }

        <span class="cov0" title="0">opts.PreCopy = func(ctx context.Context, desc ocispec.Descriptor) error </span><span class="cov0" title="0">{
                return notifyOnce(&amp;printed, desc, statusHandler.OnNodeDownloading)
        }</span>
        <span class="cov0" title="0">opts.PostCopy = func(ctx context.Context, desc ocispec.Descriptor) error </span><span class="cov0" title="0">{
                // restore named but deduplicated successor nodes
                successors, err := content.Successors(ctx, dst, desc)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, s := range successors </span><span class="cov0" title="0">{
                        if name, ok := s.Annotations[ocispec.AnnotationTitle]; ok </span><span class="cov0" title="0">{
                                if err = metadataHandler.OnFilePulled(name, po.Output, s, po.Path); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if err = notifyOnce(&amp;printed, s, statusHandler.OnNodeRestored); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov0" title="0">printed.Store(descriptor.GenerateContentKey(desc), true)
                return statusHandler.OnNodeDownloaded(desc)</span>
        }

        // Copy
        <span class="cov0" title="0">desc, err := oras.Copy(ctx, src, po.Reference, dst, po.Reference, opts)
        return desc, err</span>
}

func notifyOnce(notified *sync.Map, s ocispec.Descriptor, notify func(ocispec.Descriptor) error) error <span class="cov0" title="0">{
        if _, loaded := notified.LoadOrStore(descriptor.GenerateContentKey(s), true); !loaded </span><span class="cov0" title="0">{
                return notify(s)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package root

import (
        "bytes"
        "encoding/json"
        "errors"
        "strings"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/spf13/cobra"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/content"
        "oras.land/oras-go/v2/content/file"
        "oras.land/oras-go/v2/content/memory"
        "oras.land/oras-go/v2/registry/remote/auth"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        "oras.land/oras/cmd/oras/internal/display"
        "oras.land/oras/cmd/oras/internal/display/status"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/fileref"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/internal/contentutil"
        "oras.land/oras/internal/listener"
        "oras.land/oras/internal/registryutil"
)

type pushOptions struct {
        option.Common
        option.Packer
        option.ArtifactPlatform
        option.ImageSpec
        option.Target
        option.Format
        option.Terminal

        extraRefs         []string
        manifestConfigRef string
        artifactType      string
        concurrency       int
        // Deprecated: verbose is deprecated and will be removed in the future.
        verbose bool
}

func pushCmd() *cobra.Command <span class="cov0" title="0">{
        var opts pushOptions
        cmd := &amp;cobra.Command{
                Use:   "push [flags] &lt;name&gt;[:&lt;tag&gt;[,&lt;tag&gt;][...]] &lt;file&gt;[:&lt;type&gt;] [...]",
                Short: "Push files to a registry or an OCI image layout",
                Long: `Push files to a registry or an OCI image layout

Example - Push file "hi.txt" with media type "application/vnd.oci.image.layer.v1.tar" (default):
  oras push localhost:5000/hello:v1 hi.txt

Example - Push file "hi.txt" and export the pushed manifest to a specified path:
  oras push --export-manifest manifest.json localhost:5000/hello:v1 hi.txt

Example - Push file "hi.txt" with the custom media type "application/vnd.me.hi":
  oras push localhost:5000/hello:v1 hi.txt:application/vnd.me.hi

Example - Push multiple files with different media types:
  oras push localhost:5000/hello:v1 hi.txt:application/vnd.me.hi bye.txt:application/vnd.me.bye

Example - Push file with colon in name "hi:txt" with the default media type:
  oras push localhost:5000/hello:v1 hi:txt:

Example - Push file "hi.txt" with artifact type "application/vnd.example+type":
  oras push --artifact-type application/vnd.example+type localhost:5000/hello:v1 hi.txt

Example - Push file "hi.txt" with config type "application/vnd.me.config":
  oras push --image-spec v1.0 --artifact-type application/vnd.me.config localhost:5000/hello:v1 hi.txt

Example - Push file "hi.txt" with the custom manifest config "config.json" of the custom media type "application/vnd.me.config":
  oras push --config config.json:application/vnd.me.config localhost:5000/hello:v1 hi.txt

Example - [Experimental] Push file "hi.txt" and format output in JSON:
  oras push localhost:5000/hello:v1 hi.txt --format json

Example - [Experimental] Push file "hi.txt" and format output with Go template:
  oras push localhost:5000/hello:v1 hi.txt --format go-template="{{.digest}}"

Example - Push file to the insecure registry:
  oras push --insecure localhost:5000/hello:v1 hi.txt

Example - Push file to the HTTP registry:
  oras push --plain-http localhost:5000/hello:v1 hi.txt

Example - Push repository with manifest annotations:
  oras push --annotation "key=val" localhost:5000/hello:v1

Example - Push repository with manifest annotation file:
  oras push --annotation-file annotation.json localhost:5000/hello:v1

Example - [Experimental] Push artifact to repository with platform:
  oras push --artifact-platform linux/arm/v5 localhost:5000/hello:v1

Example - Push file "hi.txt" with multiple tags:
  oras push localhost:5000/hello:tag1,tag2,tag3 hi.txt

Example - Push file "hi.txt" with multiple tags and concurrency level tuned:
  oras push --concurrency 6 localhost:5000/hello:tag1,tag2,tag3 hi.txt

Example - Push file "hi.txt" into an OCI image layout folder 'layout-dir' with tag 'test':
  oras push --oci-layout layout-dir:test hi.txt

Example - Push file "hi.txt" into an OCI image layout folder 'layout-dir' with tag 'example.com:test':
  oras push example.com:test hi.txt --oci-layout-path layout-dir
`,
                Args: oerrors.CheckArgs(argument.AtLeast(1), "the destination for pushing"),
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        refs := strings.Split(args[0], ",")
                        opts.RawReference = refs[0]
                        opts.extraRefs = refs[1:]
                        opts.FileRefs = args[1:]
                        if err := option.Parse(cmd, &amp;opts); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">opts.DisableTTY(opts.Debug, false)
                        if opts.manifestConfigRef != "" &amp;&amp; opts.artifactType == "" </span><span class="cov0" title="0">{
                                if !cmd.Flags().Changed("image-spec") </span><span class="cov0" title="0">{
                                        // switch to v1.0 manifest since artifact type is suggested
                                        // by OCI v1.1 artifact guidance but is not presented
                                        // see https://github.com/opencontainers/image-spec/blob/e7f7c0ca69b21688c3cea7c87a04e4503e6099e2/manifest.md?plain=1#L170
                                        opts.Flag = option.ImageSpecV1_0
                                        opts.PackVersion = oras.PackManifestVersion1_0
                                }</span> else<span class="cov0" title="0"> if opts.Flag == option.ImageSpecV1_1 </span><span class="cov0" title="0">{
                                        return &amp;oerrors.Error{
                                                Err:            errors.New(`missing artifact type for OCI image-spec v1.1 artifacts`),
                                                Recommendation: "set an artifact type via `--artifact-type` or consider image spec v1.0",
                                        }
                                }</span>
                        }
                        <span class="cov0" title="0">configAndPlatform := []string{"config", "artifact-platform"}
                        if err := oerrors.CheckMutuallyExclusiveFlags(cmd.Flags(), configAndPlatform...); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">switch opts.PackVersion </span>{
                        case oras.PackManifestVersion1_0:<span class="cov0" title="0">
                                if opts.manifestConfigRef != "" &amp;&amp; opts.artifactType != "" </span><span class="cov0" title="0">{
                                        return errors.New("--artifact-type and --config cannot both be provided for 1.0 OCI image")
                                }</span>
                        case oras.PackManifestVersion1_1:<span class="cov0" title="0">
                                if opts.manifestConfigRef == "" &amp;&amp; opts.artifactType == "" </span><span class="cov0" title="0">{
                                        opts.artifactType = oras.MediaTypeUnknownArtifact
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        opts.Printer.Verbose = opts.verbose
                        return runPush(cmd, &amp;opts)
                }</span>,
        }
        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;opts.manifestConfigRef, "config", "", "", "`path` of image config file")
        cmd.Flags().StringVarP(&amp;opts.artifactType, "artifact-type", "", "", "artifact type")
        cmd.Flags().IntVarP(&amp;opts.concurrency, "concurrency", "", 5, "concurrency level")
        cmd.Flags().BoolVarP(&amp;opts.verbose, "verbose", "v", true, "print status output for unnamed blobs")
        _ = cmd.Flags().MarkDeprecated("verbose", "and will be removed in a future release.")
        opts.SetTypes(option.FormatTypeText, option.FormatTypeJSON, option.FormatTypeGoTemplate)
        option.ApplyFlags(&amp;opts, cmd.Flags())
        return oerrors.Command(cmd, &amp;opts.Target)</span>
}

func runPush(cmd *cobra.Command, opts *pushOptions) error <span class="cov8" title="1">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)

        // prepare pack
        packOpts := oras.PackManifestOptions{
                ConfigAnnotations:   opts.Annotations[option.AnnotationConfig],
                ManifestAnnotations: opts.Annotations[option.AnnotationManifest],
        }
        store, err := file.New("")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = store.Close() }</span>()
        <span class="cov8" title="1">if opts.manifestConfigRef != "" </span><span class="cov0" title="0">{
                path, cfgMediaType, err := fileref.Parse(opts.manifestConfigRef, oras.MediaTypeUnknownConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">desc, err := addFile(ctx, store, option.AnnotationConfig, cfgMediaType, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">desc.Annotations = packOpts.ConfigAnnotations
                packOpts.ConfigDescriptor = &amp;desc</span>
        } else<span class="cov8" title="1"> if opts.Platform.Platform != nil </span><span class="cov0" title="0">{
                blob, err := json.Marshal(opts.Platform.Platform)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if opts.Flag == option.ImageSpecV1_0 &amp;&amp; opts.artifactType != "" </span><span class="cov0" title="0">{
                        return &amp;oerrors.Error{
                                Err:            errors.New(`artifact type cannot be customized for OCI image-spec v1.0 when platform is specified`),
                                Recommendation: "consider using image spec v1.1 or remove --artifact-type",
                        }
                }</span>
                <span class="cov0" title="0">desc := content.NewDescriptorFromBytes(ocispec.MediaTypeImageConfig, blob)
                err = store.Push(ctx, desc, bytes.NewReader(blob))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">desc.Annotations = packOpts.ConfigAnnotations
                packOpts.ConfigDescriptor = &amp;desc</span>
        }
        <span class="cov8" title="1">memoryStore := memory.New()
        union := contentutil.MultiReadOnlyTarget(memoryStore, store)
        statusHandler, metadataHandler, err := display.NewPushHandler(opts.Printer, opts.Format, opts.TTY, union)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">descs, err := loadFiles(ctx, store, opts.Annotations, opts.FileRefs, statusHandler)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">packOpts.Layers = descs
        pack := func() (ocispec.Descriptor, error) </span><span class="cov0" title="0">{
                root, err := oras.PackManifest(ctx, memoryStore, opts.PackVersion, opts.artifactType, packOpts)
                if err != nil </span><span class="cov0" title="0">{
                        return ocispec.Descriptor{}, err
                }</span>
                <span class="cov0" title="0">if err = memoryStore.Tag(ctx, root, root.Digest.String()); err != nil </span><span class="cov0" title="0">{
                        return ocispec.Descriptor{}, err
                }</span>
                <span class="cov0" title="0">return root, nil</span>
        }

        // prepare push
        <span class="cov0" title="0">originalDst, err := opts.NewTarget(opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">dst, stopTrack, err := statusHandler.TrackTarget(originalDst)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">copyOptions := oras.DefaultCopyOptions
        copyOptions.Concurrency = opts.concurrency
        copyOptions.OnCopySkipped = statusHandler.OnCopySkipped
        copyOptions.PreCopy = statusHandler.PreCopy
        copyOptions.PostCopy = statusHandler.PostCopy
        copyWithScopeHint := func(root ocispec.Descriptor) error </span><span class="cov0" title="0">{
                // add both pull and push scope hints for dst repository
                // to save potential push-scope token requests during copy
                ctx = registryutil.WithScopeHint(ctx, originalDst, auth.ActionPull, auth.ActionPush)

                if tag := opts.Reference; tag == "" </span><span class="cov0" title="0">{
                        err = oras.CopyGraph(ctx, union, dst, root, copyOptions.CopyGraphOptions)
                }</span> else<span class="cov0" title="0"> {
                        _, err = oras.Copy(ctx, union, root.Digest.String(), dst, tag, copyOptions)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Push
        <span class="cov0" title="0">root, err := doPush(dst, stopTrack, pack, copyWithScopeHint)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = metadataHandler.OnCopied(&amp;opts.Target, root)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(opts.extraRefs) != 0 </span><span class="cov0" title="0">{
                contentBytes, err := content.FetchAll(ctx, memoryStore, root)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">tagBytesNOpts := oras.DefaultTagBytesNOptions
                tagBytesNOpts.Concurrency = opts.concurrency
                dst := listener.NewTagListener(originalDst, nil, metadataHandler.OnTagged)
                if _, err = oras.TagBytesN(ctx, dst, root.MediaType, contentBytes, opts.extraRefs, tagBytesNOpts); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">err = metadataHandler.Render()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Export manifest
        <span class="cov0" title="0">return opts.ExportManifest(ctx, memoryStore, root)</span>
}

func doPush(dst oras.Target, stopTrack status.StopTrackTargetFunc, pack packFunc, copy copyFunc) (ocispec.Descriptor, error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                _ = stopTrack()
        }</span>()
        // Push
        <span class="cov0" title="0">return pushArtifact(dst, pack, copy)</span>
}

type packFunc func() (ocispec.Descriptor, error)
type copyFunc func(desc ocispec.Descriptor) error

func pushArtifact(_ oras.Target, pack packFunc, copy copyFunc) (ocispec.Descriptor, error) <span class="cov0" title="0">{
        root, err := pack()
        if err != nil </span><span class="cov0" title="0">{
                return ocispec.Descriptor{}, err
        }</span>

        // push
        <span class="cov0" title="0">if err = copy(root); err != nil </span><span class="cov0" title="0">{
                return ocispec.Descriptor{}, err
        }</span>
        <span class="cov0" title="0">return root, nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package repo

import (
        "github.com/spf13/cobra"
)

func Cmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:     "repo [command]",
                Short:   "Repository operations",
                Aliases: []string{"repository"},
        }

        cmd.AddCommand(
                listCmd(),
                showTagsCmd(),
        )
        return cmd
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package repo

import (
        "errors"
        "fmt"
        "strings"

        "github.com/spf13/cobra"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/internal/repository"
)

type repositoryOptions struct {
        option.Remote
        option.Common
        hostname  string
        namespace string
        last      string
}

func listCmd() *cobra.Command <span class="cov0" title="0">{
        var opts repositoryOptions
        cmd := &amp;cobra.Command{
                Use:   "ls [flags] &lt;registry&gt;",
                Short: "List the repositories under the registry",
                Long: `List the repositories under the registry

Example - List the repositories under the registry:
  oras repo ls localhost:5000

Example - List the repositories under a namespace in the registry:
  oras repo ls localhost:5000/example-namespace

Example - List the repositories under the registry that include values lexically after last:
  oras repo ls --last "last_repo" localhost:5000
`,
                Args:    oerrors.CheckArgs(argument.Exactly(1), "the target registry to list repositories from"),
                Aliases: []string{"list"},
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return option.Parse(cmd, &amp;opts)
                }</span>,
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        var err error
                        if opts.hostname, opts.namespace, err = repository.ParseRepoPath(args[0]); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not parse repository path: %w", err)
                        }</span>
                        <span class="cov0" title="0">return listRepository(cmd, &amp;opts)</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().StringVar(&amp;opts.last, "last", "", "start after the repository specified by `last`")
        option.AddDeprecatedVerboseFlag(cmd.Flags())
        option.ApplyFlags(&amp;opts, cmd.Flags())
        return oerrors.Command(cmd, &amp;opts.Remote)</span>
}

func listRepository(cmd *cobra.Command, opts *repositoryOptions) error <span class="cov0" title="0">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)
        reg, err := opts.NewRegistry(opts.hostname, opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = reg.Repositories(ctx, opts.last, func(repos []string) error </span><span class="cov0" title="0">{
                for _, repo := range repos </span><span class="cov0" title="0">{
                        if subRepo, found := strings.CutPrefix(repo, opts.namespace); found </span><span class="cov0" title="0">{
                                _ = opts.Printer.Println(subRepo)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                var repoErr error
                if opts.namespace != "" </span><span class="cov0" title="0">{
                        repoErr = fmt.Errorf("could not list repositories for %q with prefix %q", reg.Reference.Host(), opts.namespace)
                }</span> else<span class="cov0" title="0"> {
                        repoErr = fmt.Errorf("could not list repositories for %q", reg.Reference.Host())
                }</span>
                <span class="cov0" title="0">return errors.Join(repoErr, err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package repo

import (
        "strings"

        "github.com/opencontainers/go-digest"
        "github.com/spf13/cobra"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
        "oras.land/oras/internal/contentutil"
)

type showTagsOptions struct {
        option.Common
        option.Target

        last             string
        excludeDigestTag bool
}

func showTagsCmd() *cobra.Command <span class="cov0" title="0">{
        var opts showTagsOptions
        cmd := &amp;cobra.Command{
                Use:   "tags [flags] &lt;name&gt;",
                Short: "Show tags of the target repository",
                Long: `Show tags of the target repository

Example - Show tags of the target repository:
  oras repo tags localhost:5000/hello

Example - Show tags in the target repository with digest-like tags hidden:
  oras repo tags --exclude-digest-tags localhost:5000/hello

Example - Show tags of the target repository that include values lexically after last:
  oras repo tags --last "last_tag" localhost:5000/hello

Example - Show tags of the target OCI image layout folder 'layout-dir':
  oras repo tags --oci-layout layout-dir

Example - Show tags of the target OCI layout archive 'layout.tar':
  oras repo tags --oci-layout layout.tar

Example - [Experimental] Show tags associated with a particular tagged resource:
  oras repo tags localhost:5000/hello:latest

Example - [Experimental] Show tags associated with a digest:
  oras repo tags localhost:5000/hello@sha256:c551125a624189cece9135981621f3f3144564ddabe14b523507bf74c2281d9b
`,
                Args:    oerrors.CheckArgs(argument.Exactly(1), "the target repository to list tags from"),
                Aliases: []string{"show-tags"},
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        opts.RawReference = args[0]
                        return option.Parse(cmd, &amp;opts)
                }</span>,
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        return showTags(cmd, &amp;opts)
                }</span>,
        }
        <span class="cov0" title="0">cmd.Flags().StringVar(&amp;opts.last, "last", "", "start after the tag specified by `last`")
        cmd.Flags().BoolVar(&amp;opts.excludeDigestTag, "exclude-digest-tags", false, "[Preview] exclude all digest-like tags such as 'sha256-aaaa...'")
        option.AddDeprecatedVerboseFlag(cmd.Flags())
        option.ApplyFlags(&amp;opts, cmd.Flags())
        return oerrors.Command(cmd, &amp;opts.Target)</span>
}

func showTags(cmd *cobra.Command, opts *showTagsOptions) error <span class="cov0" title="0">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)
        finder, err := opts.NewReadonlyTarget(ctx, opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">filter := ""
        if opts.Reference != "" </span><span class="cov0" title="0">{
                if contentutil.IsDigest(opts.Reference) </span><span class="cov0" title="0">{
                        filter = opts.Reference
                }</span> else<span class="cov0" title="0"> {
                        desc, err := finder.Resolve(ctx, opts.Reference)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">filter = desc.Digest.String()</span>
                }
                <span class="cov0" title="0">logger.Warnf("[Experimental] querying tags associated to %s, it may take a while...\n", filter)</span>
        }
        <span class="cov0" title="0">return finder.Tags(ctx, opts.last, func(tags []string) error </span><span class="cov0" title="0">{
                for _, tag := range tags </span><span class="cov0" title="0">{
                        if opts.excludeDigestTag &amp;&amp; isDigestTag(tag) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if filter != "" </span><span class="cov0" title="0">{
                                if tag == opts.Reference </span><span class="cov0" title="0">{
                                        _ = opts.Printer.Println(tag)
                                        continue</span>
                                }
                                <span class="cov0" title="0">desc, err := finder.Resolve(ctx, tag)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if desc.Digest.String() != filter </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">_ = opts.Printer.Println(tag)</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
}

func isDigestTag(tag string) bool <span class="cov0" title="0">{
        dgst := strings.Replace(tag, "-", ":", 1)
        _, err := digest.Parse(dgst)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file99" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package root

import (
        "fmt"

        "github.com/spf13/cobra"
        "oras.land/oras-go/v2"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        "oras.land/oras/cmd/oras/internal/display"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
)

type resolveOptions struct {
        option.Common
        option.Platform
        option.Target

        fullRef bool
}

func resolveCmd() *cobra.Command <span class="cov0" title="0">{
        var opts resolveOptions

        cmd := &amp;cobra.Command{
                Use:   "resolve [flags] &lt;name&gt;{:&lt;tag&gt;|@&lt;digest&gt;}",
                Short: "[Experimental] Resolves digest of the target artifact",
                Long: `[Experimental] Resolves digest of the target artifact

Example - Resolve digest of the target artifact:
  oras resolve localhost:5000/hello-world:v1
`,
                Args:    oerrors.CheckArgs(argument.Exactly(1), "the target artifact reference to resolve"),
                Aliases: []string{"digest"},
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        opts.RawReference = args[0]
                        return option.Parse(cmd, &amp;opts)
                }</span>,
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        return runResolve(cmd, &amp;opts)
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().BoolVarP(&amp;opts.fullRef, "full-reference", "l", false, "print the full artifact reference with digest")
        option.AddDeprecatedVerboseFlag(cmd.Flags())
        option.ApplyFlags(&amp;opts, cmd.Flags())
        return oerrors.Command(cmd, &amp;opts.Target)</span>
}

func runResolve(cmd *cobra.Command, opts *resolveOptions) error <span class="cov0" title="0">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)
        repo, err := opts.NewReadonlyTarget(ctx, opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := opts.EnsureReferenceNotEmpty(cmd, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">metadataHandler := display.NewResolveHandler(opts.Printer, opts.fullRef, opts.Path)
        resolveOpts := oras.DefaultResolveOptions
        resolveOpts.TargetPlatform = opts.Platform.Platform
        desc, err := oras.Resolve(ctx, repo, opts.Reference, resolveOpts)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to resolve digest: %w", err)
        }</span>
        <span class="cov0" title="0">return metadataHandler.OnResolved(desc)</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package root

import (
        "errors"
        "fmt"

        "oras.land/oras/cmd/oras/internal/display"
        "oras.land/oras/internal/listener"

        "github.com/spf13/cobra"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/errdef"
        "oras.land/oras-go/v2/registry/remote"
        "oras.land/oras/cmd/oras/internal/argument"
        "oras.land/oras/cmd/oras/internal/command"
        oerrors "oras.land/oras/cmd/oras/internal/errors"
        "oras.land/oras/cmd/oras/internal/option"
)

type tagOptions struct {
        option.Common
        option.Target

        concurrency int
        targetRefs  []string
}

func tagCmd() *cobra.Command <span class="cov0" title="0">{
        var opts tagOptions
        cmd := &amp;cobra.Command{
                Use:   "tag [flags] &lt;name&gt;{:&lt;tag&gt;|@&lt;digest&gt;} &lt;new_tag&gt; [...]",
                Short: "Tag a manifest in a registry or an OCI image layout",
                Long: `Tag a manifest in a registry or an OCI image layout

Example - Tag the manifest 'v1.0.1' in 'localhost:5000/hello' to 'v1.0.2':
  oras tag localhost:5000/hello:v1.0.1 v1.0.2

Example - Tag the manifest with digest sha256:9463e0d192846bc994279417b50114606712d516aab45f4d8b31cbc6e46aad71 to 'v1.0.2'
  oras tag localhost:5000/hello@sha256:9463e0d192846bc994279417b50114606712d516aab45f4d8b31cbc6e46aad71 v1.0.2

Example - Tag the manifest 'v1.0.1' in 'localhost:5000/hello' to 'v1.0.2', 'latest'
  oras tag localhost:5000/hello:v1.0.1 v1.0.2 latest

Example - Tag the manifest 'v1.0.1' in 'localhost:5000/hello' to 'v1.0.1', 'v1.0.2', 'latest' with concurrency level tuned:
  oras tag --concurrency 1 localhost:5000/hello:v1.0.1 v1.0.2 latest

Example - Tag the manifest 'v1.0.1' to 'v1.0.2' in an OCI image layout folder 'layout-dir':
  oras tag --oci-layout layout-dir:v1.0.1 v1.0.2
`,
                Args: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) &gt; 0 &amp;&amp; (args[0] == "list" || args[0] == "ls") </span><span class="cov0" title="0">{
                                container := "a repository"
                                if opts.IsOCILayout </span><span class="cov0" title="0">{
                                        container = "an OCI image layout"
                                }</span>
                                <span class="cov0" title="0">return &amp;oerrors.Error{
                                        Err:            errors.New(`there is no "list" sub-command for "oras tag" command`),
                                        Usage:          fmt.Sprintf("%s %s", cmd.Parent().CommandPath(), cmd.Use),
                                        Recommendation: fmt.Sprintf(`If you want to list available tags in %s, use "oras repo tags"`, container),
                                }</span>
                        }
                        <span class="cov0" title="0">return oerrors.CheckArgs(argument.AtLeast(1), "the artifact to be retagged and the tags to be added")(cmd, args)</span>
                },
                PreRunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        opts.RawReference = args[0]
                        opts.targetRefs = args[1:]
                        if err := option.Parse(cmd, &amp;opts); err != nil </span><span class="cov0" title="0">{
                                if inner, ok := err.(*oerrors.Error); ok </span><span class="cov0" title="0">{
                                        if errors.Is(inner, errdef.ErrInvalidReference) </span><span class="cov0" title="0">{
                                                inner.Err = fmt.Errorf("unable to add tag for '%s': %w", opts.RawReference, inner.Err)
                                        }</span>
                                }
                                <span class="cov0" title="0">return err</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        return tagManifest(cmd, &amp;opts)
                }</span>,
        }

        <span class="cov0" title="0">option.ApplyFlags(&amp;opts, cmd.Flags())
        cmd.Flags().IntVarP(&amp;opts.concurrency, "concurrency", "", 5, "concurrency level")
        option.AddDeprecatedVerboseFlag(cmd.Flags())
        return oerrors.Command(cmd, &amp;opts.Target)</span>
}

func tagManifest(cmd *cobra.Command, opts *tagOptions) error <span class="cov0" title="0">{
        ctx, logger := command.GetLogger(cmd, &amp;opts.Common)
        target, err := opts.NewTarget(opts.Common, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if targetRepo, ok := target.(*remote.Repository); ok </span><span class="cov0" title="0">{
                // Since referrer capability has not been set or detected yet,
                // nil is the only returned value and thus can be ignored
                _ = targetRepo.SetReferrersCapability(true)
        }</span>
        <span class="cov0" title="0">if err := opts.EnsureReferenceNotEmpty(cmd, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tagNOpts := oras.DefaultTagNOptions
        tagNOpts.Concurrency = opts.concurrency
        tagHandler := display.NewTagHandler(opts.Printer, opts.Target)
        tagListener := listener.NewTagListener(target, tagHandler.OnTagging, tagHandler.OnTagged)
        _, err = oras.TagN(
                ctx,
                tagListener,
                opts.Reference,
                opts.targetRefs,
                tagNOpts,
        )
        return err</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package root

import (
        "fmt"
        "os"
        "runtime"
        "strings"

        "github.com/spf13/cobra"

        "oras.land/oras/cmd/oras/internal/output"
        "oras.land/oras/internal/version"
)

func versionCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "version",
                Short: "Show the oras version information",
                Long: `Show the oras version information

Example - print version:
  oras version
`,
                Args: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) != 0 </span><span class="cov0" title="0">{
                                _, err := fmt.Fprintf(os.Stderr, "warning: `oras version` requires no argument, %q will be ignored\n", strings.Join(args, ","))
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        printer := output.NewPrinter(cmd.OutOrStdout(), cmd.ErrOrStderr())
                        return runVersion(printer)
                }</span>,
        }

        <span class="cov0" title="0">return cmd</span>
}

func runVersion(printer *output.Printer) error <span class="cov0" title="0">{
        items := [][]string{
                {"Version", version.GetVersion()},
                {"Go version", runtime.Version()},
                {"OS/Arch", fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH)},
        }
        if version.GitCommit != "" </span><span class="cov0" title="0">{
                items = append(items, []string{"Git commit", version.GitCommit})
        }</span>
        <span class="cov0" title="0">if version.GitTreeState != "" </span><span class="cov0" title="0">{
                items = append(items, []string{"Git tree state", version.GitTreeState})
        }</span>

        <span class="cov0" title="0">size := 0
        for _, item := range items </span><span class="cov0" title="0">{
                if length := len(item[0]); length &gt; size </span><span class="cov0" title="0">{
                        size = length
                }</span>
        }
        <span class="cov0" title="0">for _, item := range items </span><span class="cov0" title="0">{
                _ = printer.Println(item[0] + ": " + strings.Repeat(" ", size-len(item[0])) + item[1])
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cache

import (
        "context"
        "io"
        "sync"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/content"
        "oras.land/oras-go/v2/registry"
)

type closer func() error

func (fn closer) Close() error <span class="cov1" title="1">{
        return fn()
}</span>

// Cache target struct.
type target struct {
        oras.ReadOnlyTarget
        cache content.Storage
}

// New generates a new target storage with caching.
func New(source oras.ReadOnlyTarget, cache content.Storage) oras.ReadOnlyTarget <span class="cov10" title="3">{
        t := &amp;target{
                ReadOnlyTarget: source,
                cache:          cache,
        }
        if refFetcher, ok := source.(registry.ReferenceFetcher); ok </span><span class="cov1" title="1">{
                return &amp;referenceTarget{
                        target:           t,
                        ReferenceFetcher: refFetcher,
                }
        }</span>
        <span class="cov6" title="2">return t</span>
}

// Fetch fetches the content identified by the descriptor.
func (t *target) Fetch(ctx context.Context, target ocispec.Descriptor) (io.ReadCloser, error) <span class="cov1" title="1">{
        rc, err := t.cache.Fetch(ctx, target)
        if err == nil </span><span class="cov1" title="1">{
                // Fetch from cache
                return rc, nil
        }</span>

        <span class="cov0" title="0">if rc, err = t.ReadOnlyTarget.Fetch(ctx, target); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fetch from origin with caching
        <span class="cov0" title="0">return t.cacheReadCloser(ctx, rc, target), nil</span>
}

func (t *target) cacheReadCloser(ctx context.Context, rc io.ReadCloser, target ocispec.Descriptor) io.ReadCloser <span class="cov1" title="1">{
        pr, pw := io.Pipe()
        var wg sync.WaitGroup

        wg.Add(1)
        var pushErr error
        go func() </span><span class="cov1" title="1">{
                defer wg.Done()
                pushErr = t.cache.Push(ctx, target, pr)
                if pushErr != nil </span><span class="cov0" title="0">{
                        pr.CloseWithError(pushErr)
                }</span>
        }()

        <span class="cov1" title="1">return struct {
                io.Reader
                io.Closer
        }{
                Reader: io.TeeReader(rc, pw),
                Closer: closer(func() error </span><span class="cov1" title="1">{
                        rcErr := rc.Close()
                        if err := pw.Close(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov1" title="1">wg.Wait()
                        if pushErr != nil </span><span class="cov0" title="0">{
                                return pushErr
                        }</span>
                        <span class="cov1" title="1">return rcErr</span>
                }),
        }
}

// Exists returns true if the described content exists.
func (t *target) Exists(ctx context.Context, desc ocispec.Descriptor) (bool, error) <span class="cov0" title="0">{
        exists, err := t.cache.Exists(ctx, desc)
        if err == nil &amp;&amp; exists </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">return t.ReadOnlyTarget.Exists(ctx, desc)</span>
}

// Cache referenceTarget struct.
type referenceTarget struct {
        *target
        registry.ReferenceFetcher
}

// FetchReference fetches the content identified by the reference from the
// remote and cache the fetched content.
// Cached content will only be read via Fetch, FetchReference will always fetch
// From origin.
func (t *referenceTarget) FetchReference(ctx context.Context, reference string) (ocispec.Descriptor, io.ReadCloser, error) <span class="cov6" title="2">{
        target, rc, err := t.ReferenceFetcher.FetchReference(ctx, reference)
        if err != nil </span><span class="cov0" title="0">{
                return ocispec.Descriptor{}, nil, err
        }</span>

        // skip caching if the content already exists in cache
        <span class="cov6" title="2">exists, err := t.cache.Exists(ctx, target)
        if err != nil </span><span class="cov0" title="0">{
                return ocispec.Descriptor{}, nil, err
        }</span>
        <span class="cov6" title="2">if exists </span><span class="cov1" title="1">{
                err = rc.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return ocispec.Descriptor{}, nil, err
                }</span>

                // get rc from the cache
                <span class="cov1" title="1">rc, err = t.cache.Fetch(ctx, target)
                if err != nil </span><span class="cov0" title="0">{
                        return ocispec.Descriptor{}, nil, err
                }</span>

                // no need to do tee'd push
                <span class="cov1" title="1">return target, rc, nil</span>
        }

        // Fetch from origin with caching
        <span class="cov1" title="1">return target, t.cacheReadCloser(ctx, rc, target), nil</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package contentutil

import "github.com/opencontainers/go-digest"

// IsDigest checks if the given string is a valid digest.
func IsDigest(tagOrDigest string) bool <span class="cov10" title="4">{
        _, err := digest.Parse(tagOrDigest)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package contentutil

import (
        "context"
        "errors"
        "io"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/errdef"
)

type multiReadOnlyTarget struct {
        targets []oras.ReadOnlyTarget
}

// MultiReadOnlyTarget returns a ReadOnlyTarget that combines multiple targets.
func MultiReadOnlyTarget(targets ...oras.ReadOnlyTarget) oras.ReadOnlyTarget <span class="cov8" title="1">{
        return &amp;multiReadOnlyTarget{
                targets: targets,
        }
}</span>

// Fetch fetches the content from the targets in order and return first found
// content. If no content is found, it returns ErrNotFound.
func (m *multiReadOnlyTarget) Fetch(ctx context.Context, target ocispec.Descriptor) (io.ReadCloser, error) <span class="cov0" title="0">{
        lastErr := errdef.ErrNotFound
        for _, c := range m.targets </span><span class="cov0" title="0">{
                rc, err := c.Fetch(ctx, target)
                if err == nil </span><span class="cov0" title="0">{
                        return rc, nil
                }</span>
                <span class="cov0" title="0">if !errors.Is(err, errdef.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">lastErr = err</span>
        }
        <span class="cov0" title="0">return nil, lastErr</span>
}

// Exists returns true if the content exists in any of the targets.
// multiReadOnlyTarget does not implement Exists() because it's read-only.
func (m *multiReadOnlyTarget) Exists(ctx context.Context, target ocispec.Descriptor) (bool, error) <span class="cov0" title="0">{
        return false, errors.New("MultiReadOnlyTarget.Exists() is not implemented")
}</span>

// Resolve resolves the reference to a descriptor from the targets in order and
// return first found descriptor. If no descriptor is found, it returns
// ErrNotFound.
func (m *multiReadOnlyTarget) Resolve(ctx context.Context, ref string) (ocispec.Descriptor, error) <span class="cov0" title="0">{
        lastErr := errdef.ErrNotFound
        for _, c := range m.targets </span><span class="cov0" title="0">{
                desc, err := c.Resolve(ctx, ref)
                if err == nil </span><span class="cov0" title="0">{
                        return desc, nil
                }</span>
                <span class="cov0" title="0">if !errors.Is(err, errdef.ErrNotFound) </span><span class="cov0" title="0">{
                        return ocispec.Descriptor{}, err
                }</span>
                <span class="cov0" title="0">lastErr = err</span>
        }
        <span class="cov0" title="0">return ocispec.Descriptor{}, lastErr</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package credential

import "oras.land/oras-go/v2/registry/remote/auth"

// Credential converts user input username and password to a credential.
func Credential(username, password string) auth.Credential <span class="cov10" title="11">{
        if username == "" </span><span class="cov9" title="9">{
                return auth.Credential{
                        RefreshToken: password,
                }
        }</span>
        <span class="cov3" title="2">return auth.Credential{
                Username: username,
                Password: password,
        }</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package credential

import (
        "oras.land/oras-go/v2/registry/remote/credentials"
)

// NewStore generates a store based on the passed-in config file paths.
func NewStore(configPaths ...string) (credentials.Store, error) <span class="cov10" title="8">{
        opts := credentials.StoreOptions{AllowPlaintextPut: true}
        if len(configPaths) == 0 </span><span class="cov9" title="7">{
                // use default docker config file path
                return credentials.NewStoreFromDocker(opts)
        }</span>

        <span class="cov1" title="1">var stores []credentials.Store
        for _, config := range configPaths </span><span class="cov1" title="1">{
                store, err := credentials.NewStore(config, opts)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">stores = append(stores, store)</span>
        }
        <span class="cov0" title="0">return credentials.NewStoreWithFallbacks(stores[0], stores[1:]...), nil</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package crypto

import (
        "crypto/x509"
        "errors"
        "os"
)

// LoadCertPool returns a new cert pool loaded from the cert file.
func LoadCertPool(path string) (*x509.CertPool, error) <span class="cov10" title="8">{
        pool := x509.NewCertPool()
        pemBytes, err := os.ReadFile(path)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov9" title="7">if ok := pool.AppendCertsFromPEM(pemBytes); !ok </span><span class="cov1" title="1">{
                return nil, errors.New("Failed to load certificate in file: " + path)
        }</span>
        <span class="cov8" title="6">return pool, nil</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package descriptor

import (
        "github.com/opencontainers/go-digest"
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras/internal/docker"
)

// IsManifest checks if a descriptor describes a manifest.
// Adapted from `oras-go`: https://github.com/oras-project/oras-go/blob/d6c837e439f4c567f8003eab6e423c22900452a8/internal/descriptor/descriptor.go#L67
func IsManifest(desc ocispec.Descriptor) bool <span class="cov5" title="4">{
        switch desc.MediaType </span>{
        case docker.MediaTypeManifest,
                docker.MediaTypeManifestList,
                ocispec.MediaTypeImageManifest,
                ocispec.MediaTypeImageIndex:<span class="cov4" title="3">
                return true</span>
        default:<span class="cov1" title="1">
                return false</span>
        }
}

// IsImageManifest checks whether a manifest is an image manifest.
func IsImageManifest(desc ocispec.Descriptor) bool <span class="cov4" title="3">{
        return desc.MediaType == docker.MediaTypeManifest || desc.MediaType == ocispec.MediaTypeImageManifest
}</span>

// IsIndex checks if a descriptor describes an image index or Docker manifest list.
func IsIndex(desc ocispec.Descriptor) bool <span class="cov5" title="4">{
        return desc.MediaType == ocispec.MediaTypeImageIndex || desc.MediaType == docker.MediaTypeManifestList
}</span>

// ShortDigest converts the digest of the descriptor to a short form for displaying.
func ShortDigest(desc ocispec.Descriptor) (digestString string) <span class="cov9" title="16">{
        digestString = desc.Digest.String()
        if err := desc.Digest.Validate(); err == nil </span><span class="cov9" title="15">{
                if algo := desc.Digest.Algorithm(); algo == digest.SHA256 </span><span class="cov9" title="15">{
                        digestString = desc.Digest.Encoded()[:12]
                }</span>
        }
        <span class="cov9" title="16">return digestString</span>
}

// Plain returns a plain descriptor that contains only MediaType, Digest and Size.
// Copied from `oras-go`: https://github.com/oras-project/oras-go/blob/d6c837e439f4c567f8003eab6e423c22900452a8/internal/descriptor/descriptor.go#L81
func Plain(desc ocispec.Descriptor) ocispec.Descriptor <span class="cov1" title="1">{
        return ocispec.Descriptor{
                MediaType: desc.MediaType,
                Digest:    desc.Digest,
                Size:      desc.Size,
        }
}</span>

// GetTitleOrMediaType gets a descriptor name using either title or media type.
func GetTitleOrMediaType(desc ocispec.Descriptor) (name string, isTitle bool) <span class="cov10" title="17">{
        name, ok := desc.Annotations[ocispec.AnnotationTitle]
        if !ok </span><span class="cov3" title="2">{
                return desc.MediaType, false
        }</span>
        <span class="cov9" title="15">return name, true</span>
}

// GenerateContentKey generates a unique key for each content descriptor using
// digest and name.
func GenerateContentKey(desc ocispec.Descriptor) string <span class="cov1" title="1">{
        return desc.Digest.String() + desc.Annotations[ocispec.AnnotationTitle]
}</span>
</pre>
		
		<pre class="file" id="file109" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package file

import (
        "errors"
        "fmt"
        "io"
        "os"

        digest "github.com/opencontainers/go-digest"
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
)

// PrepareManifestContent prepares the content for manifest from the file path
// or stdin.
func PrepareManifestContent(path string) ([]byte, error) <span class="cov6" title="4">{
        if path == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("missing file name")
        }</span>

        <span class="cov5" title="3">var content []byte
        var err error
        if path == "-" </span><span class="cov1" title="1">{
                content, err = io.ReadAll(os.Stdin)
        }</span> else<span class="cov3" title="2"> {
                content, err = os.ReadFile(path)
        }</span>
        <span class="cov5" title="3">if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read %s: %w", path, err)
        }</span>

        <span class="cov3" title="2">return content, nil</span>
}

// PrepareBlobContent prepares the content descriptor for blob from the file
// path or stdin. Use the input digest and size if they are provided. Will
// return error if the content is from stdin but the content digest and size
// are missing.
func PrepareBlobContent(path string, mediaType string, digestString string, size int64) (desc ocispec.Descriptor, rc io.ReadCloser, err error) <span class="cov10" title="9">{
        if path == "" </span><span class="cov1" title="1">{
                return ocispec.Descriptor{}, nil, errors.New("missing file name")
        }</span>

        // validate digest
        <span class="cov9" title="8">var blobDigest digest.Digest
        if digestString != "" </span><span class="cov5" title="3">{
                blobDigest, err = digest.Parse(digestString)
                if err != nil </span><span class="cov1" title="1">{
                        return ocispec.Descriptor{}, nil, fmt.Errorf("invalid digest %s: %w", digestString, err)
                }</span>
        }

        // prepares the content descriptor from stdin
        <span class="cov8" title="7">if path == "-" </span><span class="cov5" title="3">{
                // throw err if size or digest is not provided.
                if size &lt; 0 </span><span class="cov1" title="1">{
                        return ocispec.Descriptor{}, nil, errors.New("content size must be provided if it is read from stdin")
                }</span>
                <span class="cov3" title="2">if blobDigest == "" </span><span class="cov1" title="1">{
                        return ocispec.Descriptor{}, nil, errors.New("content digest must be provided if it is read from stdin")
                }</span>
                <span class="cov1" title="1">return ocispec.Descriptor{
                        MediaType: mediaType,
                        Digest:    blobDigest,
                        Size:      size,
                }, os.Stdin, nil</span>
        }

        <span class="cov6" title="4">var file *os.File
        file, err = os.Open(path)
        if err != nil </span><span class="cov1" title="1">{
                return ocispec.Descriptor{}, nil, fmt.Errorf("failed to open %s: %w", path, err)
        }</span>
        <span class="cov5" title="3">defer func() </span><span class="cov5" title="3">{
                if err != nil </span><span class="cov1" title="1">{
                        _ = file.Close()
                }</span>
        }()

        <span class="cov5" title="3">var fi os.FileInfo
        fi, err = file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return ocispec.Descriptor{}, nil, fmt.Errorf("failed to stat %s: %w", path, err)
        }</span>
        <span class="cov5" title="3">actualSize := fi.Size()
        if size &gt;= 0 &amp;&amp; size != actualSize </span><span class="cov1" title="1">{
                return ocispec.Descriptor{}, nil, fmt.Errorf("input size %d does not match the actual content size %d", size, actualSize)
        }</span>

        <span class="cov3" title="2">if blobDigest == "" </span><span class="cov1" title="1">{
                blobDigest, err = digest.FromReader(file)
                if err != nil </span><span class="cov0" title="0">{
                        return ocispec.Descriptor{}, nil, err
                }</span>
                <span class="cov1" title="1">if _, err = file.Seek(0, io.SeekStart); err != nil </span><span class="cov0" title="0">{
                        return ocispec.Descriptor{}, nil, err
                }</span>
        }

        <span class="cov3" title="2">return ocispec.Descriptor{
                MediaType: mediaType,
                Digest:    blobDigest,
                Size:      actualSize,
        }, file, nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package graph

import (
        "context"
        "encoding/json"
        "sync"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "golang.org/x/sync/errgroup"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/content"
        "oras.land/oras/internal/docker"
)

// MediaTypeArtifactManifest specifies the media type for a content descriptor.
const MediaTypeArtifactManifest = "application/vnd.oci.artifact.manifest.v1+json"

// Artifact describes an artifact manifest.
// This structure provides `application/vnd.oci.artifact.manifest.v1+json` mediatype when marshalled to JSON.
//
// This manifest type was introduced in image-spec v1.1.0-rc1 and was removed in
// image-spec v1.1.0-rc3. It is not part of the current image-spec and is kept
// here for Go compatibility.
//
// Reference: https://github.com/opencontainers/image-spec/pull/999
type Artifact struct {
        // MediaType is the media type of the object this schema refers to.
        MediaType string `json:"mediaType"`

        // ArtifactType is the IANA media type of the artifact this schema refers to.
        ArtifactType string `json:"artifactType"`

        // Blobs is a collection of blobs referenced by this manifest.
        Blobs []ocispec.Descriptor `json:"blobs,omitempty"`

        // Subject (reference) is an optional link from the artifact to another manifest forming an association between the artifact and the other manifest.
        Subject *ocispec.Descriptor `json:"subject,omitempty"`

        // Annotations contains arbitrary metadata for the artifact manifest.
        Annotations map[string]string `json:"annotations,omitempty"`
}

// Successors returns the nodes directly pointed by the current node, picking
// out subject and config descriptor if applicable.
// Returning nil when no subject and config found.
func Successors(ctx context.Context, fetcher content.Fetcher, node ocispec.Descriptor) (nodes []ocispec.Descriptor, subject, config *ocispec.Descriptor, err error) <span class="cov5" title="5">{
        switch node.MediaType </span>{
        case docker.MediaTypeManifest, ocispec.MediaTypeImageManifest:<span class="cov4" title="4">
                var fetched []byte
                fetched, err = content.FetchAll(ctx, fetcher, node)
                if err != nil </span><span class="cov2" title="2">{
                        return
                }</span>
                <span class="cov2" title="2">var manifest ocispec.Manifest
                if err = json.Unmarshal(fetched, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov2" title="2">nodes = manifest.Layers
                subject = manifest.Subject
                config = &amp;manifest.Config</span>
        case MediaTypeArtifactManifest:<span class="cov0" title="0">
                var fetched []byte
                fetched, err = content.FetchAll(ctx, fetcher, node)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">var manifest Artifact
                if err = json.Unmarshal(fetched, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">nodes = manifest.Blobs
                subject = manifest.Subject</span>
        case ocispec.MediaTypeImageIndex:<span class="cov1" title="1">
                var fetched []byte
                fetched, err = content.FetchAll(ctx, fetcher, node)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov1" title="1">var index ocispec.Index
                if err = json.Unmarshal(fetched, &amp;index); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov1" title="1">nodes = index.Manifests
                subject = index.Subject</span>
        default:<span class="cov0" title="0">
                nodes, err = content.Successors(ctx, fetcher, node)</span>
        }
        <span class="cov4" title="3">return</span>
}

// FindPredecessors returns all predecessors of descs in src concurrently.
func FindPredecessors(ctx context.Context, src oras.ReadOnlyGraphTarget, descs []ocispec.Descriptor, opts oras.ExtendedCopyOptions) ([]ocispec.Descriptor, error) <span class="cov2" title="2">{
        var referrers []ocispec.Descriptor
        g, ctx := errgroup.WithContext(ctx)
        var m sync.Mutex
        if opts.Concurrency != 0 </span><span class="cov0" title="0">{
                g.SetLimit(opts.Concurrency)
        }</span>
        <span class="cov2" title="2">for _, desc := range descs </span><span class="cov2" title="2">{
                g.Go(func(node ocispec.Descriptor) func() error </span><span class="cov2" title="2">{
                        return func() error </span><span class="cov2" title="2">{
                                descs, err := opts.FindPredecessors(ctx, src, node)
                                if err != nil </span><span class="cov1" title="1">{
                                        return err
                                }</span>
                                <span class="cov1" title="1">m.Lock()
                                defer m.Unlock()
                                referrers = append(referrers, descs...)
                                return nil</span>
                        }
                }(desc))
        }
        <span class="cov2" title="2">if err := g.Wait(); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return referrers, nil</span>
}

// FilteredSuccessors fetches successors and returns filtered ones.
func FilteredSuccessors(ctx context.Context, desc ocispec.Descriptor, fetcher content.Fetcher, filter func(ocispec.Descriptor) bool) ([]ocispec.Descriptor, error) <span class="cov8" title="13">{
        allSuccessors, err := content.Successors(ctx, fetcher, desc)
        if err != nil </span><span class="cov4" title="4">{
                return nil, err
        }</span>

        <span class="cov7" title="9">var successors []ocispec.Descriptor
        for _, s := range allSuccessors </span><span class="cov10" title="23">{
                if filter(s) </span><span class="cov6" title="7">{
                        successors = append(successors, s)
                }</span>
        }
        <span class="cov7" title="9">return successors, nil</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package io

import (
        "bytes"
        "io"
)

// ReadLine reads a line from the reader with trailing \r dropped.
func ReadLine(reader io.Reader) ([]byte, error) <span class="cov6" title="12">{
        var line []byte
        var buffer [1]byte
        for </span><span class="cov10" title="42">{
                n, err := reader.Read(buffer[:])
                if err != nil </span><span class="cov5" title="6">{
                        if err == io.EOF </span><span class="cov4" title="5">{
                                break</span>
                        }
                        <span class="cov1" title="1">return nil, err</span>
                }
                <span class="cov9" title="36">if n == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov9" title="36">c := buffer[0]
                if c == '\n' </span><span class="cov5" title="6">{
                        break</span>
                }
                <span class="cov9" title="30">line = append(line, c)</span>
        }
        <span class="cov6" title="11">return bytes.TrimSuffix(line, []byte{'\r'}), nil</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package listener

import (
        "context"
        "io"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras-go/v2"
        "oras.land/oras-go/v2/registry"
)

// NewTagListener creates a wrapper type for printing a tag status and hint.
// It can only be used for oras.TagBytes and oras.TagBytesN.
func NewTagListener(target oras.Target, onTagging, onTagged func(desc ocispec.Descriptor, tag string) error) oras.Target <span class="cov10" title="2">{
        if repo, ok := target.(registry.Repository); ok </span><span class="cov1" title="1">{
                return &amp;tagListenerForRepository{
                        Repository: repo,
                        onTagging:  onTagging,
                        onTagged:   onTagged,
                }
        }</span>
        <span class="cov1" title="1">return &amp;tagListenerForTarget{
                Target:    target,
                onTagging: onTagging,
                onTagged:  onTagged,
        }</span>
}

// NewTaggedListener creates a wrapper type for printing all tagged statuses.
// It can only be used for oras.TagBytes and oras.TagBytesN.
func NewTaggedListener(target oras.Target, onTagged func(desc ocispec.Descriptor, tag string) error) oras.Target <span class="cov0" title="0">{
        return NewTagListener(target, nil, onTagged)
}</span>

type tagListenerForRepository struct {
        registry.Repository
        onTagging func(desc ocispec.Descriptor, tag string) error
        onTagged  func(desc ocispec.Descriptor, tag string) error
}

// PushReference overrides Repository.PushReference method to print off which tag(s) were added successfully.
func (l *tagListenerForRepository) PushReference(ctx context.Context, expected ocispec.Descriptor, content io.Reader, reference string) error <span class="cov1" title="1">{
        if l.onTagging != nil </span><span class="cov1" title="1">{
                if err := l.onTagging(expected, reference); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if err := l.Repository.PushReference(ctx, expected, content, reference); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return l.onTagged(expected, reference)</span>
}

type tagListenerForTarget struct {
        oras.Target
        onTagging func(desc ocispec.Descriptor, tag string) error
        onTagged  func(desc ocispec.Descriptor, tag string) error
}

// Tag tags a descriptor with a reference string.
func (l *tagListenerForTarget) Tag(ctx context.Context, desc ocispec.Descriptor, reference string) error <span class="cov1" title="1">{
        if l.onTagging != nil </span><span class="cov1" title="1">{
                if err := l.onTagging(desc, reference); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if err := l.Target.Tag(ctx, desc, reference); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return l.onTagged(desc, reference)</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package mock contains mocking components for unit testing.
package mock

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "io"

        "github.com/opencontainers/go-digest"
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras-go/v2/registry/remote"
)

type content struct {
        ocispec.Descriptor
        blob []byte
}

type repository struct {
        cas                map[string]content
        remote.Repository  // make tests compile
        isFetcher          bool
        isReferenceFetcher bool
        isResolver         bool
}

// WithFetch enables mocking for Fetch.
func (repo *repository) WithFetch() *repository <span class="cov0" title="0">{
        repo.isFetcher = true
        return repo
}</span>

// WithFetchReference enables mocking for FetchReference.
func (repo *repository) WithFetchReference() *repository <span class="cov0" title="0">{
        repo.isReferenceFetcher = true
        return repo
}</span>

// WithResolve enables mocking for Resolve.
func (repo *repository) WithResolve() *repository <span class="cov0" title="0">{
        repo.isResolver = true
        return repo
}</span>

// New returns a new repository struct.
func New() *repository <span class="cov0" title="0">{
        return &amp;repository{}
}</span>

// Blob mocks a content blob stored in content-addressable storage.
type Blob struct {
        Content   string
        MediaType string
        Tag       string
}

// Remount remounts the underlying CAS of the repository.
func (repo *repository) Remount(blobs []Blob) <span class="cov0" title="0">{
        repo.cas = make(map[string]content)
        for _, blob := range blobs </span><span class="cov0" title="0">{
                bytes := []byte(blob.Content)
                desc := ocispec.Descriptor{
                        MediaType: blob.MediaType,
                        Digest:    digest.FromBytes(bytes),
                        Size:      int64(len(bytes)),
                }
                repo.cas[string(desc.Digest)] = content{desc, bytes}
                if blob.Tag != "" </span><span class="cov0" title="0">{
                        repo.cas[blob.Tag] = content{desc, bytes}
                }</span>
        }
}

var errNotImplemented = errors.New("not implemented")

// FetchReference mocks the fetching via a reference ref.
func (repo *repository) FetchReference(ctx context.Context, ref string) (ocispec.Descriptor, io.ReadCloser, error) <span class="cov0" title="0">{
        if !repo.isReferenceFetcher </span><span class="cov0" title="0">{
                return ocispec.Descriptor{}, nil, errNotImplemented
        }</span>

        <span class="cov0" title="0">if c, ok := repo.cas[ref]; ok </span><span class="cov0" title="0">{
                return c.Descriptor, io.NopCloser(bytes.NewReader(c.blob)), nil
        }</span>
        <span class="cov0" title="0">return ocispec.Descriptor{}, nil, fmt.Errorf("got unexpected reference %q", ref)</span>
}

// Fetch mocks fetching the target descriptor.
func (repo *repository) Fetch(ctx context.Context, target ocispec.Descriptor) (io.ReadCloser, error) <span class="cov0" title="0">{
        if !repo.isFetcher </span><span class="cov0" title="0">{
                return nil, errNotImplemented
        }</span>

        <span class="cov0" title="0">if r, ok := repo.cas[target.Digest.String()]; ok </span><span class="cov0" title="0">{
                return io.NopCloser(bytes.NewReader(r.blob)), nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected descriptor %v", target)</span>

}

// Resolve mocks resolving via a reference.
func (repo *repository) Resolve(ctx context.Context, reference string) (ocispec.Descriptor, error) <span class="cov0" title="0">{
        if !repo.isResolver </span><span class="cov0" title="0">{
                return ocispec.Descriptor{}, errNotImplemented
        }</span>

        <span class="cov0" title="0">if r, ok := repo.cas[reference]; ok </span><span class="cov0" title="0">{
                return r.Descriptor, nil
        }</span>
        <span class="cov0" title="0">return ocispec.Descriptor{}, fmt.Errorf("unexpected reference %v", reference)</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package net

import (
        "context"
        "fmt"
        "net"
)

// DialFunc is the function type for http.DialContext.
type DialFunc func(ctx context.Context, network, addr string) (net.Conn, error)

// Dialer struct provides dialing function with predefined DNS resolves.
type Dialer struct {
        BaseDialContext DialFunc
        resolve         map[string]string
}

// Add adds an entry for DNS resolve.
func (d *Dialer) Add(from string, fromPort int, to net.IP, toPort int) <span class="cov10" title="4">{
        if d.resolve == nil </span><span class="cov10" title="4">{
                d.resolve = make(map[string]string)
        }</span>
        <span class="cov10" title="4">d.resolve[fmt.Sprintf("%s:%d", from, fromPort)] = fmt.Sprintf("%s:%d", to, toPort)</span>
}

// DialContext connects to the addr on the named network using the provided
// context.
func (d *Dialer) DialContext(ctx context.Context, network, addr string) (net.Conn, error) <span class="cov1" title="1">{
        if resolved, ok := d.resolve[addr]; ok </span><span class="cov1" title="1">{
                addr = resolved
        }</span>
        <span class="cov1" title="1">return d.BaseDialContext(ctx, network, addr)</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package progress

import "io"

// Tracker updates the status of a descriptor.
type Tracker interface {
        io.Closer

        // Update updates the status of the descriptor.
        Update(status Status) error

        // Fail marks the descriptor as failed.
        // Fail should return nil on successful failure marking.
        Fail(err error) error
}

// TrackerFunc is an adapter to allow the use of ordinary functions as Trackers.
// If f is a function with the appropriate signature, TrackerFunc(f) is a
// [Tracker] that calls f.
type TrackerFunc func(status Status, err error) error

// Close closes the tracker.
func (f TrackerFunc) Close() error <span class="cov3" title="2">{
        return nil
}</span>

// Update updates the status of the descriptor.
func (f TrackerFunc) Update(status Status) error <span class="cov9" title="18">{
        return f(status, nil)
}</span>

// Fail marks the descriptor as failed.
func (f TrackerFunc) Fail(err error) error <span class="cov7" title="8">{
        return f(Status{}, err)
}</span>

// Start starts tracking the transmission.
func Start(t Tracker) error <span class="cov7" title="9">{
        return t.Update(Status{
                State:  StateInitialized,
                Offset: -1,
        })
}</span>

// Done marks the transmission as complete.
// Done should be called after the transmission is complete.
// Note: Reading all content from the reader does not imply the transmission is
// complete.
func Done(t Tracker) error <span class="cov7" title="9">{
        return t.Update(Status{
                State:  StateTransmitted,
                Offset: -1,
        })
}</span>

// TrackReader bind a reader with a tracker.
func TrackReader(t Tracker, r io.Reader) io.Reader <span class="cov8" title="14">{
        rt := readTracker{
                base:    r,
                tracker: t,
        }
        if _, ok := r.(io.WriterTo); ok </span><span class="cov7" title="10">{
                return &amp;readTrackerWriteTo{rt}
        }</span>
        <span class="cov5" title="4">return &amp;rt</span>
}

// readTracker tracks the transmission based on the read operation.
type readTracker struct {
        base    io.Reader
        tracker Tracker
        offset  int64
}

// Read reads from the base reader and updates the status.
// On partial read, the tracker treats it as two reads: a successful read with
// status update and a failed read with failure report.
func (rt *readTracker) Read(p []byte) (int, error) <span class="cov10" title="22">{
        n, err := rt.base.Read(p)
        rt.offset += int64(n)
        if n &gt; 0 </span><span class="cov8" title="13">{
                if updateErr := rt.tracker.Update(Status{
                        State:  StateTransmitting,
                        Offset: rt.offset,
                }); updateErr != nil </span><span class="cov1" title="1">{
                        err = updateErr
                }</span>
        }
        <span class="cov10" title="22">if err != nil &amp;&amp; err != io.EOF </span><span class="cov4" title="3">{
                if failErr := rt.tracker.Fail(err); failErr != nil </span><span class="cov1" title="1">{
                        return n, failErr
                }</span>
        }
        <span class="cov9" title="21">return n, err</span>
}

// readTrackerWriteTo is readTracker with WriteTo support.
type readTrackerWriteTo struct {
        readTracker
}

// WriteTo writes to the base writer and updates the status.
// On partial write, the tracker treats it as two writes: a successful write
// with status update and a failed write with failure report.
func (rt *readTrackerWriteTo) WriteTo(w io.Writer) (int64, error) <span class="cov5" title="5">{
        wt := &amp;writeTracker{
                base:    w,
                tracker: rt.tracker,
                offset:  rt.offset,
        }
        n, err := rt.base.(io.WriterTo).WriteTo(wt)
        rt.offset = wt.offset
        if err != nil &amp;&amp; wt.trackerErr == nil </span><span class="cov3" title="2">{
                if failErr := rt.tracker.Fail(err); failErr != nil </span><span class="cov1" title="1">{
                        return n, failErr
                }</span>
        }
        <span class="cov5" title="4">return n, err</span>
}

// writeTracker tracks the transmission based on the write operation.
type writeTracker struct {
        base       io.Writer
        tracker    Tracker
        offset     int64
        trackerErr error
}

// Write writes to the base writer and updates the status.
// On partial write, the tracker treats it as two writes: a successful write
// with status update and a failed write with failure report.
func (wt *writeTracker) Write(p []byte) (int, error) <span class="cov3" title="2">{
        n, err := wt.base.Write(p)
        wt.offset += int64(n)
        if n &gt; 0 </span><span class="cov3" title="2">{
                if updateErr := wt.tracker.Update(Status{
                        State:  StateTransmitting,
                        Offset: wt.offset,
                }); updateErr != nil </span><span class="cov1" title="1">{
                        wt.trackerErr = updateErr
                        err = updateErr
                }</span>
        }
        <span class="cov3" title="2">if err != nil </span><span class="cov1" title="1">{
                if failErr := wt.tracker.Fail(err); failErr != nil </span><span class="cov0" title="0">{
                        wt.trackerErr = failErr
                        return n, failErr
                }</span>
        }
        <span class="cov3" title="2">return n, err</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package registryutil

import (
        "context"

        "oras.land/oras-go/v2/registry/remote"
        "oras.land/oras-go/v2/registry/remote/auth"
)

// WithScopeHint adds a hinted scope to the context.
func WithScopeHint(ctx context.Context, target any, actions ...string) context.Context <span class="cov0" title="0">{
        if repo, ok := target.(*remote.Repository); ok </span><span class="cov0" title="0">{
                return auth.AppendRepositoryScope(ctx, repo.Reference, actions...)
        }</span>
        <span class="cov0" title="0">return ctx</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package repository

import (
        "fmt"
        "strings"

        "oras.land/oras-go/v2/registry"
)

// ParserRepoPath extracts hostname and namespace from rawReference.
func ParseRepoPath(rawReference string) (hostname, namespace string, err error) <span class="cov10" title="8">{
        rawReference = strings.TrimSuffix(rawReference, "/")
        if strings.Contains(rawReference, "/") </span><span class="cov8" title="6">{
                var ref registry.Reference
                ref, err = registry.ParseReference(rawReference)
                if err != nil </span><span class="cov4" title="2">{
                        return
                }</span>
                <span class="cov7" title="4">if ref.Reference != "" </span><span class="cov1" title="1">{
                        err = fmt.Errorf("tags or digests should not be provided")
                        return
                }</span>
                <span class="cov5" title="3">hostname = ref.Registry
                namespace = ref.Repository + "/"</span>
        } else<span class="cov4" title="2"> {
                hostname = rawReference
        }</span>
        <span class="cov7" title="5">return</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">//go:build freebsd || linux || netbsd || openbsd || solaris

/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package testutils

import (
        "bytes"
        "fmt"
        "io"
        "os"
        "strings"
        "sync"

        containerd "github.com/containerd/console"
)

// NewPty creates a new pty pair for testing, caller is responsible for closing
// the returned device file if err is not nil.
func NewPty() (containerd.Console, *os.File, error) <span class="cov7" title="18">{
        pty, devicePath, err := containerd.NewPty()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov7" title="18">device, err := os.OpenFile(devicePath, os.O_RDWR, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov7" title="18">return pty, device, nil</span>
}

// MatchPty checks that the output matches the expected strings in specified
// order.
func MatchPty(pty containerd.Console, device *os.File, expected ...string) error <span class="cov7" title="15">{
        var wg sync.WaitGroup
        wg.Add(1)
        var buffer bytes.Buffer
        go func() </span><span class="cov7" title="15">{
                defer wg.Done()
                _, _ = io.Copy(&amp;buffer, pty)
        }</span>()
        <span class="cov7" title="15">_ = device.Close()
        wg.Wait()

        return OrderedMatch(buffer.String(), expected...)</span>
}

// OrderedMatch matches the got with the expected strings in order.
func OrderedMatch(got string, want ...string) error <span class="cov7" title="15">{
        for _, e := range want </span><span class="cov10" title="43">{
                i := strings.Index(got, e)
                if i &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find %q in %q", e, got)
                }</span>
                <span class="cov10" title="43">got = got[i+len(e):]</span>
        }
        <span class="cov7" title="15">return nil</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package testutils

import (
        "context"
        "fmt"
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "io"
)

// ErrorFetcher implements content.Fetcher.
type ErrorFetcher struct {
        ExpectedError error
}

// NewErrorFetcher create and error fetcher
func NewErrorFetcher() *ErrorFetcher <span class="cov8" title="1">{
        return &amp;ErrorFetcher{
                ExpectedError: fmt.Errorf("expected error"),
        }
}</span>

// Fetch returns an error.
func (f *ErrorFetcher) Fetch(context.Context, ocispec.Descriptor) (io.ReadCloser, error) <span class="cov8" title="1">{
        return nil, f.ExpectedError
}</span>
</pre>
		
		<pre class="file" id="file120" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package testutils

import (
        "bytes"
        "context"
        "encoding/json"
        "github.com/opencontainers/go-digest"
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras-go/v2/content"
        "oras.land/oras-go/v2/content/memory"
        "oras.land/oras/internal/docker"
)

// MockFetcher implements content.Fetcher and populates a memory store.
type MockFetcher struct {
        store       *memory.Store
        Fetcher     content.Fetcher
        Subject     ocispec.Descriptor
        Config      ocispec.Descriptor
        OciImage    ocispec.Descriptor
        ImageLayer  ocispec.Descriptor
        DockerImage ocispec.Descriptor
        Index       ocispec.Descriptor
}

// NewMockFetcher creates a MockFetcher and populates it.
func NewMockFetcher() (mockFetcher MockFetcher) <span class="cov5" title="7">{
        mockFetcher = MockFetcher{store: memory.New()}
        imageType := "test.image"
        mockFetcher.Config = mockFetcher.PushBlob(imageType, []byte("config content"))
        mockFetcher.ImageLayer = mockFetcher.PushBlob(ocispec.MediaTypeImageLayer, []byte("layer content"))
        mockFetcher.ImageLayer.Annotations = map[string]string{ocispec.AnnotationTitle: "layer"}
        mockFetcher.Subject = mockFetcher.PushOCIImage(nil, mockFetcher.Config)
        mockFetcher.OciImage = mockFetcher.PushOCIImage(&amp;mockFetcher.Subject, mockFetcher.Config, mockFetcher.ImageLayer)
        mockFetcher.OciImage.Annotations = map[string]string{ocispec.AnnotationTitle: "oci-image"}
        mockFetcher.DockerImage = mockFetcher.PushDockerImage(mockFetcher.Config)
        mockFetcher.Index = mockFetcher.PushIndex(mockFetcher.Subject)
        mockFetcher.Fetcher = mockFetcher.store
        return mockFetcher
}</span>

// PushBlob pushes a blob to the memory store.
func (mf *MockFetcher) PushBlob(mediaType string, blob []byte) ocispec.Descriptor <span class="cov10" title="42">{
        desc := ocispec.Descriptor{
                MediaType: mediaType,
                Digest:    digest.FromBytes(blob),
                Size:      int64(len(blob)),
        }
        if err := mf.store.Push(context.Background(), desc, bytes.NewReader(blob)); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov10" title="42">return desc</span>
}

func (mf *MockFetcher) pushImage(subject *ocispec.Descriptor, mediaType string, config ocispec.Descriptor, layers ...ocispec.Descriptor) ocispec.Descriptor <span class="cov8" title="21">{
        manifest := ocispec.Manifest{
                MediaType: mediaType,
                Subject:   subject,
                Config:    config,
                Layers:    layers,
        }
        manifestJSON, err := json.Marshal(manifest)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="21">return mf.PushBlob(mediaType, manifestJSON)</span>
}

// PushOCIImage pushes the given subject, config and layers as a OCI image.
func (mf *MockFetcher) PushOCIImage(subject *ocispec.Descriptor, config ocispec.Descriptor, layers ...ocispec.Descriptor) ocispec.Descriptor <span class="cov7" title="14">{
        return mf.pushImage(subject, ocispec.MediaTypeImageManifest, config, layers...)
}</span>

// PushDockerImage pushes the given subject, config and layers as a Docker image.
func (mf *MockFetcher) PushDockerImage(config ocispec.Descriptor, layers ...ocispec.Descriptor) ocispec.Descriptor <span class="cov5" title="7">{
        return mf.pushImage(nil, docker.MediaTypeManifest, config, layers...)
}</span>

// PushIndex pushes the manifests as an index.
func (mf *MockFetcher) PushIndex(manifests ...ocispec.Descriptor) ocispec.Descriptor <span class="cov5" title="7">{
        index := ocispec.Index{
                Manifests: manifests,
        }
        indexJSON, err := json.Marshal(index)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov5" title="7">return mf.PushBlob(ocispec.MediaTypeImageIndex, indexJSON)</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package testutils

import (
        "io"

        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "oras.land/oras-go/v2"
        "oras.land/oras/internal/progress"
)

// PromptDiscarder mocks trackable GraphTarget with discarded prompt.
type PromptDiscarder struct {
        oras.GraphTarget
        io.Closer
}

// Report discards the prompt.
func (p *PromptDiscarder) Report(ocispec.Descriptor, progress.State) error <span class="cov8" title="1">{
        return nil
}</span>

// ErrorPrompt mocks an errored prompt.
type ErrorPrompt struct {
        oras.GraphTarget
        io.Closer
        wanted error
}

// NewErrorPrompt creates an error prompt.
func NewErrorPrompt(err error) *ErrorPrompt <span class="cov8" title="1">{
        return &amp;ErrorPrompt{
                wanted: err,
        }
}</span>

// Report reports wanted prompt.
func (e *ErrorPrompt) Report(ocispec.Descriptor, progress.State) error <span class="cov8" title="1">{
        return e.wanted
}</span>
</pre>
		
		<pre class="file" id="file122" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package testutils

import "fmt"

type WriteFailure struct {
        count int
        err   error
}

func NewWriteFailure(count int) *WriteFailure <span class="cov6" title="5">{
        return &amp;WriteFailure{
                count: count,
                err:   fmt.Errorf("failed on %d", count),
        }
}</span>

func (wf *WriteFailure) Write(p []byte) (n int, err error) <span class="cov10" title="15">{
        wf.count = wf.count - 1
        if wf.count &lt;= 0 </span><span class="cov6" title="5">{
                return 0, wf.err
        }</span>
        <span class="cov8" title="10">return len(p), nil</span>
}

func (wf *WriteFailure) Expected() string <span class="cov8" title="10">{
        return wf.err.Error()
}</span>
</pre>
		
		<pre class="file" id="file123" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package trace

import (
        "context"

        "github.com/sirupsen/logrus"
)

type contextKey int

// loggerKey is the associated key type for logger entry in context.
const loggerKey contextKey = iota

// NewLogger returns a logger.
func NewLogger(ctx context.Context, debug bool) (context.Context, logrus.FieldLogger) <span class="cov10" title="3">{
        var logLevel logrus.Level
        if debug </span><span class="cov0" title="0">{
                logLevel = logrus.DebugLevel
        }</span> else<span class="cov10" title="3"> {
                logLevel = logrus.WarnLevel
        }</span>

        <span class="cov10" title="3">logger := logrus.New()
        logger.SetFormatter(&amp;TextFormatter{})
        logger.SetLevel(logLevel)
        entry := logger.WithContext(ctx)
        return context.WithValue(ctx, loggerKey, entry), entry</span>
}

// Logger return the logger attached to context or the standard one.
func Logger(ctx context.Context) logrus.FieldLogger <span class="cov0" title="0">{
        logger, ok := ctx.Value(loggerKey).(logrus.FieldLogger)
        if !ok </span><span class="cov0" title="0">{
                return logrus.StandardLogger()
        }</span>
        <span class="cov0" title="0">return logger</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package trace

import (
        "bytes"
        "fmt"
        "strings"
        "time"

        "github.com/sirupsen/logrus"
)

// TextFormatter formats logs into text.
type TextFormatter struct{}

// logEntrySeperator is the separator between log entries.
const logEntrySeperator = "\n\n" // two empty lines

// Format renders a single log entry.
func (f *TextFormatter) Format(entry *logrus.Entry) ([]byte, error) <span class="cov10" title="4">{
        var buf bytes.Buffer

        timestamp := entry.Time.Format(time.RFC3339Nano)
        levelText := strings.ToUpper(entry.Level.String())
        fmt.Fprintf(&amp;buf, "[%s][%s]: %s\n", timestamp, levelText, entry.Message)
        // print data fields
        if len(entry.Data) &gt; 0 </span><span class="cov5" title="2">{
                buf.WriteString("[Data]:\n")
                for k, v := range entry.Data </span><span class="cov5" title="2">{
                        fmt.Fprintf(&amp;buf, "  %s=%v\n", k, v)
                }</span>
        }

        <span class="cov10" title="4">buf.WriteString(logEntrySeperator)
        return buf.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package trace

import (
        "bytes"
        "fmt"
        "io"
        "mime"
        "net/http"
        "strings"
        "sync/atomic"
)

var (
        // requestCount records the number of logged request-response pairs and will
        // be used as the unique id for the next pair.
        requestCount uint64

        // toScrub is a set of headers that should be scrubbed from the log.
        toScrub = []string{
                "Authorization",
                "Set-Cookie",
        }
)

// payloadSizeLimit limits the maximum size of the response body to be printed.
const payloadSizeLimit int64 = 16 * 1024 // 16 KiB

// Transport is an http.RoundTripper that keeps track of the in-flight
// request and add hooks to report HTTP tracing events.
type Transport struct {
        http.RoundTripper
}

// NewTransport creates and returns a new instance of Transport
func NewTransport(base http.RoundTripper) *Transport <span class="cov0" title="0">{
        return &amp;Transport{
                RoundTripper: base,
        }
}</span>

// RoundTrip calls base roundtrip while keeping track of the current request.
func (t *Transport) RoundTrip(req *http.Request) (resp *http.Response, err error) <span class="cov0" title="0">{
        id := atomic.AddUint64(&amp;requestCount, 1) - 1
        ctx := req.Context()
        e := Logger(ctx)

        // log the request
        e.Debugf("--&gt; Request #%d\n&gt; Request URL: %q\n&gt; Request method: %q\n&gt; Request headers:\n%s",
                id, req.URL, req.Method, logHeader(req.Header))

        // log the response
        resp, err = t.RoundTripper.RoundTrip(req)
        if err != nil </span><span class="cov0" title="0">{
                e.Errorf("&lt;-- Response #%d\nError in getting response: %v", id, err)
        }</span> else<span class="cov0" title="0"> if resp == nil </span><span class="cov0" title="0">{
                e.Errorf("&lt;-- Response #%d\nNo response obtained for request %s %q", id, req.Method, req.URL)
        }</span> else<span class="cov0" title="0"> {
                e.Debugf("&lt;-- Response #%d\n&lt; Response Status: %q\n&lt; Response headers:\n%s\n&lt; Response body:\n%s",
                        id, resp.Status, logHeader(resp.Header), logResponseBody(resp))
        }</span>
        <span class="cov0" title="0">return resp, err</span>
}

// logHeader prints out the provided header keys and values, with auth header
// scrubbed.
func logHeader(header http.Header) string <span class="cov0" title="0">{
        if len(header) &gt; 0 </span><span class="cov0" title="0">{
                headers := []string{}
                for k, v := range header </span><span class="cov0" title="0">{
                        for _, h := range toScrub </span><span class="cov0" title="0">{
                                if strings.EqualFold(k, h) </span><span class="cov0" title="0">{
                                        v = []string{"*****"}
                                }</span>
                        }
                        <span class="cov0" title="0">headers = append(headers, fmt.Sprintf("   %q: %q", k, strings.Join(v, ", ")))</span>
                }
                <span class="cov0" title="0">return strings.Join(headers, "\n")</span>
        }
        <span class="cov0" title="0">return "   Empty header"</span>
}

// logResponseBody prints out the response body if it is printable and within
// the size limit.
func logResponseBody(resp *http.Response) string <span class="cov8" title="16">{
        if resp.Body == nil || resp.Body == http.NoBody </span><span class="cov2" title="2">{
                return "   No response body to print"
        }</span>

        // non-applicable body is not printed and remains untouched for subsequent processing
        <span class="cov8" title="14">contentType := resp.Header.Get("Content-Type")
        if contentType == "" </span><span class="cov2" title="2">{
                return "   Response body without a content type is not printed"
        }</span>
        <span class="cov7" title="12">if !isPrintableContentType(contentType) </span><span class="cov1" title="1">{
                return fmt.Sprintf("   Response body of content type %q is not printed", contentType)
        }</span>

        <span class="cov7" title="11">buf := bytes.NewBuffer(nil)
        body := resp.Body
        // restore the body by concatenating the read body with the remaining body
        resp.Body = struct {
                io.Reader
                io.Closer
        }{
                Reader: io.MultiReader(buf, body),
                Closer: body,
        }
        // read the body up to limit+1 to check if the body exceeds the limit
        if _, err := io.CopyN(buf, body, payloadSizeLimit+1); err != nil &amp;&amp; err != io.EOF </span><span class="cov1" title="1">{
                return fmt.Sprintf("   Error reading response body: %v", err)
        }</span>

        <span class="cov7" title="10">readBody := buf.String()
        if len(readBody) == 0 </span><span class="cov1" title="1">{
                return "   Response body is empty"
        }</span>
        <span class="cov6" title="9">if containsCredentials(readBody) </span><span class="cov2" title="2">{
                return "   Response body redacted due to potential credentials"
        }</span>
        <span class="cov6" title="7">if len(readBody) &gt; int(payloadSizeLimit) </span><span class="cov2" title="2">{
                return readBody[:payloadSizeLimit] + "\n...(truncated)"
        }</span>
        <span class="cov5" title="5">return readBody</span>
}

// isPrintableContentType returns true if the content of contentType is printable.
func isPrintableContentType(contentType string) bool <span class="cov10" title="29">{
        mediaType, _, err := mime.ParseMediaType(contentType)
        if err != nil </span><span class="cov3" title="3">{
                return false
        }</span>

        <span class="cov9" title="26">switch mediaType </span>{
        case "application/json", // JSON types
                "text/plain", "text/html":<span class="cov8" title="17"> // text types
                return true</span>
        }
        <span class="cov6" title="9">return strings.HasSuffix(mediaType, "+json")</span>
}

// containsCredentials returns true if the body contains potential credentials.
func containsCredentials(body string) bool <span class="cov8" title="17">{
        return strings.Contains(body, `"token"`) || strings.Contains(body, `"access_token"`)
}</span>
</pre>
		
		<pre class="file" id="file126" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package tree pretty prints trees
package tree

import "reflect"

// Node represents a tree node.
type Node struct {
        Value any
        Nodes []*Node
}

// New creates a new tree / root node.
func New(value any) *Node <span class="cov10" title="18">{
        return &amp;Node{
                Value: value,
        }
}</span>

// Add adds a leaf node.
func (n *Node) Add(value any) *Node <span class="cov9" title="16">{
        node := New(value)
        n.Nodes = append(n.Nodes, node)
        return node
}</span>

// AddPath adds a chain of nodes.
func (n *Node) AddPath(values ...any) *Node <span class="cov7" title="8">{
        if len(values) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov7" title="7">current := n
        for _, value := range values </span><span class="cov8" title="11">{
                if node := current.Find(value); node == nil </span><span class="cov8" title="10">{
                        current = current.Add(value)
                }</span> else<span class="cov1" title="1"> {
                        current = node
                }</span>
        }
        <span class="cov7" title="7">return current</span>
}

// Find finds the child node with the target value.
// Nil if not found.
func (n *Node) Find(value any) *Node <span class="cov9" title="14">{
        for _, node := range n.Nodes </span><span class="cov7" title="9">{
                if reflect.DeepEqual(node.Value, value) </span><span class="cov3" title="2">{
                        return node
                }</span>
        }
        <span class="cov8" title="12">return nil</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tree

import (
        "fmt"
        "io"
        "os"
)

// Box-drawing symbols
const (
        EdgeEmpty = "    "
        EdgePipe  = "   "
        EdgeItem  = " "
        EdgeLast  = " "
)

// DefaultPrinter prints the tree to the stdout with default settings.
var DefaultPrinter = NewPrinter(os.Stdout)

// Printer prints the tree.
type Printer struct {
        writer io.Writer
}

// NewPrinter create s a new printer.
func NewPrinter(writer io.Writer) *Printer <span class="cov7" title="18">{
        return &amp;Printer{
                writer: writer,
        }
}</span>

// Print prints a tree.
func (p *Printer) Print(root *Node) error <span class="cov6" title="11">{
        return p.print("", root)
}</span>

// print prints a tree recursively.
func (p *Printer) print(prefix string, n *Node) error <span class="cov10" title="50">{
        if _, err := fmt.Fprintln(p.writer, n.Value); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="50">size := len(n.Nodes)
        if size == 0 </span><span class="cov8" title="27">{
                return nil
        }</span>

        <span class="cov8" title="23">prefixItem := prefix + EdgeItem
        prefixPipe := prefix + EdgePipe
        last := size - 1
        for _, n := range n.Nodes[:last] </span><span class="cov7" title="16">{
                if _, err := io.WriteString(p.writer, prefixItem); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov7" title="16">if err := p.print(prefixPipe, n); err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov8" title="23">if _, err := io.WriteString(p.writer, prefix+EdgeLast); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="23">return p.print(prefix+EdgeEmpty, n.Nodes[last])</span>
}

// Print prints the tree using the default printer.
func Print(root *Node) error <span class="cov0" title="0">{
        return DefaultPrinter.Print(root)
}</span>
</pre>
		
		<pre class="file" id="file128" style="display: none">/*
Copyright The ORAS Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package version

var (
        // Version is the current version of the oras.
        Version = "1.3.0-beta.3"
        // BuildMetadata is the extra build time data
        BuildMetadata = "unreleased"
        // GitCommit is the git sha1
        GitCommit = ""
        // GitTreeState is the state of the git tree
        GitTreeState = ""
)

// GetVersion returns the semver string of the version
func GetVersion() string <span class="cov10" title="9">{
        if BuildMetadata == "" </span><span class="cov1" title="1">{
                return Version
        }</span>
        <span class="cov9" title="8">return Version + "+" + BuildMetadata</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
